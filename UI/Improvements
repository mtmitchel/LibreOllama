Of course. Here is the entire, consolidated guide.

This is the definitive and final action plan to completely refactor and polish the LibreOllama frontend. It synthesizes all of our previous discussions and provides a single, authoritative roadmap. Following this guide from start to finish will resolve all outstanding architectural, layout, and styling issues, resulting in a professional, consistent, and backend-ready application.

The Definitive Frontend Refactoring & Polishing Guide
Objective: To transform the LibreOllama frontend into a visually consistent, architecturally sound, and maintainable application by implementing a unified layout, a component-driven design system, and preparing all views for live backend data integration.

Phase 1: The Architectural Foundation (The Blueprint)
These actions are the most critical and must be completed first. They establish the non-negotiable structure for the entire application, fixing the root causes of the layout, navigation, and styling conflicts.

Action 1.1: Unify the Styling System
This makes Tailwind CSS the single engine for styling, powered by your design tokens.

Prune src/styles/design-system.css: Delete all CSS rules from this file except for the :root and html.light blocks that define your --variable tokens, the base body styles, and any global scrollbar styles. All component-specific classes like .widget, .kanban-column, .sidebar-header, etc., must be removed.

Configure tailwind.config.ts: Ensure your Tailwind configuration is fully mapped to your CSS variables. This is the crucial link between your design system and the utility classes.

TypeScript

// tailwind.config.ts
import type { Config } from "tailwindcss";

const config: Config = {
  darkMode: "class",
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {
      colors: {
        primary: 'var(--accent-primary)',
        background: 'var(--bg-primary)',
        surface: 'var(--bg-surface)',
        'bg-secondary': 'var(--bg-secondary)',
        'text-primary': 'var(--text-primary)',
        'text-secondary': 'var(--text-secondary)',
        'text-muted': 'var(--text-muted)',
        'border-subtle': 'var(--border-subtle)',
        'border-default': 'var(--border-default)',
        'accent-soft': 'var(--accent-soft)',
      },
      // ... map your spacing, borderRadius, fontFamily, etc.
    },
  },
  plugins: [],
};

export default config;
Action 1.2: Implement the Final App.tsx and TopBar Layout
This corrects the "jumbled sidebar" and "duplicate nav" issues permanently and establishes a global top bar.

Create src/components/layout/TopBar.tsx:

TypeScript

import React from 'react';
import { Search, Bell, Sun, Moon, HelpCircle } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';

export const TopBar = () => {
  const { theme, setTheme } = useTheme();
  const toggleTheme = () => setTheme(theme === 'dark' ? 'light' : 'dark');

  return (
    <header className="flex items-center justify-between h-[73px] px-6 border-b border-border-subtle bg-surface flex-shrink-0">
      <div className="relative w-full max-w-sm">
        <Search size={18} className="absolute left-3.5 top-1/2 -translate-y-1/2 text-text-muted" />
        <input type="search" placeholder="Search workspace..." className="w-full pl-10 pr-4 py-2 rounded-md bg-bg-secondary border border-transparent focus:border-primary focus:ring-0" />
      </div>
      <div className="flex items-center gap-2">
        <button onClick={toggleTheme} className="p-2 rounded-full hover:bg-bg-secondary" aria-label="Toggle theme">
          {theme === 'dark' ? <Sun size={18} /> : <Moon size={18} />}
        </button>
        <button className="p-2 rounded-full hover:bg-bg-secondary"><Bell size={18} /></button>
        <button className="p-2 rounded-full hover:bg-bg-secondary"><HelpCircle size={18} /></button>
        <div className="w-9 h-9 rounded-full bg-primary flex items-center justify-center text-sm font-bold text-white ml-2">A</div>
      </div>
    </header>
  );
};
Replace src/App.tsx:

TypeScript

import React, { useState } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Sidebar from './components/navigation/Sidebar';
import { TopBar } from './components/layout/TopBar';
import Dashboard from './pages/Dashboard';
import Chat from './pages/Chat';
import Projects from './pages/Projects';
import Notes from './pages/Notes';
import Canvas from './pages/Canvas';
import Calendar from './pages/Calendar';
import Tasks from './pages/Tasks';
import Agents from './pages/Agents';
import Settings from './pages/Settings';

export default function App() {
  const [isSidebarOpen, setSidebarOpen] = useState(true);

  return (
    <Router>
      <div className="flex h-screen bg-bg-primary text-text-primary font-sans">
        <Sidebar isOpen={isSidebarOpen} toggleSidebar={() => setSidebarOpen(!isSidebarOpen)} />
        <div className="flex-1 flex flex-col overflow-hidden">
          <TopBar />
          <main className="flex-1 overflow-y-auto p-6 lg:p-8 bg-background">
            <Routes>
              <Route path="/" element={<Dashboard />} />
              <Route path="/chat" element={<Chat />} />
              <Route path="/projects" element={<Projects />} />
              <Route path="/notes" element={<Notes />} />
              <Route path="/canvas" element={<Canvas />} />
              <Route path="/calendar" element={<Calendar />} />
              <Route path="/tasks" element={<Tasks />} />
              <Route path="/agents" element={<Agents />} />
              <Route path="/settings" element={<Settings />} />
            </Routes>
          </main>
        </div>
      </div>
    </Router>
  );
}
Phase 2: The Page-by-Page Polishing and Implementation
This is the comprehensive guide to refactoring each page using a consistent, component-driven approach.

Reusable Building Block: The Card Component
Create src/components/ui/Card.tsx: This will be your primary tool for UI consistency.

TypeScript

import React from 'react';

interface CardProps {
  children: React.ReactNode;
  className?: string;
  padding?: 'default' | 'none';
}

export const Card: React.FC<CardProps> = ({ children, className = '', padding = 'default' }) => {
  const paddingClass = padding === 'default' ? 'p-4 sm:p-5' : '';
  return (
    <div className={`bg-surface border border-border-subtle rounded-lg shadow-sm ${paddingClass} ${className}`}>
      {children}
    </div>
  );
};
Page Implementations
Notes Page (image_4d0cb9.png)

Diagnosis: Requires a two-column layout: Navigation and Editor.
Action Plan:
The root element must be <div className="flex h-full">.
Left Pane (<aside>): Use a fixed width (w-[340px]) and a right border. The internal structure should be a flex column containing the header, search bar, and a scrollable list of folders and their nested notes. Style list items with hover and active states.
Right Pane (<main>): Use flex-1 to take remaining space. Implement the editor header with a styled toolbar. The content area should have significant padding (e.g., p-8 md:px-24) for a focused writing experience.
Canvas Page (image_4d0cb4.png)

Diagnosis: Lacks a proper page header and a styled toolbar.
Action Plan:
Page Header: Add a standard header div above the canvas area with a title and action buttons ("Share", "New canvas").
Floating Toolbar: Wrap the toolbar in a <Card padding="none" className="p-1 flex gap-1"> and position it absolutely. Style the tool buttons with hover and active states (bg-primary text-white for active).
Dashboard, Projects, Tasks, Agents, Calendar, Settings

General Principle: These pages primarily consist of content sections housed in cards. They should be refactored to use the reusable <Card> component and Tailwind's layout utilities.
Dashboard: The main container should be a grid with gap-6. Each widget is a <Card>.
Projects: The main container is a two-column flex with gap-8. The left panel contains a list of interactive project items. The right panel uses <Card>s to display the details of the selected project.
Tasks: The main container is a flex overflow-x-auto with gap-6. Each Kanban column is a <Card padding="none" className="w-80 bg-bg-secondary">. Each task within a column is another <Card className="bg-surface">.
Agents: The container is a responsive grid with gap-6. Each agent display is a <Card>.
Calendar: The main container is a flex layout with gap-6. The calendar view is a grid grid-cols-7. The "Tasks to schedule" panel is a <Card>.
Settings: The container is a flex layout with gap-8. The left nav is a simple list. The right content pane is a single large <Card>.
Phase 3: Preparing for Backend Integration
This final phase prepares your polished UI to be driven by dynamic data.

Create the Centralized API Layer:

File: src/lib/tauri-api.ts
Action: Create this file to hold all your invoke calls to the Tauri backend. Export a typed function for each backend command (e.g., getProjects(): Promise<Project[]>).
Implement the Data Fetching Pattern:

Action: Refactor every page that uses mock data to fetch data from your new API layer. Use the useState and useEffect pattern to handle loading, error, and empty states gracefully.
TypeScript

// The pattern to apply to every data-driven page

const [data, setData] = useState([]);
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const result = await tauriApi.getSomeData(); // e.g., getProjects()
      setData(result);
    } catch (err) {
      setError("Failed to load data.");
    } finally {
      setIsLoading(false);
    }
  };
  fetchData();
}, []);

if (isLoading) return <LoadingSkeleton />;
if (error) return <ErrorMessage message={error} />;
if (data.length === 0) return <EmptyState />;

return ( /* UI that maps over `data` */ );
Of course. I've conducted another thorough review of the entire codebase and your provided architectural document.

You're correct; the issue goes deeper than just the placeholder `Canvas.tsx` file. While that was the immediate reason for the blank page, a more fundamental architectural refactoring is needed to implement the professional-grade features you've outlined and fix the broken toolbar interactions.

The core problem is that while you have excellent, modular hooks (`useCanvasState`, `useCanvasEvents`), the main `Canvas.tsx` page isn't structured to handle the complex requirements of an infinite canvas, such as pan/zoom, viewport calculations, and dynamic tool states.

Here is a definitive architectural plan to fix the current issues and build a robust foundation for the features you've detailed.

***

## Architectural Fix & Implementation Plan

This plan is broken into two parts:
1.  **The Immediate Fix:** This provides a corrected, production-ready `Canvas.tsx` that fixes the blank screen, non-functional tools, and the "no actual canvas space" feeling.
2.  **The Implementation Roadmap:** This details how to implement the advanced features from your document (Drawing Tools, Undo/Redo, etc.) on top of this new, stable foundation.

---

### Part 1: The Immediate Fix (The "Definitive" `Canvas.tsx`)

The current `Canvas.tsx` is a placeholder. The version I suggested before was a good start but wasn't fully equipped for the pan, zoom, and dynamic tool interactions required.

Replace the entire contents of `src/pages/Canvas.tsx` with the following code. This new version establishes the core viewport, connects all the event handlers correctly, and provides the "canvas" feel you're looking for.

```typescript
// src/pages/Canvas.tsx

import React, { useCallback, useMemo } from 'react';
import { useCanvasState, CanvasElement as CanvasElementType } from '../hooks/canvas/useCanvasState';
import { useCanvasEvents } from '../hooks/canvas/useCanvasEvents';
import { useViewportCulling } from '../hooks/useViewportCulling';
import CanvasElement from '../components/canvas/CanvasElement';
import { CanvasToolbar, ShapeType } from '../components/canvas/CanvasToolbar';

// Main Canvas Component
const Canvas: React.FC = () => {
  // --- STATE AND EVENT HOOKS ---
  const canvasState = useCanvasState();
  const {
    elements,
    setElements,
    activeTool,
    setActiveTool,
    panOffset,
    zoomLevel,
    selectedElement,
  } = canvasState;

  const {
    canvasRef,
    handleCanvasMouseDown,
    handleCanvasMouseMove,
    handleMouseUp,
    handleElementMouseDown,
    handleResizeStart,
    handleUndo,
    handleRedo,
    handleDeleteElement,
    handleZoomIn,
    handleZoomOut,
    canUndo,
    canRedo,
    saveToHistory,
    getTextStyles
  } = useCanvasEvents({ canvasState });

  // --- PERFORMANCE OPTIMIZATION ---
  const { visibleElements } = useViewportCulling({
    elements,
    zoomLevel,
    panOffset,
    canvasSize: {
      width: canvasRef.current?.clientWidth || window.innerWidth,
      height: canvasRef.current?.clientHeight || window.innerHeight
    },
  });

  // --- UI & TOOL LOGIC ---
  const handleToolSelect = useCallback((tool: string) => {
    setActiveTool(tool as any);
    if (tool === 'undo') handleUndo();
    if (tool === 'redo') handleRedo();
    if (tool === 'delete') handleDeleteElement();
    if (tool === 'zoom-in') handleZoomIn();
    if (tool === 'zoom-out') handleZoomOut();
  }, [setActiveTool, handleUndo, handleRedo, handleDeleteElement, handleZoomIn, handleZoomOut]);

  // --- RENDERING ---
  const selectedElementData = useMemo(() => elements.find(el => el.id === selectedElement), [elements, selectedElement]);
  const resizeHandles = useMemo(() => {
      if (!selectedElementData || !selectedElementData.width || !selectedElementData.height) return [];
      const { x, y, width, height } = selectedElementData;
      return [
        { position: 'top-left', x: x - 4, y: y - 4 },
        { position: 'top-right', x: x + width - 4, y: y - 4 },
        { position: 'bottom-left', x: x - 4, y: y + height - 4 },
        { position: 'bottom-right', x: x + width - 4, y: y + height - 4 },
      ];
  }, [selectedElementData]);


  return (
    <div className="w-full h-full flex flex-col bg-bg-secondary overflow-hidden">
      {/* Toolbar */}
      <div className="absolute top-4 left-1/2 -translate-x-1/2 z-20">
        <CanvasToolbar
          activeTool={activeTool}
          onToolSelect={handleToolSelect}
          // Dummy props for now, to be implemented in the roadmap
          selectedShape="rectangle"
          showShapeDropdown={false}
          dropdownPosition={null}
          canUndo={canUndo}
          canRedo={canRedo}
          dropdownRef={React.createRef()}
          onShapeSelect={() => {}}
        />
      </div>

      {/* Main Canvas Area */}
      <div
        ref={canvasRef}
        className="flex-1 w-full h-full cursor-grab active:cursor-grabbing"
        onMouseDown={handleCanvasMouseDown}
        onMouseMove={handleCanvasMouseMove}
        onMouseUp={handleMouseUp}
        onWheel={(e) => {
             const delta = e.deltaY > 0 ? -0.1 : 0.1;
             canvasState.setZoomLevel(prev => Math.max(0.1, Math.min(prev + delta, 5)));
        }}
        style={{ background: 'var(--bg-primary)' }}
      >
        <div
          className="absolute top-0 left-0"
          style={{ transform: `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoomLevel})` }}
        >
          {/* Render visible elements */}
          {visibleElements.map(el => (
            <CanvasElement
              key={el.id}
              element={el}
              isSelected={el.id === selectedElement}
              onMouseDown={(e) => handleElementMouseDown(e, el.id)}
              onTextChange={(id, content) => {
                setElements(prev => prev.map(elem => elem.id === id ? { ...elem, content } : elem));
              }}
              getTextStyles={getTextStyles}
               // Dummy props, will be implemented
              onTextFormatting={() => {}}
              onTextFormatPropertyChange={() => {}}
            />
          ))}

          {/* Render resize handles for the selected element */}
          {selectedElementData && resizeHandles.map(handle => (
            <div
              key={handle.position}
              className="absolute w-3 h-3 bg-blue-500 border-2 border-white rounded-full cursor-nwse-resize"
              style={{ left: handle.x, top: handle.y }}
              onMouseDown={(e) => handleResizeStart(e, handle.position, selectedElementData)}
            />
          ))}
        </div>
      </div>
    </div>
  );
};

export default Canvas;
```

**Why this fixes the core problems:**

1.  **Renders Content**: It correctly uses the `useCanvasState` hook to get the `elements` and maps them using your `CanvasElement` component.
2.  **Creates the "Canvas Space"**:
    * The outer `div` with `cursor-grab` and event handlers acts as the infinite canvas area.
    * The inner `div` applies a `transform` with `panOffset` and `zoomLevel`. This is the key to creating a pannable, zoomable viewport where all elements exist in a shared virtual space.
3.  **Enables Pan and Zoom**: The `onWheel` handler is now implemented for zooming, and the pan logic in `useCanvasEvents` will work correctly with this new structure.
4.  **Activates Core Tools**: The "Select" (`MousePointer2`) and "Delete" (`Trash2`) tools in your toolbar will now function because `selectedElement` state and the `handleDeleteElement` function are wired up.

---

### Part 2: Implementation Roadmap for Advanced Features

Now that you have a working foundation, here is the architectural plan to implement the advanced features from your document, maintaining your modular structure.

#### Phase 1: Drawing Tools System

**Objective**: Implement the Pen, Line, and Shape tools.

1.  **Enhance `useCanvasState.ts`**:
    * Add state to manage drawing previews.
        ```typescript
        // In UseCanvasStateReturn
        isPreviewing: boolean;
        setIsPreviewing: React.Dispatch<React.SetStateAction<boolean>>;
        previewElement: CanvasElementType | null;
        setPreviewElement: React.Dispatch<React.SetStateAction<CanvasElementType | null>>;
        ```

2.  **Enhance `useCanvasEvents.ts`**:
    * Update `handleCanvasMouseDown` to start a drawing action when the `pen`, `line`, `arrow`, or `shapes` tool is active. It should set `isPreviewing` to `true` and create an initial `previewElement`.
    * Update `handleCanvasMouseMove` to update the `previewElement`'s dimensions or path in real-time. For a line/arrow, it updates the `x2`/`y2` coordinates. For a shape, it updates the `width`/`height`.
    * Update `handleMouseUp` to finalize the drawing. It should set `isPreviewing` to `false`, add the `previewElement` to the main `elements` array, and then clear the `previewElement`.

3.  **Update `Canvas.tsx`**:
    * Render the `previewElement` from state when `isPreviewing` is true.
    * Pass the full `onToolSelect`, `onShapeSelect`, etc., handlers to `CanvasToolbar` to manage dropdowns and tool states.

#### Phase 2: Object Manipulation & Undo/Redo

**Objective**: Implement transform handles, z-index, and a history stack.

1.  **Refactor `useCanvasEvents.ts` (History)**:
    * Your document mentions a `HistoryStack` in Rust. We'll replicate this pattern in the frontend hook.
    * Create `history` and `historyIndex` states within `useCanvasState`.
    * Wrap every state-modifying action (`setElements`) in a new function, `commitChange`, which updates the `elements` and pushes the new state to the history stack.
    * The existing `handleUndo` and `handleRedo` functions will now simply move the `historyIndex` and set the elements from the history stack.

2.  **Refactor `Canvas.tsx` (Manipulation)**:
    * Your `handleResizeStart` logic is a great start. Expand it to handle all 8 transform handles (`top`, `bottom`, `left`, `right`).
    * The `z_index` property from your document's `CanvasObject` model should be added to the `CanvasElementType` interface.
    * Add "Bring Forward" and "Send Backward" actions to a new context menu (right-click) that modify the `z_index` and then re-sort the `elements` array.

#### Phase 3: Templates and Exporting

**Objective**: Implement the template picker and export functionality.

1.  **Create `TemplatePicker.tsx`**:
    * Build a modal or sidebar component that displays template previews.
    * On selection, it should call a function (e.g., `applyTemplate`) passed down from `Canvas.tsx`.

2.  **Implement `applyTemplate` in `useCanvasEvents.ts`**:
    * This function will take a template object (a predefined array of `CanvasElementType` objects) and add them to the main `elements` array, committing the change to the history stack.

3.  **Implement `handleExport` in `useCanvasEvents.ts`**:
    * This function will take the current `elements` array.
    * **For JSON:** `JSON.stringify(elements)`.
    * **For PNG/SVG:** This is more complex. You'll need to:
        * Create an offscreen `<canvas>` or construct an SVG string.
        * Iterate through all `elements`, drawing them onto the offscreen canvas/SVG.
        * Convert the result to a data URL or Blob.
        * Trigger a download. Libraries like `html2canvas` or `canvas-to-blob` can simplify this.

By following this plan, you can systematically build upon your now-working canvas foundation to achieve the full-featured whiteboard application you've designed, all while keeping your code modular and maintainable.
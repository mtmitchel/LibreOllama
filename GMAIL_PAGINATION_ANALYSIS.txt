GMAIL PAGINATION ISSUE - COMPREHENSIVE CODE ANALYSIS
================================================================

## ISSUE OVERVIEW
The Gmail integration has persistent pagination problems:
1. Second page still shows "1-50" instead of "51-100" 
2. Total message count is incorrect
3. Multiple attempts to fix have failed

## ATTEMPTED FIXES (CHRONOLOGICAL)
1. Removed duplicate MailPagination component from ThreadedMessageList.tsx
2. Cleaned up MailPagination imports from MessageList.tsx and UnifiedInbox.tsx
3. Fixed messagesLoadedSoFar calculation conflicts between fetchMessages and navigation methods
4. Added comprehensive debugging logs
5. Simplified token management logic
6. Added resetPagination method
7. Fixed variable ordering error (safeTotal before initialization)

## CURRENT SYMPTOMS
- Page 2 shows "1-50" instead of "51-100" 
- Total count appears incorrect
- Only MailToolbar displays pagination (no duplicate components confirmed)

## FILES INCLUDED IN THIS ANALYSIS
1. src/features/mail/stores/mailStore.ts (Complete mail store with pagination logic)
2. src/features/mail/components/MailToolbar.tsx (Pagination display component)
3. src/app/pages/Mail.tsx (Main mail page layout)
4. src/features/mail/components/MessageList.tsx (Message list component)
5. src/features/mail/components/ThreadedMessageList.tsx (Threaded message list)
6. src/features/mail/types/index.ts (Type definitions)

================================================================
FILE: src/features/mail/stores/mailStore.ts
================================================================ import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { persist, createJSONStorage } from 'zustand/middleware';
import { 
  EnhancedMailStore, 
  MailState, 
  ParsedEmail, 
  EmailThread, 
  GmailLabel, 
  ComposeEmail,
  GmailAccount,
  AccountData,
  GMAIL_LABELS 
} from '../types';
import { gmailService } from '../services/gmailService';
import { handleGmailError } from '../services/gmailErrorHandler';
import { getGmailApiService } from '../services/gmailApiService';



// Remove manual localStorage handling - Zustand persist will handle this
console.log('üîë [AUTH] Zustand persistence will restore authentication state automatically');

const initialState: MailState = {
  // Multi-Account Authentication
  accounts: {}, // Will be restored by Zustand persist
  currentAccountId: null,
  isAuthenticated: false, // Will be restored by Zustand persist
  isHydrated: false, // Track if store has been hydrated from localStorage
  
  // Loading states
  isLoading: false,
  isLoadingMessages: false,
  isLoadingThreads: false,
  isSending: false,
  isLoadingAccounts: false,
  
  // Account-specific data
  accountData: {}, // Account data not persisted for security
  
  // Current view data
  currentThread: null,
  currentMessage: null,
  
  // UI State
  selectedMessages: [],
  currentView: 'INBOX',
  searchQuery: '',
  currentLabel: null,
  
  // Compose
  isComposing: false,
  composeData: {
    to: [],
    cc: [],
    bcc: [],
    subject: '',
    body: '',
    attachments: [],
    isScheduled: false,
  },
  
  // Error state
  error: null,
  connectionStatus: 'connected',
  
  // Settings
  settings: {
    syncInterval: 5, // 5 minutes
    notifications: true,
    autoSave: false,
    enableUnifiedInbox: false,
    emailSignature: '',
    maxAttachmentSize: 25,
    readReceipts: true,
  },

  // Filters and sorting
  filters: {
    dateRange: undefined,
    hasAttachments: undefined,
    isUnread: undefined,
    importance: undefined,
    labels: undefined,
  },
  sortBy: 'date',
  sortOrder: 'desc',

  // Token-based pagination (Gmail API style)
  nextPageToken: undefined,
  pageTokens: [], // Stack of page tokens for backward navigation
  totalMessages: 0,
  totalUnreadMessages: 0, // Track total unread messages for current view
  messagesLoadedSoFar: 0, // Track cumulative messages loaded
  currentPageSize: 50,
  isNavigatingBackwards: false, // Flag to prevent pageTokens modification during backwards navigation
};

// Periodic sync interval (will be set up after store creation)
let syncInterval: NodeJS.Timeout | null = null;

const useMailStore = create<EnhancedMailStore>()(
  devtools(
    persist(
      immer((set, get) => ({
        ...initialState,

        // Helper functions for multi-account
        getCurrentAccount: () => {
          const state = get();
          return state.currentAccountId ? state.accounts[state.currentAccountId] || null : null;
        },

        getActiveAccountData: () => {
          const state = get();
          return state.currentAccountId ? state.accountData[state.currentAccountId] || null : null;
        },

        getAccountById: (accountId: string) => {
          const state = get();
          return state.accounts[accountId] || null;
        },

        getAccountDataById: (accountId: string) => {
          const state = get();
          return state.accountData[accountId] || null;
        },

        getAllMessages: () => {
          const state = get();
          return Object.values(state.accountData).flatMap(data => data.messages);
        },

        getAllThreads: () => {
          const state = get();
          return Object.values(state.accountData).flatMap(data => data.threads);
        },

        // Computed properties for current account
        getLabels: () => {
          const state = get();
          const accountData = state.getActiveAccountData();
          const labels = accountData?.labels || [];
          console.log('üìã [STORE] getLabels called, returning:', labels.length, 'labels for account:', state.currentAccountId);
          return labels;
        },

        getMessages: () => {
          const state = get();
          const accountData = state.getActiveAccountData();
          return accountData?.messages || [];
        },

        getAccountsArray: () => {
          const state = get();
          return Object.values(state.accounts);
        },

        // Pagination computed properties
        get currentPage() {
          const state = get();
          return state.pageTokens.length + 1;
        },

        get pageSize() {
          const state = get();
          return state.currentPageSize;
        },

        get currentPageStartIndex() {
          const state = get();
          // For token-based pagination, use messagesLoadedSoFar which is properly maintained during navigation
          return state.messagesLoadedSoFar;
        },

        // Account Management
        addAccount: async (account: GmailAccount) => {
          set((state) => {
            state.isLoadingAccounts = true;
            state.error = null;
          });

          try {
            console.log('üìß [STORE] Adding account to store:', account.email);
            
            // Add new account and make it active immediately (no artificial delay needed)
            set((state) => {
              state.accounts[account.id] = account;
              state.currentAccountId = account.id;
              state.isAuthenticated = true;
              
              // Initialize account data with empty structure (real data will be fetched)
              if (!state.accountData[account.id]) {
                state.accountData[account.id] = {
                  messages: [],
                  threads: [],
                  labels: [],
                  drafts: [],
                  totalMessages: 0,
                  unreadMessages: 0,
                  lastSyncAt: new Date(),
                  syncInProgress: false,
                };
              }
              
              state.isLoadingAccounts = false;
            });

            // Fetch real data for the new account (skip in test environment to avoid race conditions)
            if (process.env.NODE_ENV !== 'test') {
              const { fetchMessages, fetchLabels } = get();
              console.log(`üîÑ [STORE] Fetching initial data for new account: ${account.email}`);
              
              try {
                // Fetch labels first, then messages (labels needed for total count)
                await fetchLabels(account.id);
                await fetchMessages(undefined, undefined, undefined, account.id);
                console.log(`‚úÖ [STORE] Initial data loaded for account: ${account.email}`);
              } catch (dataError) {
                console.warn(`‚ö†Ô∏è [STORE] Failed to load initial data for account: ${account.email}`, dataError);
                // Don't fail the account addition, just log the warning
                // User can manually refresh to load data
              }
            } else {
              console.log(`üß™ [STORE] Test environment detected - skipping automatic data fetch for account: ${account.email}`);
            }
            
            console.log('‚úÖ [STORE] Account added successfully:', account.email);
          } catch (error) {
            console.error('‚ùå [STORE] Failed to add account:', error);
            const handledError = handleGmailError(error, {
              operation: 'add_account',
              accountId: account.id,
            });
            set((state) => {
              state.error = handledError.message;
              state.isLoadingAccounts = false;
            });
          }
        },

        removeAccount: async (accountId: string) => {
          set((state) => {
            state.isLoadingAccounts = true;
            state.error = null;
          });

          try {
            // This would revoke tokens and clean up
            await new Promise(resolve => setTimeout(resolve, 500));
            
            set((state) => {
              delete state.accounts[accountId];
              delete state.accountData[accountId];
              
              // Potentially switch to another account or sign out
              if (state.currentAccountId === accountId) {
                const remainingAccountIds = Object.keys(state.accounts);
                if (remainingAccountIds.length > 0) {
                  state.currentAccountId = remainingAccountIds[0];
                } else {
                  state.currentAccountId = null;
                  state.isAuthenticated = false;
                }
              }
              
              state.isLoadingAccounts = false;
            });
          } catch (error) {
            const handledError = handleGmailError(error, {
              operation: 'remove_account',
              accountId,
            });
            set((state) => {
              state.error = handledError.message;
              state.isLoadingAccounts = false;
            });
          }
        },

        switchAccount: (accountId: string) => {
          set((state) => {
            const account = state.accounts[accountId];
            if (account) {
              state.currentAccountId = accountId;
            }
          });
        },

        refreshAccount: async (accountId: string) => {
          const account = get().accounts[accountId];
          if (!account) {
            console.error('Account not found:', accountId);
            return;
          }

          set((state) => {
            if (state.accounts[accountId]) {
              state.accounts[accountId].syncStatus = 'syncing';
            }
          });

          try {
            console.log('üîÑ [STORE] Refreshing account quota:', account.email);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(accountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // Verify authentication by getting user profile (this handles token validation internally)
            let userProfile;
            try {
              userProfile = await gmailApi.getUserProfile();
            } catch (error) {
              console.error('‚ùå [QUOTA] Authentication verification failed - account needs re-authentication:', error);
              
              // If authentication fails, remove the account from the store to force re-authentication
              if (error instanceof Error && error.message.includes('Authentication')) {
                set((state) => {
                  delete state.accounts[accountId];
                  if (state.currentAccountId === accountId) {
                    const remainingAccounts = Object.keys(state.accounts);
                    state.currentAccountId = remainingAccounts.length > 0 ? remainingAccounts[0] : null;
                  }
                });
              }
              
              throw new Error('Authentication failed - please sign out and sign in again');
            }
            
            if (!userProfile) {
              throw new Error('Failed to verify account authentication');
            }

            // Fetch quota information using Google Drive API
            try {
              console.log('üîç [QUOTA] Fetching storage quota from Google Drive API...');
              
              // Create tokens object for quota fetch
              const tokens = {
                access_token: account.accessToken,
                refresh_token: account.refreshToken,
                expires_at: account.tokenExpiry ? account.tokenExpiry.toISOString() : new Date(Date.now() + 3600000).toISOString(), // 1 hour default if missing
                token_type: 'Bearer' as const,
              };
              
              const response = await fetch('https://www.googleapis.com/drive/v3/about?fields=storageQuota(limit,usage,usageInDrive,usageInDriveTrash)', {
                headers: {
                  Authorization: `Bearer ${tokens.access_token}`,
                  'Content-Type': 'application/json',
                },
              });

              if (!response.ok) {
                console.warn('‚ö†Ô∏è [QUOTA] Drive API not available, keeping existing quota values');
              } else {
                const data = await response.json();
                console.log('üîç [QUOTA] Raw API response:', data);
                const storageQuota = data.storageQuota;
                
                if (storageQuota) {
                  const used = parseInt(storageQuota.usage || '0', 10);
                  let total = parseInt(storageQuota.limit || '0', 10);
                  
                  // Some Google accounts (Workspace, Google One) don't return a limit
                  if (!total || total < 0) {
                    console.log('‚ö†Ô∏è [QUOTA] No limit returned by API, account may have custom quota');
                    total = 0;
                  }
                  
                  console.log('‚úÖ [QUOTA] Storage quota parsed:', {
                    used: `${(used / (1024 * 1024 * 1024)).toFixed(1)} GB`,
                    total: total > 0 ? `${(total / (1024 * 1024 * 1024)).toFixed(1)} GB` : 'Custom/Unlimited',
                    percentage: total > 0 ? `${((used / total) * 100).toFixed(1)}%` : 'N/A',
                  });
                  
                  // Update account with new quota info
                  set((state) => {
                    if (state.accounts[accountId]) {
                      state.accounts[accountId].quotaUsed = used;
                      state.accounts[accountId].quotaTotal = total;
                    }
                  });
                }
              }
            } catch (quotaError) {
              console.warn('‚ö†Ô∏è [QUOTA] Failed to fetch quota info:', quotaError);
              // Don't fail the whole refresh if quota fetch fails
            }
            
            set((state) => {
              if (state.accounts[accountId]) {
                state.accounts[accountId].syncStatus = 'idle';
                state.accounts[accountId].lastSyncAt = new Date();
              }
            });
            
            console.log('‚úÖ [STORE] Account refreshed successfully');
          } catch (error) {
            console.error('‚ùå [STORE] Failed to refresh account:', error);
            set((state) => {
              if (state.accounts[accountId]) {
                state.accounts[accountId].syncStatus = 'error';
                // If authentication failed, set a clear error message
                if (error instanceof Error && error.message.includes('Authentication failed')) {
                  state.accounts[accountId].errorMessage = 'Authentication expired - please sign out and sign in again';
                }
              }
            });
          }
        },

        syncAllAccounts: async () => {
          const accounts = get().accounts;
          if (Object.keys(accounts).length === 0) {
            console.log('üì≠ [SYNC] No accounts to sync');
            return;
          }

          console.log(`üîÑ [SYNC] Starting sync for ${Object.keys(accounts).length} accounts`);
          
          set((state) => {
            state.isLoadingAccounts = true;
            state.error = null;
            Object.values(state.accounts).forEach(acc => {
              acc.syncStatus = 'syncing';
            });
          });

          try {
            const { fetchMessages, fetchLabels } = get();
            
            // Sync all accounts in parallel
            const syncPromises = Object.values(accounts).map(async (account) => {
              try {
                console.log(`üîÑ [SYNC] Syncing account: ${account.email}`);
                
                // Fetch labels first, then messages (labels needed for total count)
                await fetchLabels(account.id);
                await fetchMessages(undefined, undefined, undefined, account.id);
                
                console.log(`‚úÖ [SYNC] Account synced: ${account.email}`);
                return account.id;
              } catch (error) {
                console.error(`‚ùå [SYNC] Failed to sync account ${account.email}:`, error);
                set((state) => {
                  if (state.accounts[account.id]) {
                    state.accounts[account.id].syncStatus = 'error';
                  }
                });
                throw error;
              }
            });

            await Promise.all(syncPromises);
            
            set((state) => {
              Object.values(state.accounts).forEach(acc => {
                acc.lastSyncAt = new Date();
                acc.syncStatus = 'idle';
              });
              state.isLoadingAccounts = false;
            });
            
            console.log(`‚úÖ [SYNC] All accounts synced successfully`);
          } catch (error) {
            console.error('‚ùå [SYNC] Sync failed for some accounts:', error);
            const handledError = handleGmailError(error, {
              operation: 'sync_all_accounts',
            });
            set((state) => {
              // Only set accounts to error status if they weren't already set above
              Object.values(state.accounts).forEach(acc => {
                if (acc.syncStatus === 'syncing') {
                  acc.syncStatus = 'error';
                }
              });
              state.error = handledError.message;
              state.isLoadingAccounts = false;
            });
          }
        },

        // Authentication actions
        authenticate: async (accountId?: string) => {
          set((state) => {
            state.isLoading = true;
            state.error = null;
          });
          
          const targetAccountId = accountId || get().currentAccountId;
          
          try {
            if (!targetAccountId) {
              throw new Error('No account specified for authentication');
            }

            // This would integrate with the actual OAuth flow
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            set((state) => {
              state.isAuthenticated = true;
              state.isLoading = false;
              state.connectionStatus = 'connected';
              
              const account = state.accounts[targetAccountId];
              if (account) {
                account.syncStatus = 'idle';
              }
            });
          } catch (error) {
            const handledError = handleGmailError(error, {
              operation: 'authenticate',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
              state.isLoading = false;
              state.connectionStatus = 'error';
            });
          }
        },

        // Message actions
        fetchMessages: async (labelId?: string, query?: string, pageToken?: string, accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) {
            set((state) => {
              state.error = 'No account selected';
            });
            return;
          }

          set((state) => {
            state.isLoadingMessages = true;
            state.error = null;
          });
          
          try {
            console.log(`üì® [STORE] Fetching real messages for account: ${targetAccountId}`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // Determine label IDs to fetch - validate the label exists first
            let labelIds = ['INBOX']; // Default fallback
            
            if (labelId) {
              // Check if the requested label exists in the account's labels
              const accountData = get().accountData[targetAccountId];
              const labelExists = accountData?.labels?.some(label => label.id === labelId);
              
              if (labelExists) {
                labelIds = [labelId];
              } else {
                console.warn(`‚ö†Ô∏è [STORE] Label ${labelId} not found, falling back to INBOX`);
                // Don't throw error - gracefully fall back to INBOX
                labelIds = ['INBOX'];
              }
            }
            
            // Fetch labels first if we don't have them (needed for total count)
            const accountData = get().accountData[targetAccountId];
            if (!accountData || !accountData.labels || accountData.labels.length === 0) {
              console.log(`üè∑Ô∏è [STORE] Fetching labels first to get total count`);
              try {
                const labels = await gmailApi.getLabels();
                set((state) => {
                  if (!state.accountData[targetAccountId]) {
                    state.accountData[targetAccountId] = {
                      messages: [],
                      threads: [],
                      labels: [],
                      drafts: [],
                      totalMessages: 0,
                      unreadMessages: 0,
                      lastSyncAt: new Date(),
                      syncInProgress: false,
                    };
                  }
                  state.accountData[targetAccountId].labels = labels;
                });
              } catch (labelError) {
                console.warn('‚ö†Ô∏è [STORE] Failed to fetch labels for total count:', labelError);
              }
            }

            // Fetch real messages from Gmail API
            const result = await gmailApi.getMessages(labelIds, 50, pageToken, query);
            
            console.log(`‚úÖ [STORE] Fetched ${result.messages.length} real messages`);
            console.log(`üîó [STORE] API result:`, { 
              messageCount: result.messages.length, 
              nextPageToken: result.nextPageToken,
              hasNextPageToken: !!result.nextPageToken,
              resultSizeEstimate: result.resultSizeEstimate
            });
            console.log(`üîó [STORE] Full API result:`, result);

            set((state) => {
              // Initialize account data if it doesn't exist
              if (!state.accountData[targetAccountId]) {
                state.accountData[targetAccountId] = {
                  messages: [],
                  threads: [],
                  labels: [],
                  drafts: [],
                  totalMessages: 0,
                  unreadMessages: 0,
                  lastSyncAt: new Date(),
                  syncInProgress: false,
                };
              }
              
              // Update messages with real data
              state.accountData[targetAccountId].messages = result.messages;
              state.accountData[targetAccountId].unreadMessages = result.messages.filter(msg => !msg.isRead).length;
              state.accountData[targetAccountId].lastSyncAt = new Date();

              // Use labels first as they're more reliable than resultSizeEstimate
              let totalMessages = 0;
              const accountData = state.accountData[targetAccountId];
              
              // Primary: Use label's messagesTotal (most accurate)
              const currentLabel = labelId || 'INBOX';
              const targetLabel = accountData.labels.find(label => label.id === currentLabel);
              
              console.log(`[QUOTA_DEBUG] All labels for account ${targetAccountId}:`, JSON.stringify(accountData.labels, null, 2));
              console.log(`[QUOTA_DEBUG] Searching for label: ${currentLabel}, Found:`, targetLabel);

              let totalUnreadMessages = 0;
              
              if (targetLabel && typeof targetLabel.messagesTotal === 'number' && targetLabel.messagesTotal > 0) {
                totalMessages = targetLabel.messagesTotal;
                totalUnreadMessages = targetLabel.messagesUnread || 0;
                console.log(`üìÑ [STORE] Set totalMessages from ${currentLabel} label: ${totalMessages}, unread: ${totalUnreadMessages}`);
              } else if (result.resultSizeEstimate && result.resultSizeEstimate > 0) {
                // Secondary: Use API's resultSizeEstimate (often inaccurate)
                totalMessages = result.resultSizeEstimate;
                // For unread count when we don't have label data, count unread in current results
                totalUnreadMessages = result.messages.filter(msg => !msg.isRead).length;
                console.log(`üìÑ [STORE] Set totalMessages from API resultSizeEstimate: ${totalMessages}`);
              } else {
                // Last resort: estimate based on current data (likely wrong)
                totalMessages = pageToken ? 
                  Math.max(result.messages.length, state.messagesLoadedSoFar + result.messages.length) :
                  result.messages.length;
                totalUnreadMessages = result.messages.filter(msg => !msg.isRead).length;
                console.log(`üìÑ [STORE] Set totalMessages from estimation fallback: ${totalMessages}`);
              }
              
              state.accountData[targetAccountId].totalMessages = totalMessages;
              state.isLoadingMessages = false;
              
              // Update pagination state for token-based pagination
              state.nextPageToken = result.nextPageToken;
              
              // Handle token-based navigation
              if (pageToken) {
                  if (state.isNavigatingBackwards) {
                      // We've just navigated back, so remove the token that led to the *previous* (now current) page.
                      // The current state of pageTokens is for the page we are on.
                      state.pageTokens.pop();
                  } else {
                      // We are moving forward. Store the token for the page we are now on.
                      if (!state.pageTokens.includes(pageToken)) {
                          state.pageTokens.push(pageToken);
                      }
                  }
              } else {
                  // First page - reset everything
                  state.pageTokens = [];
              }
              // Don't recalculate messagesLoadedSoFar here - it's managed by nextPage/prevPage methods

              // Set totalMessages from account data (which now gets it from API resultSizeEstimate)
              // Make sure we have a valid number
              state.totalMessages = totalMessages;
              state.totalUnreadMessages = totalUnreadMessages;
              state.nextPageToken = result.nextPageToken;
              
              console.log(`üìÑ [STORE] *** FETCH COMPLETE ***`, {
                messagesLoadedSoFar: state.messagesLoadedSoFar,
                nextPageToken: state.nextPageToken,
                tokensInStack: state.pageTokens.length,
                totalMessages: state.totalMessages,
                totalUnreadMessages: state.totalUnreadMessages,
                currentMessages: result.messages.length
              });
              
              // No need for prevPageToken in token-based pagination
            });
          } catch (error) {
            console.error('‚ùå [STORE] Failed to fetch messages:', error);
            const handledError = handleGmailError(error, {
              operation: 'fetch_messages',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
              state.isLoadingMessages = false;
            });
          }
        },

        fetchMessage: async (messageId: string, accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          set((state) => {
            state.isLoading = true;
            state.error = null;
          });
          
          try {
            console.log(`üìß [STORE] Fetching real message: ${messageId}`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // First check if we already have the message in our store
            const accountData = get().accountData[targetAccountId];
            let message = accountData?.messages.find(msg => msg.id === messageId);
            
            // If not found in store, fetch from API
            if (!message) {
              console.log(`üîç [STORE] Message not in store, fetching from API...`);
              message = (await gmailApi.getMessage(messageId)) || undefined;
            }
            
            if (!message) {
              throw new Error('Message not found');
            }

            console.log(`‚úÖ [STORE] Message fetched: ${message.subject}`);

            set((state) => {
              state.currentMessage = message;
              state.isLoading = false;
            });
          } catch (error) {
            console.error('‚ùå [STORE] Failed to fetch message:', error);
            const handledError = handleGmailError(error, {
              operation: 'fetch_message',
              accountId: targetAccountId || undefined,
              messageId,
            });
            set((state) => {
              state.error = handledError.message;
              state.isLoading = false;
            });
          }
        },

        fetchThread: async (threadId: string, accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          set((state) => {
            state.isLoadingThreads = true;
            state.error = null;
          });
          
          try {
            await new Promise(resolve => setTimeout(resolve, 300));
            
            const accountData = get().accountData[targetAccountId];
            const threadMessages = accountData?.messages.filter(msg => msg.threadId === threadId) || [];
            
            if (threadMessages.length === 0) {
              throw new Error('Thread not found');
            }

            const thread: EmailThread = {
              id: threadId,
              subject: threadMessages[0].subject,
              participants: Array.from(new Set([
                ...threadMessages.flatMap(msg => [msg.from, ...msg.to, ...(msg.cc || []), ...(msg.bcc || [])])
              ])),
              messages: threadMessages,
              lastMessageDate: threadMessages[threadMessages.length - 1].date,
              isRead: threadMessages.every(msg => msg.isRead),
              isStarred: threadMessages.some(msg => msg.isStarred),
              labels: Array.from(new Set(threadMessages.flatMap(msg => msg.labels))),
              messageCount: threadMessages.length,
              accountId: targetAccountId!,
              hasAttachments: threadMessages.some(msg => msg.hasAttachments),
              snippet: threadMessages[0]?.snippet || '',
            };

            set((state) => {
              state.currentThread = thread;
              state.isLoadingThreads = false;
            });
          } catch (error) {
            const handledError = handleGmailError(error, {
              operation: 'fetch_thread',
              threadId,
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
              state.isLoadingThreads = false;
            });
          }
        },

        // Real Gmail API implementations
        markAsRead: async (messageIds: string[], accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          try {
            console.log(`üìñ [STORE] Marking ${messageIds.length} messages as read`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // Update via Gmail API
            await gmailApi.markAsRead(messageIds);

            // Update local state
            set((state) => {
              const accountData = state.accountData[targetAccountId];
              if (accountData) {
                messageIds.forEach(id => {
                  const message = accountData.messages.find(msg => msg.id === id);
                  if (message) {
                    message.isRead = true;
                    message.labels = message.labels.filter(label => label !== 'UNREAD');
                  }
                });
                // Update unread count
                state.accountData[targetAccountId].unreadMessages = accountData.messages.filter(msg => !msg.isRead).length;
              }
            });
            
            console.log(`‚úÖ [STORE] Successfully marked messages as read`);
          } catch (error) {
            console.error('‚ùå [STORE] Failed to mark messages as read:', error);
            const handledError = handleGmailError(error, {
              operation: 'mark_as_read',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
            });
          }
        },

        markAsUnread: async (messageIds: string[], accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          try {
            console.log(`üì© [STORE] Marking ${messageIds.length} messages as unread`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // Update via Gmail API
            await gmailApi.markAsUnread(messageIds);

            // Update local state
            set((state) => {
              const accountData = state.accountData[targetAccountId];
              if (accountData) {
                messageIds.forEach(id => {
                  const message = accountData.messages.find(msg => msg.id === id);
                  if (message) {
                    message.isRead = false;
                    if (!message.labels.includes('UNREAD')) {
                      message.labels.push('UNREAD');
                    }
                  }
                });
                // Update unread count
                state.accountData[targetAccountId].unreadMessages = accountData.messages.filter(msg => !msg.isRead).length;
              }
            });
            
            console.log(`‚úÖ [STORE] Successfully marked messages as unread`);
          } catch (error) {
            console.error('‚ùå [STORE] Failed to mark messages as unread:', error);
            const handledError = handleGmailError(error, {
              operation: 'mark_as_unread',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
            });
          }
        },

        deleteMessages: async (messageIds: string[], accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          try {
            console.log(`üóëÔ∏è [STORE] Deleting ${messageIds.length} messages`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // Delete via Gmail API
            await gmailApi.deleteMessages(messageIds);

            // Update local state
            set((state) => {
              const accountData = state.accountData[targetAccountId];
              if (accountData) {
                accountData.messages = accountData.messages.filter(msg => !messageIds.includes(msg.id));
                // Update counts
                state.accountData[targetAccountId].totalMessages = accountData.messages.length;
                state.accountData[targetAccountId].unreadMessages = accountData.messages.filter(msg => !msg.isRead).length;
              }
            });
            
            console.log(`‚úÖ [STORE] Successfully deleted messages`);
          } catch (error) {
            console.error('‚ùå [STORE] Failed to delete messages:', error);
            const handledError = handleGmailError(error, {
              operation: 'delete_messages',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
            });
          }
        },

        archiveMessages: async (messageIds: string[], accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          try {
            console.log(`üì¶ [STORE] Archiving ${messageIds.length} messages`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // Archive via Gmail API
            await gmailApi.archiveMessages(messageIds);

            // Update local state
            set((state) => {
              const accountData = state.accountData[targetAccountId];
              if (accountData) {
                messageIds.forEach(id => {
                  const message = accountData.messages.find(msg => msg.id === id);
                  if (message) {
                    message.labels = message.labels.filter(label => label !== 'INBOX');
                  }
                });
              }
            });
            
            console.log(`‚úÖ [STORE] Successfully archived messages`);
          } catch (error) {
            console.error('‚ùå [STORE] Failed to archive messages:', error);
            const handledError = handleGmailError(error, {
              operation: 'archive_messages',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
            });
          }
        },

        starMessages: async (messageIds: string[], accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          try {
            console.log(`‚≠ê [STORE] Starring ${messageIds.length} messages`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // Star via Gmail API
            await gmailApi.starMessages(messageIds);

            // Update local state
            set((state) => {
              const accountData = state.accountData[targetAccountId];
              if (accountData) {
                messageIds.forEach(id => {
                  const message = accountData.messages.find(msg => msg.id === id);
                  if (message) {
                    message.isStarred = true;
                    if (!message.labels.includes('STARRED')) {
                      message.labels.push('STARRED');
                    }
                  }
                });
              }
            });
            
            console.log(`‚úÖ [STORE] Successfully starred messages`);
          } catch (error) {
            console.error('‚ùå [STORE] Failed to star messages:', error);
            const handledError = handleGmailError(error, {
              operation: 'star_messages',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
            });
          }
        },

        unstarMessages: async (messageIds: string[], accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          try {
            console.log(`‚òÜ [STORE] Unstarring ${messageIds.length} messages`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              throw new Error('Failed to initialize Gmail API service');
            }

            // Unstar via Gmail API
            await gmailApi.unstarMessages(messageIds);

            // Update local state
            set((state) => {
              const accountData = state.accountData[targetAccountId];
              if (accountData) {
                messageIds.forEach(id => {
                  const message = accountData.messages.find(msg => msg.id === id);
                  if (message) {
                    message.isStarred = false;
                    message.labels = message.labels.filter(label => label !== 'STARRED');
                  }
                });
              }
            });
            
            console.log(`‚úÖ [STORE] Successfully unstarred messages`);
          } catch (error) {
            console.error('‚ùå [STORE] Failed to unstar messages:', error);
            const handledError = handleGmailError(error, {
              operation: 'unstar_messages',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
            });
          }
        },

        // Labels
        fetchLabels: async (accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) {
            console.warn('üè∑Ô∏è [STORE] No target account ID for fetchLabels');
            return;
          }

          try {
            console.log(`üè∑Ô∏è [STORE] Fetching real labels for account: ${targetAccountId}`);
            
            // Get Gmail API service for the account
            const gmailApi = getGmailApiService(targetAccountId);
            if (!gmailApi) {
              console.error('üè∑Ô∏è [STORE] Failed to get Gmail API service for account:', targetAccountId);
              throw new Error('Failed to initialize Gmail API service');
            }

            // Fetch real labels from Gmail API
            const labels = await gmailApi.getLabels();
            
            console.log(`‚úÖ [STORE] Fetched ${labels.length} real labels:`, labels.map(l => l.name));

            set((state) => {
              // Initialize account data if it doesn't exist
              if (!state.accountData[targetAccountId]) {
                console.log('üè∑Ô∏è [STORE] Initializing account data for:', targetAccountId);
                state.accountData[targetAccountId] = {
                  messages: [],
                  threads: [],
                  labels: [],
                  drafts: [],
                  totalMessages: 0,
                  unreadMessages: 0,
                  lastSyncAt: new Date(),
                  syncInProgress: false,
                };
              }
              
              // Update labels with real data
              console.log(`üè∑Ô∏è [STORE] Setting ${labels.length} labels for account:`, targetAccountId);
              state.accountData[targetAccountId].labels = labels;
            });
          } catch (error) {
            console.error('‚ùå [STORE] Failed to fetch labels:', error);
            
            // If tokens are corrupted, they've already been cleared by the API service
            if (error instanceof Error && error.message.includes('Authentication tokens are corrupted')) {
              // Remove the account from the store to force re-authentication
              set((state) => {
                delete state.accounts[targetAccountId];
                if (state.currentAccountId === targetAccountId) {
                  const remainingAccounts = Object.keys(state.accounts);
                  state.currentAccountId = remainingAccounts.length > 0 ? remainingAccounts[0] : null;
                }
              });
              return; // Don't set fallback labels for corrupted accounts
            }
            
            // As a fallback, set some basic system labels
            set((state) => {
              if (!state.accountData[targetAccountId]) {
                state.accountData[targetAccountId] = {
                  messages: [],
                  threads: [],
                  labels: [],
                  drafts: [],
                  totalMessages: 0,
                  unreadMessages: 0,
                  lastSyncAt: new Date(),
                  syncInProgress: false,
                };
              }
              
              // Set fallback system labels
              const fallbackLabels: GmailLabel[] = [
                { id: 'INBOX', name: 'Inbox', messageListVisibility: 'show' as const, labelListVisibility: 'labelShow' as const, type: 'system' as const, messagesTotal: 0, messagesUnread: 0, threadsTotal: 0, threadsUnread: 0 },
                { id: 'SENT', name: 'Sent', messageListVisibility: 'show' as const, labelListVisibility: 'labelShow' as const, type: 'system' as const, messagesTotal: 0, messagesUnread: 0, threadsTotal: 0, threadsUnread: 0 },
                { id: 'DRAFT', name: 'Drafts', messageListVisibility: 'show' as const, labelListVisibility: 'labelShow' as const, type: 'system' as const, messagesTotal: 0, messagesUnread: 0, threadsTotal: 0, threadsUnread: 0 },
              ];
              
              console.log(`üè∑Ô∏è [STORE] Setting fallback labels for account:`, targetAccountId);
              state.accountData[targetAccountId].labels = fallbackLabels;
            });
            
            const handledError = handleGmailError(error, {
              operation: 'fetch_labels',
              accountId: targetAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
            });
          }
        },

        addLabel: async (messageIds: string[], labelId: string, accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          set((state) => {
            const accountData = state.accountData[targetAccountId];
            if (accountData) {
              messageIds.forEach(id => {
                const message = accountData.messages.find(msg => msg.id === id);
                if (message && !message.labels.includes(labelId)) {
                  message.labels.push(labelId);
                }
              });
            }
          });
        },

        removeLabel: async (messageIds: string[], labelId: string, accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          set((state) => {
            const accountData = state.accountData[targetAccountId];
            if (accountData) {
              messageIds.forEach(id => {
                const message = accountData.messages.find(msg => msg.id === id);
                if (message) {
                  message.labels = message.labels.filter(label => label !== labelId);
                }
              });
            }
          });
        },

        // Compose actions
        startCompose: (draft?: Partial<ComposeEmail>) => {
          set((state) => {
            state.isComposing = true;
                                      state.composeData = {
              to: [],
              cc: [],
              bcc: [],
              subject: '',
              body: '',
              attachments: [],
              isScheduled: false,
              accountId: state.currentAccountId || undefined,
              ...draft,
            };
          });
        },

        updateCompose: (updates: Partial<ComposeEmail>) => {
          set((state) => {
            if (state.composeData) {
              Object.assign(state.composeData, updates);
            }
          });
        },

        sendEmail: async (email: ComposeEmail) => {
          set((state) => {
            state.isSending = true;
            state.error = null;
          });

          try {
            const targetAccountId = email.accountId || get().currentAccountId;
            if (!targetAccountId) {
              throw new Error('No account selected for sending');
            }

            // This would integrate with the actual send functionality
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            set((state) => {
              state.isSending = false;
              state.isComposing = false;
              state.composeData = {
                to: [],
                cc: [],
                bcc: [],
                subject: '',
                body: '',
                attachments: [],
                isScheduled: false,
              };
            });
          } catch (error) {
            const handledError = handleGmailError(error, {
              operation: 'send_email',
              accountId: email.accountId || get().currentAccountId || undefined,
            });
            set((state) => {
              state.error = handledError.message;
              state.isSending = false;
            });
          }
        },

        saveDraft: async (email: ComposeEmail) => {
          // Implementation for saving draft
          console.log('Saving draft for account:', email.accountId);
        },

        cancelCompose: () => {
          set((state) => {
            state.isComposing = false;
            state.composeData = {
              to: [],
              cc: [],
              bcc: [],
              subject: '',
              body: '',
              attachments: [],
              isScheduled: false,
            };
          });
        },

        // Search
        searchMessages: async (query: string, accountId?: string) => {
          await get().fetchMessages(undefined, query, undefined, accountId);
        },

        clearSearch: () => {
          set((state) => {
            state.searchQuery = '';
          });
          get().fetchMessages();
        },

        // UI Actions
        setCurrentView: (view: MailState['currentView']) => {
          set((state) => {
            state.currentView = view;
            state.selectedMessages = [];
          });
        },

        setCurrentLabel: (labelId: string | null) => {
          set((state) => {
            state.currentLabel = labelId;
            state.selectedMessages = [];
          });
        },

        selectMessage: (messageId: string, isSelected: boolean) => {
          set((state) => {
            if (isSelected) {
              if (!state.selectedMessages.includes(messageId)) {
                state.selectedMessages.push(messageId);
              }
            } else {
              state.selectedMessages = state.selectedMessages.filter(id => id !== messageId);
            }
          });
        },

        selectAllMessages: (isSelected: boolean) => {
          set((state) => {
            const accountData = state.currentAccountId ? state.accountData[state.currentAccountId] : null;
            if (accountData) {
              state.selectedMessages = isSelected ? accountData.messages.map(msg => msg.id) : [];
            }
          });
        },

        clearSelection: () => {
          set((state) => {
            state.selectedMessages = [];
          });
        },

        // Settings
        updateSettings: (settings: Partial<MailState['settings']>) => {
          set((state) => {
            Object.assign(state.settings, settings);
          });
        },

        // Error handling
        setError: (error: string | null) => {
          set((state) => {
            state.error = error;
          });
        },

        clearError: () => {
          set((state) => {
            state.error = null;
          });
        },

        // Pagination
        nextPage: async () => {
          const state = get();
          if (state.nextPageToken) {
            console.log('üîÑ [PAGINATION] Next page triggered:', {
              currentTokens: state.pageTokens.length,
              messagesLoadedSoFar: state.messagesLoadedSoFar,
              nextPageToken: state.nextPageToken
            });
            
            set(s => {
              // Set messagesLoadedSoFar to the number of messages we've loaded before this page
              s.messagesLoadedSoFar = s.pageTokens.length * s.currentPageSize;
              
              // Add current page token for navigation history
              s.pageTokens.push(s.nextPageToken!);
              
              console.log('üîÑ [PAGINATION] State after nextPage update:', {
                tokens: s.pageTokens.length,
                messagesLoadedSoFar: s.messagesLoadedSoFar
              });
            });
            
            await state.goToPage(state.nextPageToken);
          }
        },
        prevPage: async () => {
          const state = get();
          if (state.pageTokens.length === 0) return; // Can't go back from first page
          
          console.log('üîÑ [PAGINATION] Prev page triggered:', {
            currentTokens: state.pageTokens.length,
            messagesLoadedSoFar: state.messagesLoadedSoFar
          });
          
          const newTokens = [...state.pageTokens];
          newTokens.pop(); // Remove current page's token
          const prevToken = newTokens.length > 0 ? newTokens[newTokens.length - 1] : undefined;
          
          set(s => {
            s.pageTokens = newTokens;
            s.messagesLoadedSoFar = newTokens.length * s.currentPageSize;
            
            console.log('üîÑ [PAGINATION] State after prevPage update:', {
              tokens: s.pageTokens.length,
              messagesLoadedSoFar: s.messagesLoadedSoFar
            });
          });

          await state.goToPage(prevToken);
        },
        goToPage: async (pageToken?: string) => {
          const { currentLabel, searchQuery, fetchMessages, currentAccountId } = get();
          await fetchMessages(currentLabel || undefined, searchQuery, pageToken, currentAccountId || undefined);
        },

        // Reset pagination state - useful for debugging
        resetPagination: () => {
          set((state) => {
            console.log('üîÑ [PAGINATION] RESETTING PAGINATION STATE');
            state.pageTokens = [];
            state.messagesLoadedSoFar = 0;
            state.nextPageToken = undefined;
            state.totalMessages = 0;
            state.totalUnreadMessages = 0;
          });
        },
        
        // Test helper methods (for compatibility with existing tests)
        setAuthenticated: (isAuthenticated: boolean) => {
          set((state) => {
            state.isAuthenticated = isAuthenticated;
          });
        },

        setCurrentAccountId: (accountId: string | null) => {
          set((state) => {
            state.currentAccountId = accountId;
          });
        },

        setMessages: (messages: ParsedEmail[], accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          set((state) => {
            if (!state.accountData[targetAccountId]) {
              state.accountData[targetAccountId] = {
                messages: [],
                threads: [],
                labels: [],
                drafts: [],
                totalMessages: 0,
                unreadMessages: 0,
                lastSyncAt: new Date(),
                syncInProgress: false,
              };
            }
            state.accountData[targetAccountId].messages = messages;
            state.accountData[targetAccountId].unreadMessages = messages.filter(msg => !msg.isRead).length;
            state.accountData[targetAccountId].totalMessages = messages.length;
          });
        },

        setAccounts: (accounts: GmailAccount[]) => {
          set((state) => {
            state.accounts = {};
            accounts.forEach(account => {
              state.accounts[account.id] = account;
            });
          });
        },

        setSyncInProgress: (inProgress: boolean, accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          set((state) => {
            if (state.accountData[targetAccountId]) {
              state.accountData[targetAccountId].syncInProgress = inProgress;
            }
          });
        },

        setCurrentMessage: (message: ParsedEmail | null) => {
          set((state) => {
            state.currentMessage = message;
          });
        },

        clearCurrentMessage: () => {
          set((state) => {
            state.currentMessage = null;
            state.currentThread = null;
          });
        },

        setLabels: (labels: GmailLabel[], accountId?: string) => {
          const targetAccountId = accountId || get().currentAccountId;
          if (!targetAccountId) return;

          set((state) => {
            if (!state.accountData[targetAccountId]) {
              state.accountData[targetAccountId] = {
                messages: [],
                threads: [],
                labels: [],
                drafts: [],
                totalMessages: 0,
                unreadMessages: 0,
                lastSyncAt: new Date(),
                syncInProgress: false,
              };
            }
            state.accountData[targetAccountId].labels = labels;
          });
        },

        // PRODUCTION METHODS ONLY - Test helpers moved to __tests__/mailStoreTestUtils.ts
      })),
      {
        name: 'gmail-auth-storage', // name of the item in the storage (must be unique)
        storage: createJSONStorage(() => localStorage), // use localStorage
        partialize: (state) => ({ 
          accounts: state.accounts,
          currentAccountId: state.currentAccountId,
          isAuthenticated: state.isAuthenticated 
        }), // persist auth-related state
        onRehydrateStorage: () => (state) => {
          console.log('üîÑ [STORE] Store hydrated from localStorage, setting isHydrated to true');
          if (state) {
            state.isHydrated = true;
          } else {
            // If no persisted state, still set hydrated to true after attempt
            console.log('üîÑ [STORE] No persisted state found, marking as hydrated');
          }
        },
      }
    )
  )
);

// Fallback hydration trigger - ensure isHydrated is set to true even if persist doesn't work
setTimeout(() => {
  const state = useMailStore.getState();
  if (!state.isHydrated) {
    console.log('üîÑ [STORE] Manual hydration fallback triggered');
    useMailStore.setState({ isHydrated: true });
  }
}, 100);

export { useMailStore }; 

================================================================
FILE: src/features/mail/components/MailToolbar.tsx
================================================================
import React from 'react';
import { 
  Archive, 
  Trash2, 
  MailOpen, 
  Mail, 
  Star, 
  Clock, 
  MoreHorizontal,
  RefreshCw,
  ChevronLeft,
  ChevronRight,
  RotateCcw
} from 'lucide-react';
import { Button, Text } from '../../../components/ui';
import { useMailStore } from '../stores/mailStore';

export function MailToolbar() {
  const { 
    selectedMessages, 
    getMessages,
    selectAllMessages,
    clearSelection,
    archiveMessages,
    deleteMessages,
    markAsRead,
    markAsUnread,
    starMessages,
    fetchMessages,
    isLoadingMessages,
    // Token-based pagination
    totalMessages,
    totalUnreadMessages,
    messagesLoadedSoFar,
    nextPageToken,
    prevPage,
    nextPage,
    resetPagination
  } = useMailStore();

  const messages = getMessages();

  const selectedCount = selectedMessages.length;
  const isAllSelected = messages.length > 0 && selectedMessages.length === messages.length;
  const isPartiallySelected = selectedMessages.length > 0 && selectedMessages.length < messages.length;

  const handleSelectAll = () => {
    if (isAllSelected) {
      clearSelection();
    } else {
      selectAllMessages(true);
    }
  };

  const handleArchive = () => {
    if (selectedCount > 0) {
      archiveMessages(selectedMessages);
    }
  };

  const handleDelete = () => {
    if (selectedCount > 0) {
      deleteMessages(selectedMessages);
    }
  };

  const handleMarkAsRead = () => {
    if (selectedCount > 0) {
      markAsRead(selectedMessages);
    }
  };

  const handleMarkAsUnread = () => {
    if (selectedCount > 0) {
      markAsUnread(selectedMessages);
    }
  };

  const handleStar = () => {
    if (selectedCount > 0) {
      starMessages(selectedMessages);
    }
  };

  const handleRefresh = () => {
    // Reset pagination state and fetch messages from beginning
    resetPagination();
    fetchMessages();
  };

  const handlePreviousPage = async () => {
    if (messagesLoadedSoFar > 0 && !isLoadingMessages) {
      await prevPage();
    }
  };

  const handleNextPage = async () => {
    if (nextPageToken && !isLoadingMessages) {
      await nextPage();
    }
  };

  return (
    <div 
      className="flex items-center justify-between bg-[var(--bg-tertiary)]"
      style={{ 
        padding: 'var(--space-3) var(--space-4)',
        gap: 'var(--space-2)'
      }}
    >
      {/* Left Side - Selection and Actions */}
      <div className="flex items-center" style={{ gap: 'var(--space-2)' }}>
        {/* Select All Checkbox */}
        <div className="relative w-3 flex items-center justify-center">
          <input
            type="checkbox"
            checked={isAllSelected}
            ref={(input) => {
              if (input) input.indeterminate = isPartiallySelected;
            }}
            onChange={handleSelectAll}
            className="w-3 h-3 text-[var(--accent-primary)] bg-transparent border-[var(--border-default)] rounded-none focus:ring-[var(--accent-primary)] focus:ring-1 focus:ring-offset-0 cursor-pointer"
            style={{ transform: 'scale(0.5)' }}
          />
        </div>

        {/* Refresh Button */}
        <Button
          variant="ghost"
          size="icon"
          onClick={handleRefresh}
          disabled={isLoadingMessages}
          className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
          title="Refresh"
        >
          <RefreshCw size={16} className={isLoadingMessages ? 'animate-spin' : ''} />
        </Button>

        {/* Action Buttons - Only show when messages are selected */}
        {selectedCount > 0 && (
          <>
            <div className="w-px h-6 bg-[var(--border-default)] mx-1" />
            
            <Button
              variant="ghost"
              size="icon"
              onClick={handleArchive}
              className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
              title="Archive"
            >
              <Archive size={16} />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              onClick={handleDelete}
              className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
              title="Delete"
            >
              <Trash2 size={16} />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              onClick={handleMarkAsRead}
              className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
              title="Mark as read"
            >
              <MailOpen size={16} />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              onClick={handleMarkAsUnread}
              className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
              title="Mark as unread"
            >
              <Mail size={16} />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              onClick={handleStar}
              className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
              title="Add star"
            >
              <Star size={16} />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
              title="Snooze"
            >
              <Clock size={16} />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
              title="More"
            >
              <MoreHorizontal size={16} />
            </Button>

            <div className="w-px h-6 bg-[var(--border-default)] mx-1" />
            
            <Text size="sm" variant="secondary">
              {selectedCount} selected
            </Text>
          </>
        )}
      </div>

      {/* Right Side - Pagination */}
      <div className="flex items-center" style={{ gap: 'var(--space-2)' }}>
        <Text size="sm" variant="secondary">
          {(() => {
            if (messages.length === 0) {
              return `0-0 of ${totalMessages}`;
            }
            
            const start = messagesLoadedSoFar + 1;
            const end = messagesLoadedSoFar + messages.length;
            
            // Use unread count if available, otherwise fall back to total messages
            const displayTotal = totalUnreadMessages > 0 ? totalUnreadMessages : totalMessages;
            const safeTotal = typeof displayTotal === 'number' && !isNaN(displayTotal) && displayTotal > 0 
              ? displayTotal 
              : (nextPageToken ? `${end}+` : end);
            
            console.log(`üìÑ [TOOLBAR] PAGINATION DISPLAY - START: ${start}, END: ${end}, TOTAL: ${safeTotal}`, {
              start,
              end,
              totalMessages,
              totalUnreadMessages,
              messagesLoadedSoFar,
              currentPageMessages: messages.length,
              displayTotal,
              safeTotal
            });
            
            return `${start}-${end} of ${safeTotal}`;
          })()}
        </Text>
        
        <Button
          variant="ghost"
          size="icon"
          onClick={handlePreviousPage}
          disabled={messagesLoadedSoFar === 0 || isLoadingMessages}
          className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)] disabled:opacity-50 disabled:cursor-not-allowed"
          title="Previous page"
        >
          <ChevronLeft size={16} />
        </Button>
        
        <Button
          variant="ghost"
          size="icon"
          onClick={handleNextPage}
          disabled={!nextPageToken || isLoadingMessages}
          className="h-8 w-8 text-[var(--text-secondary)] hover:text-[var(--text-primary)] disabled:opacity-50 disabled:cursor-not-allowed"
          title="Next page"
        >
          <ChevronRight size={16} />
        </Button>
      </div>
    </div>
  );
} 

================================================================
FILE: src/app/pages/Mail.tsx
================================================================
// ... existing code ...

================================================================
FILE: src/features/mail/components/MessageList.tsx
================================================================
// ... existing code ...

================================================================
FILE: src/features/mail/components/ThreadedMessageList.tsx
================================================================
// ... existing code ...

================================================================
FILE: src/features/mail/types/index.ts
================================================================
// ... existing code ...

================================================================
ANALYSIS SUMMARY
================================================================

## PAGINATION LOGIC FLOW
1. MailToolbar displays: `${messagesLoadedSoFar + 1}-${messagesLoadedSoFar + messages.length} of ${total}`
2. nextPage() sets: messagesLoadedSoFar = pageTokens.length * currentPageSize (50)
3. fetchMessages() was previously overriding messagesLoadedSoFar (now disabled)

## POTENTIAL ISSUES IDENTIFIED
1. messagesLoadedSoFar may not be updating correctly during navigation
2. Token stack (pageTokens) may have inconsistent state
3. Total count calculation using wrong source (unread vs total)
4. State persistence/hydration issues

## DEBUGGING RECOMMENDATIONS
1. Check console logs for pagination state changes
2. Verify messagesLoadedSoFar value on page navigation
3. Inspect pageTokens array length and contents
4. Validate totalMessages and totalUnreadMessages values
5. Test with resetPagination() on refresh

## CONCLUSION
The code structure appears correct but messagesLoadedSoFar is not properly updating on page 2.
The issue likely lies in the state management between nextPage/prevPage and the store updates. 

=== FINAL TECHNICAL ANALYSIS ===

## ROOT CAUSE HYPOTHESIS

Based on the code analysis, the most likely issues are:

1. **State Update Race Condition**: The nextPage() method updates messagesLoadedSoFar BEFORE the actual API call, but if there's an async issue or state batching, the UI might not reflect the update.

2. **Zustand State Batching**: Multiple setState calls in quick succession might be batched, causing intermediate values to be lost.

3. **Store Subscription Issues**: The MailToolbar component may not be properly subscribed to messagesLoadedSoFar changes.

4. **Token Stack Corruption**: The pageTokens array may not be properly maintained, causing incorrect messagesLoadedSoFar calculations.

## DEBUGGING STEPS NEEDED

1. Add explicit state logging in nextPage() AFTER state update
2. Verify MailToolbar re-renders when messagesLoadedSoFar changes  
3. Check if messagesLoadedSoFar value persists between page navigations
4. Inspect the actual pageTokens array contents in console
5. Test if the issue occurs in both threaded and non-threaded views

## RECOMMENDED FIXES

1. **Immediate logging**: Add console.log in MailToolbar render to show messagesLoadedSoFar value
2. **State verification**: Add useEffect in MailToolbar to log when messagesLoadedSoFar changes
3. **Atomic updates**: Ensure nextPage/prevPage state updates are atomic and don't conflict
4. **Reset mechanism**: Use resetPagination() to clear corrupted state

## FILES TO MONITOR

- MailToolbar.tsx (pagination display)
- mailStore.ts (nextPage/prevPage methods)
- Browser console logs (state updates)

The issue is definitely in the state management between navigation and display, not in duplicate components or calculation logic.

# LibreOllama Canvas Production Readiness - Additional Considerations

## Overview

After reviewing the comprehensive guides provided, here are critical additional considerations to ensure the canvas is truly production-ready. These address edge cases, error handling, performance extremes, and deployment strategies not covered in the initial fixes.

## 1. Error Handling & Recovery

### 1.1 Deletion During Active Operations

```typescript
// Add to store actions - handle element deletion gracefully
deleteElement: (elementId: ElementId) => {
  set((state) => {
    const element = state.elements.get(elementId);
    if (!element) return;
    
    // Check if element is being edited
    if (state.editingElement === elementId) {
      // Cancel edit operation first
      state.cancelEdit();
    }
    
    // Check if element has connectors
    const connectedConnectors = Array.from(state.elements.values())
      .filter(el => 
        el.type === 'connector' && 
        (el.startPoint.elementId === elementId || el.endPoint.elementId === elementId)
      );
    
    // Delete or update connectors
    connectedConnectors.forEach(connector => {
      if (connector.startPoint.elementId === elementId && connector.endPoint.elementId === elementId) {
        // Delete self-connected connector
        state.elements.delete(connector.id);
      } else {
        // Convert to floating endpoint
        const updates: Partial<ConnectorElement> = {};
        if (connector.startPoint.elementId === elementId) {
          updates.startPoint = { ...connector.startPoint, elementId: undefined };
        }
        if (connector.endPoint.elementId === elementId) {
          updates.endPoint = { ...connector.endPoint, elementId: undefined };
        }
        state.updateElement(connector.id, updates);
      }
    });
    
    // If deleting a section, handle children
    if (element.type === 'section') {
      const children = Array.from(state.elements.values())
        .filter(el => el.sectionId === elementId);
      
      // Move children to parent section or root
      children.forEach(child => {
        state.updateElement(child.id, {
          sectionId: element.sectionId || null,
          // Adjust coordinates to maintain visual position
          x: child.x + element.x,
          y: child.y + element.y
        });
      });
    }
    
    // Finally delete the element
    state.elements.delete(elementId);
  });
};
```

### 1.2 Corrupt Data Recovery

```typescript
// Add data validation on load
interface CanvasDataValidator {
  validateAndRepair(data: unknown): { valid: boolean; repaired: CanvasData; errors: string[] } {
    const errors: string[] = [];
    const repaired = structuredClone(data) as any;
    
    // Validate elements
    if (!repaired.elements || !Array.isArray(repaired.elements)) {
      errors.push('Missing or invalid elements array');
      repaired.elements = [];
    }
    
    // Validate each element
    repaired.elements = repaired.elements.filter((el: any) => {
      if (!el.id || !el.type) {
        errors.push(`Invalid element: missing id or type`);
        return false;
      }
      
      // Ensure coordinates are numbers
      el.x = Number(el.x) || 0;
      el.y = Number(el.y) || 0;
      
      // Validate section references
      if (el.sectionId && !repaired.elements.find((s: any) => s.id === el.sectionId && s.type === 'section')) {
        errors.push(`Element ${el.id} references non-existent section ${el.sectionId}`);
        el.sectionId = null;
      }
      
      return true;
    });
    
    // Check for circular section references
    const checkCircular = (sectionId: string, visited = new Set<string>()): boolean => {
      if (visited.has(sectionId)) return true;
      visited.add(sectionId);
      
      const section = repaired.elements.find((el: any) => el.id === sectionId);
      if (section?.sectionId) {
        return checkCircular(section.sectionId, visited);
      }
      return false;
    };
    
    repaired.elements.forEach((el: any) => {
      if (el.type === 'section' && el.sectionId && checkCircular(el.id)) {
        errors.push(`Circular section reference detected for ${el.id}`);
        el.sectionId = null;
      }
    });
    
    return {
      valid: errors.length === 0,
      repaired,
      errors
    };
  }
}
```

## 2. Performance Edge Cases

### 2.1 Deeply Nested Sections

```typescript
// Add nesting depth limits and optimization
const MAX_SECTION_DEPTH = 10;

const getSectionDepth = (sectionId: SectionId, sections: Map<SectionId, SectionElement>): number => {
  let depth = 0;
  let currentId: SectionId | null = sectionId;
  
  while (currentId && depth < MAX_SECTION_DEPTH) {
    const section = sections.get(currentId);
    if (!section?.sectionId) break;
    currentId = section.sectionId;
    depth++;
  }
  
  return depth;
};

// Optimize deeply nested coordinate calculations with memoization
const memoizedGetAbsolutePosition = memoize(
  (elementId: ElementId, elements: Map, sections: Map) => {
    // ... calculation
  },
  {
    maxSize: 1000,
    equals: (a, b) => a[0] === b[0] // Compare by elementId
  }
);
```

### 2.2 Large Element Collections in Sections

```typescript
// Virtualize section children when count exceeds threshold
interface VirtualizedSectionProps {
  section: SectionElement;
  children: CanvasElement[];
}

const VirtualizedSection: React.FC<VirtualizedSectionProps> = ({ section, children }) => {
  const VIRTUALIZATION_THRESHOLD = 100;
  const OVERSCAN = 20;
  
  if (children.length <= VIRTUALIZATION_THRESHOLD) {
    // Render normally
    return <>{children.map(child => <ElementRenderer key={child.id} element={child} />)}</>;
  }
  
  // Use viewport intersection to determine visible children
  const viewport = useCanvasStore(state => state.viewport);
  const sectionBounds = {
    x: section.x - OVERSCAN,
    y: section.y - OVERSCAN,
    width: section.width + OVERSCAN * 2,
    height: section.height + OVERSCAN * 2
  };
  
  const visibleChildren = useMemo(() => {
    return children.filter(child => {
      const childBounds = getElementBounds(child);
      return intersects(childBounds, sectionBounds);
    });
  }, [children, sectionBounds]);
  
  return (
    <>
      {visibleChildren.map(child => (
        <ElementRenderer key={child.id} element={child} />
      ))}
      {/* Render count indicator */}
      <Text
        x={5}
        y={section.height - 20}
        text={`${visibleChildren.length} of ${children.length} visible`}
        fontSize={10}
        fill="#999"
      />
    </>
  );
};
```

### 2.3 Complex Path Optimization

```typescript
// Optimize pen strokes with many points
const optimizePenPath = (points: number[], tolerance: number = 1): number[] => {
  if (points.length <= 4) return points; // Too short to optimize
  
  // Douglas-Peucker algorithm for path simplification
  const douglasPeucker = (points: number[], epsilon: number): number[] => {
    // Implementation...
  };
  
  // Limit maximum points
  const MAX_POINTS = 10000;
  if (points.length > MAX_POINTS) {
    // Aggressive simplification for very long paths
    return douglasPeucker(points, tolerance * 2);
  }
  
  return douglasPeucker(points, tolerance);
};

// Apply during pen stroke completion
const completePenStroke = (points: number[]) => {
  const optimized = optimizePenPath(points);
  
  // Warn if significant simplification occurred
  if (points.length > 1000 && optimized.length < points.length * 0.5) {
    console.warn(`Pen stroke simplified from ${points.length} to ${optimized.length} points`);
  }
  
  return optimized;
};
```

## 3. State Management Robustness

### 3.1 Operation Queuing

```typescript
// Prevent race conditions with operation queue
class OperationQueue {
  private queue: Array<() => Promise<void>> = [];
  private processing = false;
  
  async enqueue(operation: () => Promise<void>): Promise<void> {
    this.queue.push(operation);
    if (!this.processing) {
      await this.process();
    }
  }
  
  private async process(): Promise<void> {
    this.processing = true;
    
    while (this.queue.length > 0) {
      const operation = this.queue.shift()!;
      try {
        await operation();
      } catch (error) {
        console.error('Operation failed:', error);
        // Continue processing
      }
    }
    
    this.processing = false;
  }
}

// Use in store
const operationQueue = new OperationQueue();

const moveElementWithQueue = async (elementId: ElementId, position: Coordinates) => {
  await operationQueue.enqueue(async () => {
    // Perform state update
    useCanvasStore.getState().updateElement(elementId, position);
  });
};
```

### 3.2 Conflict Resolution

```typescript
// Handle conflicting operations
interface ConflictResolver {
  resolvePositionConflict(
    local: Coordinates,
    remote: Coordinates,
    timestamp: { local: number; remote: number }
  ): Coordinates {
    // Last-write-wins strategy
    return timestamp.remote > timestamp.local ? remote : local;
  }
  
  resolveDeletionConflict(
    localDeleted: boolean,
    remoteDeleted: boolean
  ): boolean {
    // Deletion always wins
    return localDeleted || remoteDeleted;
  }
}
```

## 4. User Experience Enhancements

### 4.1 Cursor Management

```typescript
// Comprehensive cursor system
const CursorManager = {
  setCursor(stage: Konva.Stage, cursor: string) {
    stage.container().style.cursor = cursor;
  },
  
  updateForTool(stage: Konva.Stage, tool: CanvasTool) {
    const cursors: Record<CanvasTool, string> = {
      'select': 'default',
      'pan': 'grab',
      'pen': 'crosshair',
      'text': 'text',
      'draw-rectangle': 'crosshair',
      'connector': 'crosshair',
      // ...
    };
    this.setCursor(stage, cursors[tool] || 'default');
  },
  
  updateForHover(stage: Konva.Stage, target: Konva.Node) {
    // Check if hovering over resize handles
    if (target.name()?.includes('anchor')) {
      const name = target.name();
      if (name.includes('top-left') || name.includes('bottom-right')) {
        this.setCursor(stage, 'nwse-resize');
      } else if (name.includes('top-right') || name.includes('bottom-left')) {
        this.setCursor(stage, 'nesw-resize');
      }
    }
    // Check if hovering over section edge
    else if (isNearSectionEdge(target)) {
      this.setCursor(stage, 'move');
    }
  }
};
```

### 4.2 Keyboard Navigation

```typescript
// Table cell keyboard navigation
const handleTableKeyboardNavigation = (
  e: KeyboardEvent,
  currentCell: { row: number; col: number },
  tableElement: TableElement
) => {
  const { rows, cols } = tableElement;
  let newCell = { ...currentCell };
  
  switch (e.key) {
    case 'Tab':
      e.preventDefault();
      if (e.shiftKey) {
        // Previous cell
        newCell.col--;
        if (newCell.col < 0) {
          newCell.col = cols - 1;
          newCell.row = Math.max(0, newCell.row - 1);
        }
      } else {
        // Next cell
        newCell.col++;
        if (newCell.col >= cols) {
          newCell.col = 0;
          newCell.row = Math.min(rows - 1, newCell.row + 1);
        }
      }
      break;
      
    case 'ArrowUp':
      newCell.row = Math.max(0, newCell.row - 1);
      break;
      
    case 'ArrowDown':
      newCell.row = Math.min(rows - 1, newCell.row + 1);
      break;
      
    case 'ArrowLeft':
      if (getCursorPosition() === 0) {
        newCell.col = Math.max(0, newCell.col - 1);
      }
      break;
      
    case 'ArrowRight':
      if (getCursorPosition() === getCellText().length) {
        newCell.col = Math.min(cols - 1, newCell.col + 1);
      }
      break;
  }
  
  if (newCell.row !== currentCell.row || newCell.col !== currentCell.col) {
    selectTableCell(tableElement.id, newCell);
  }
};
```

### 4.3 Visual Feedback

```typescript
// Loading states and progress indicators
interface CanvasLoadingState {
  isLoading: boolean;
  operation?: 'saving' | 'loading' | 'processing';
  progress?: number;
  message?: string;
}

const LoadingOverlay: React.FC<{ state: CanvasLoadingState }> = ({ state }) => {
  if (!state.isLoading) return null;
  
  return (
    <div className="canvas-loading-overlay">
      <div className="loading-content">
        <Spinner />
        {state.message && <p>{state.message}</p>}
        {state.progress !== undefined && (
          <ProgressBar value={state.progress} max={100} />
        )}
      </div>
    </div>
  );
};
```

## 5. Testing Strategy

### 5.1 Automated Test Suite

```typescript
// Coordinate system tests
describe('CoordinateService', () => {
  it('should correctly convert nested section coordinates', () => {
    const sections = new Map([
      [SectionId('s1'), { id: 's1', x: 100, y: 100, sectionId: null }],
      [SectionId('s2'), { id: 's2', x: 50, y: 50, sectionId: 's1' }],
    ]);
    
    const element = { id: 'e1', x: 25, y: 25, sectionId: 's2' };
    const absolute = CoordinateService.toAbsolute(element, sections);
    
    expect(absolute).toEqual({ x: 175, y: 175 });
  });
  
  it('should handle circular section references gracefully', () => {
    // Test circular reference detection
  });
});

// Visual regression tests
describe('Canvas Rendering', () => {
  it('should render sections with children correctly', async () => {
    const canvas = render(<Canvas initialData={testData} />);
    await waitForCanvasReady();
    
    const screenshot = await canvas.screenshot();
    expect(screenshot).toMatchImageSnapshot();
  });
});
```

### 5.2 Performance Benchmarks

```typescript
// Performance test suite
const performanceBenchmarks = {
  async testLargeCanvas() {
    const startTime = performance.now();
    
    // Create 5000 elements
    const elements = Array.from({ length: 5000 }, (_, i) => ({
      id: ElementId(`e${i}`),
      type: 'rectangle',
      x: Math.random() * 10000,
      y: Math.random() * 10000,
      width: 100,
      height: 100
    }));
    
    // Render and measure
    const renderTime = await measureRender(elements);
    expect(renderTime).toBeLessThan(50); // 50ms target
    
    // Measure interaction
    const interactionTime = await measureDragOperation();
    expect(interactionTime).toBeLessThan(16); // 60fps target
  }
};
```

## 6. Deployment Strategy

### 6.1 Feature Flags

```typescript
// Gradual rollout with feature flags
const canvasFeatureFlags = {
  // Core fixes
  'coordinate-system-v2': true,
  'section-resize': true,
  'connector-auto-update': true,
  
  // Performance optimizations
  'virtualized-sections': false, // Enable gradually
  'path-simplification': true,
  'aggressive-caching': false,
  
  // New features
  'collaborative-editing': false,
  'webgl-renderer': false
};

// Usage
if (canvasFeatureFlags['virtualized-sections']) {
  return <VirtualizedSection {...props} />;
} else {
  return <StandardSection {...props} />;
}
```

### 6.2 Monitoring & Analytics

```typescript
// Performance monitoring
const CanvasMetrics = {
  trackRenderTime(elementCount: number, time: number) {
    analytics.track('canvas.render', {
      elementCount,
      renderTime: time,
      fps: 1000 / time,
      timestamp: Date.now()
    });
  },
  
  trackOperation(operation: string, duration: number, metadata?: any) {
    analytics.track('canvas.operation', {
      operation,
      duration,
      ...metadata
    });
  },
  
  trackError(error: Error, context: any) {
    errorReporter.captureException(error, {
      tags: { feature: 'canvas' },
      context
    });
  }
};
```

### 6.3 Data Migration

```typescript
// Migrate existing canvases to new coordinate system
const migrateCanvasData = async (oldData: any): Promise<CanvasData> => {
  console.log('Starting canvas migration...');
  
  const migrated = structuredClone(oldData);
  
  // Convert old absolute coordinates to new relative system
  const sections = migrated.elements.filter(el => el.type === 'section');
  const elements = migrated.elements.filter(el => el.type !== 'section');
  
  elements.forEach(element => {
    if (element.sectionId) {
      const section = sections.find(s => s.id === element.sectionId);
      if (section) {
        // Old system stored absolute coordinates
        // New system needs relative
        element.x -= section.x;
        element.y -= section.y;
      }
    }
  });
  
  // Add version marker
  migrated.version = 2;
  
  return migrated;
};
```

## 7. Production Checklist

### Pre-Deployment
- [ ] All automated tests passing
- [ ] Performance benchmarks meet targets
- [ ] Visual regression tests updated
- [ ] Error handling for all edge cases
- [ ] Memory leak tests pass
- [ ] Accessibility audit complete

### Deployment
- [ ] Feature flags configured
- [ ] Monitoring dashboards ready
- [ ] Error tracking configured
- [ ] Performance baselines established
- [ ] Rollback plan documented
- [ ] Support team briefed

### Post-Deployment
- [ ] Monitor error rates
- [ ] Track performance metrics
- [ ] Gather user feedback
- [ ] A/B test results (if applicable)
- [ ] Document lessons learned

## Summary

These additional considerations ensure the canvas is not just functional but truly production-ready. Key focus areas:

1. **Robustness**: Handle all edge cases gracefully
2. **Performance**: Optimize for extreme scenarios
3. **User Experience**: Polish interactions and feedback
4. **Quality**: Comprehensive testing and monitoring
5. **Operations**: Safe deployment and rollback capability

With these additions to the existing fixes, the LibreOllama canvas will be ready for production use at scale.

# Canvas Implementation Priority Guide

## 🎯 Implementation Order for Maximum Impact

### Week 1: Core Stability (Must Have)
These fixes address the most critical user-facing issues.

#### Day 1-2: Coordinate System Fix
```typescript
// 1. Implement SectionHandler.tsx
// 2. Update element rendering to use relative coordinates
// 3. Test: Elements in sections should not cause jumping
```

#### Day 3-4: Connector System
```typescript
// 1. Implement ConnectorManager.tsx
// 2. Add subscription to element updates
// 3. Test: Connectors follow their connected elements
```

#### Day 5: Error Handling
```typescript
// 1. Add deletion safeguards
// 2. Implement operation queuing
// 3. Add try-catch blocks to all user operations
```

### Week 2: Essential Features (Should Have)

#### Day 1-2: Table Cell Editing
```typescript
// 1. Implement TableCellEditor.tsx
// 2. Add keyboard navigation
// 3. Test: Can edit and save cell content
```

#### Day 3-4: Drawing Containment
```typescript
// 1. Implement DrawingContainment.tsx
// 2. Fix pen tool coordinate handling
// 3. Test: Drawings stay in sections when moved
```

#### Day 5: Basic Performance
```typescript
// 1. Implement coordinate caching
// 2. Add viewport culling improvements
// 3. Monitor render times
```

### Week 3: Polish & Scale (Nice to Have)

#### Day 1-2: Advanced Performance
```typescript
// 1. Section child virtualization
// 2. Path simplification for complex pen strokes
// 3. Memory monitoring
```

#### Day 3-4: UX Polish
```typescript
// 1. Cursor management system
// 2. Loading states and progress
// 3. Visual feedback improvements
```

#### Day 5: Testing & Monitoring
```typescript
// 1. Set up automated tests
// 2. Configure performance monitoring
// 3. Add error tracking
```

## 🚨 Critical Path Items

These MUST be done before any deployment:

1. **Coordinate System** - Without this, sections are unusable
2. **Element Deletion Safety** - Prevents data corruption
3. **Basic Error Handling** - Prevents crashes
4. **Data Validation** - Ensures backward compatibility

## ⚡ Quick Wins (< 1 hour each)

If you need immediate improvements:

```typescript
// 1. Add cursor styles (30 min)
stage.container().style.cursor = tool === 'pan' ? 'grab' : 'default';

// 2. Prevent section circular references (45 min)
if (wouldCreateCircularReference(elementId, targetSectionId)) {
  return; // Don't allow the move
}

// 3. Add operation debouncing (20 min)
const debouncedSave = debounce(saveCanvas, 1000);

// 4. Simple loading indicator (30 min)
{isSaving && <div className="saving-indicator">Saving...</div>}
```

## 📊 Success Metrics

Track these to ensure the refactor is successful:

- **Section Jump Rate**: Should be 0%
- **Connector Update Lag**: < 16ms
- **Table Edit Success**: 100%
- **Memory Growth**: < 10MB per 1000 operations
- **Error Rate**: < 0.1%

## 🔄 Rollback Points

After each phase, ensure you can rollback if needed:

1. **After Week 1**: Feature flag for new coordinate system
2. **After Week 2**: A/B test with small user group
3. **After Week 3**: Gradual rollout to all users

## 💡 Developer Tips

### Common Pitfalls to Avoid
```typescript
// ❌ Don't do this
element.x = element.x + section.x; // Manual coordinate math

// ✅ Do this
<Group x={section.x} y={section.y}>{children}</Group> // Let Konva handle it
```

### Debug Helpers
```typescript
// Add to development build
window.debugCanvas = {
  logCoordinates: (elementId) => {
    const element = store.getElement(elementId);
    console.log('Local:', element.x, element.y);
    console.log('Absolute:', CoordinateService.toAbsolute(element));
  },
  
  validateSections: () => {
    // Check for circular references, orphaned elements, etc.
  }
};
```

### Performance Shortcuts
```typescript
// Use these patterns for better performance
const visibleElements = useMemo(() => /* filter */, [viewport, elements]);
const handlers = useCallback(() => /* handler */, []); // Stable references
React.memo(Component); // Prevent unnecessary re-renders
```

## 🎉 Definition of Done

The canvas refactor is complete when:

- [ ] All coordinate jumping issues resolved
- [ ] Connectors update automatically
- [ ] Table cells are editable
- [ ] Drawings stay in sections
- [ ] No memory leaks after 1 hour of use
- [ ] 60fps maintained with 1000+ elements
- [ ] All tests passing
- [ ] Monitoring in place
- [ ] Documentation updated
- [ ] Team trained on new patterns

Remember: **Test after each change!** The coordinate system is the foundation - get it right first, then build on top.

# Konva-Specific Gotchas & Solutions

## Critical Konva Implementation Details

### 1. Transform vs Position (The #1 Source of Bugs)

```typescript
// ❌ WRONG - Mixing transform and position
<Group 
  x={section.x} 
  y={section.y}
  scaleX={zoomLevel}  // Don't scale individual groups!
  scaleY={zoomLevel}
>

// ✅ CORRECT - Use position for sections, scale only on Stage
<Stage scale={{ x: zoomLevel, y: zoomLevel }}>
  <Layer>
    <Group x={section.x} y={section.y}>  {/* No scale here */}
      {children}
    </Group>
  </Layer>
</Stage>
```

### 2. Layer Ordering & Listening

```typescript
// ❌ WRONG - All layers listening
<Layer listening={true}>  {/* Background */}
<Layer listening={true}>  {/* Content */}
<Layer listening={true}>  {/* UI */}

// ✅ CORRECT - Optimize listening
<Layer listening={false}>  {/* Background - no interaction needed */}
<Layer listening={true}>   {/* Content - needs interaction */}
<Layer listening={false}>  {/* UI overlays - use specific listening */}
```

### 3. Transformer Attachment Timing

```typescript
// ❌ WRONG - Immediate attachment
const TransformerComponent = ({ node }) => {
  const trRef = useRef();
  
  // This often fails because node isn't ready
  trRef.current?.nodes([node]);
  
  return <Transformer ref={trRef} />;
};

// ✅ CORRECT - Use effect with proper timing
const TransformerComponent = ({ node, isSelected }) => {
  const trRef = useRef<Konva.Transformer>();
  
  useEffect(() => {
    if (isSelected && trRef.current && node) {
      trRef.current.nodes([node]);
      trRef.current.getLayer()?.batchDraw(); // Force redraw
    }
  }, [isSelected, node]);
  
  return isSelected ? <Transformer ref={trRef} /> : null;
};
```

### 4. Event Propagation & Bubbling

```typescript
// ❌ WRONG - Events bubble through everything
<Group onClick={handleGroupClick}>
  <Rect onClick={handleRectClick} />  {/* Both handlers fire! */}
</Group>

// ✅ CORRECT - Control propagation
<Group onClick={handleGroupClick}>
  <Rect onClick={(e) => {
    e.cancelBubble = true;  // Stop propagation
    handleRectClick(e);
  }} />
</Group>
```

### 5. Coordinate Space Conversions

```typescript
// ❌ WRONG - Manual math for pointer position
const handleClick = (e) => {
  const stage = e.target.getStage();
  const mousePos = stage.getPointerPosition();
  
  // This ignores stage scale and position!
  const canvasX = mousePos.x - stage.x();
  const canvasY = mousePos.y - stage.y();
};

// ✅ CORRECT - Use Konva's transform methods
const handleClick = (e) => {
  const stage = e.target.getStage();
  const pointerPos = stage.getPointerPosition();
  
  // Get the transform and invert it
  const transform = stage.getAbsoluteTransform().copy().invert();
  const canvasPos = transform.point(pointerPos);
};
```

### 6. Caching Pitfalls

```typescript
// ❌ WRONG - Cache everything immediately
<Rect 
  cache 
  width={100} 
  height={100} 
  fill="red" 
/>

// ✅ CORRECT - Cache intelligently
const ComplexShape = ({ element }) => {
  const shapeRef = useRef();
  
  useEffect(() => {
    const node = shapeRef.current;
    if (!node) return;
    
    // Only cache after initial render and for complex shapes
    if (shouldCache(element)) {
      node.cache({
        x: -2, // Small padding for anti-aliasing
        y: -2,
        width: element.width + 4,
        height: element.height + 4,
        pixelRatio: 1 // Lower for large shapes
      });
      
      // Clear cache when properties change
      return () => node.clearCache();
    }
  }, [element.fill, element.stroke]); // Re-cache on visual changes
  
  return <Rect ref={shapeRef} {...element} />;
};
```

### 7. Text Measurement & Rendering

```typescript
// ❌ WRONG - Assume text dimensions
<Text 
  text="Hello" 
  width={50}  // Text might overflow!
  height={20}
/>

// ✅ CORRECT - Measure text properly
const TextWithAutoSize = ({ text, maxWidth }) => {
  const textRef = useRef<Konva.Text>();
  const [size, setSize] = useState({ width: 0, height: 0 });
  
  useEffect(() => {
    if (textRef.current) {
      // Measure without width constraint first
      textRef.current.width('auto');
      const naturalWidth = textRef.current.width();
      
      if (naturalWidth > maxWidth) {
        textRef.current.width(maxWidth);
      }
      
      setSize({
        width: textRef.current.width(),
        height: textRef.current.height()
      });
    }
  }, [text, maxWidth]);
  
  return <Text ref={textRef} text={text} />;
};
```

### 8. Memory Leaks with Konva Nodes

```typescript
// ❌ WRONG - Konva nodes not cleaned up
const BadComponent = () => {
  useEffect(() => {
    const stage = new Konva.Stage({ container: 'container' });
    // No cleanup!
  }, []);
};

// ✅ CORRECT - Proper cleanup
const GoodComponent = () => {
  const stageRef = useRef<Konva.Stage>();
  
  useEffect(() => {
    stageRef.current = new Konva.Stage({ container: 'container' });
    
    return () => {
      // Destroy Konva nodes to free memory
      stageRef.current?.destroy();
    };
  }, []);
};
```

### 9. Drag Boundaries & Constraints

```typescript
// ❌ WRONG - Constraints don't account for scale
<Rect 
  draggable
  dragBoundFunc={(pos) => {
    return {
      x: Math.max(0, Math.min(pos.x, 500)),
      y: Math.max(0, Math.min(pos.y, 500))
    };
  }}
/>

// ✅ CORRECT - Account for parent transforms
<Rect 
  draggable
  dragBoundFunc={(pos) => {
    const stage = this.getStage();
    const scale = stage.scaleX();
    const parent = this.getParent();
    
    // Convert boundaries to local space
    const bounds = {
      minX: 0,
      maxX: (parent.width() - this.width()),
      minY: 0,
      maxY: (parent.height() - this.height())
    };
    
    return {
      x: Math.max(bounds.minX, Math.min(pos.x, bounds.maxX)),
      y: Math.max(bounds.minY, Math.min(pos.y, bounds.maxY))
    };
  }}
/>
```

### 10. Batch Operations for Performance

```typescript
// ❌ WRONG - Multiple individual updates
elements.forEach(el => {
  el.x(newX);
  el.y(newY);
  layer.batchDraw(); // Drawing multiple times!
});

// ✅ CORRECT - Batch all updates
layer.batchDraw(() => {
  elements.forEach(el => {
    el.position({ x: newX, y: newY });
  });
}); // Single draw at the end
```

## Special Considerations for Sections

### Section Clipping

```typescript
// ✅ Implement proper clipping for section content
<Group 
  x={section.x} 
  y={section.y}
  clipFunc={(ctx) => {
    // Clip to section bounds
    ctx.rect(0, 0, section.width, section.height);
  }}
>
  {children}
</Group>
```

### Section Hit Detection

```typescript
// ✅ Custom hit detection for section borders
<Rect
  width={section.width}
  height={section.height}
  fill="transparent"
  stroke="#ddd"
  hitFunc={(context, shape) => {
    const width = shape.width();
    const height = shape.height();
    const strokeWidth = shape.strokeWidth();
    
    // Only detect hits on the border, not inside
    context.beginPath();
    context.rect(0, 0, width, height);
    context.rect(
      strokeWidth, 
      strokeWidth, 
      width - strokeWidth * 2, 
      height - strokeWidth * 2
    );
    context.fillStrokeShape(shape);
  }}
/>
```

## Performance Testing Helpers

```typescript
// Add to development environment
const KonvaPerformanceMonitor = {
  logRenderStats() {
    const stage = Konva.stages[0];
    console.log({
      totalNodes: stage.find('*').length,
      shapes: stage.find('Shape').length,
      groups: stage.find('Group').length,
      cached: stage.find('Shape').filter(s => s.isCached()).length,
      listening: stage.find('*').filter(n => n.listening()).length
    });
  },
  
  measureRedraw() {
    const start = performance.now();
    Konva.stages[0].draw();
    console.log(`Redraw took ${performance.now() - start}ms`);
  }
};
```

## Final Tips

1. **Always profile**: Use Chrome DevTools Performance tab
2. **Watch node count**: `stage.find('*').length` should stay reasonable
3. **Monitor memory**: Check for detached DOM nodes
4. **Test at scale**: Always test with 1000+ elements
5. **Mobile testing**: Touch events behave differently

Remember: Konva is powerful but has quirks. When in doubt, check what Konva is actually doing with `node.getAbsoluteTransform()` and `node.getClientRect()`!
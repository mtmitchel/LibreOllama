KANBAN/TASKS FEATURE COMPLETE CODE EXPORT
Generated: 07/09/2025 12:30:37

This document contains ALL code related to the kanban/tasks feature in LibreOllama.
This includes components, tests, services, stores, hooks, utilities, types, and workers.


====================================================================================================
FILE: src/app/pages/Tasks.tsx
DESCRIPTION: Main Tasks page component - Entry point for the kanban interface
====================================================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { Card, Button, Toast, FlexibleGrid } from '../../components/ui';
import { Plus, LayoutGrid, List as ListIcon } from 'lucide-react';
import {
  DndContext,
  DragOverlay,
  useSensor,
  useSensors,
  PointerSensor,
  KeyboardSensor,
  closestCorners,
} from '@dnd-kit/core';
import { sortableKeyboardCoordinates } from '@dnd-kit/sortable';
import { useShallow } from 'zustand/react/shallow';

// Import our new modular components and hooks
import {
  TaskCard,
  TaskColumn,
  TaskModal,
  CompactDragCard,
  TaskColumnSkeleton,
} from '../../features/tasks';
import { useGoogleStore } from '../../stores/googleStore';
import { useKanbanDrag, useTaskSyncQueue, useKanbanUI, useTaskForm } from '../../features/tasks/hooks';
import { setTaskMetadata, prepareTaskForAPI } from '../../features/tasks/utils/taskHelpers';

export default function Tasks() {
  const {
    viewMode,
    setViewMode,
    error,
    setError,
    toasts,
    addToast,
    removeToast,
  } = useKanbanUI();
  
  const [hasInitialized, setHasInitialized] = useState(false);
  
  const { pendingOperations, processQueue, isSyncing } = useTaskSyncQueue(addToast);
  
  const {
    taskLists,
    kanbanColumns,
    isLoadingTasks,
    activeAccount,
    createTask,
    updateTask,
    deleteTask,
    toggleTaskCompletion,
    fetchTaskLists,
    fetchAllTasks,
    optimisticUpdateTask,
    taskIdToListId,
    fetchTasksForList,
  } = useGoogleStore(
    useShallow((state) => {
      return {
        taskLists: state.taskLists,
        kanbanColumns: state.kanbanColumns,
        isLoadingTasks: state.isLoadingTasks,
        activeAccount: state.activeAccount,
        createTask: state.createTask,
        updateTask: state.updateTask,
        deleteTask: state.deleteTask,
        toggleTaskCompletion: state.toggleTaskCompletion,
        fetchTaskLists: state.fetchTaskLists,
        fetchAllTasks: state.fetchAllTasks,
        optimisticUpdateTask: state.optimisticUpdateTask,
        taskIdToListId: state.taskIdToListId,
        fetchTasksForList: state.fetchTasksForList,
      };
    })
  );

  const { dragState, handleDragStart, handleDragOver, handleDragEnd } = useKanbanDrag(
    kanbanColumns,
    pendingOperations,
    processQueue
  );

  const {
    modalState,
    taskForm,
    formErrors,
    openCreateModal,
    openEditModal,
    closeModal,
    updateTaskForm,
    addLabel,
    removeLabel,
    addSubtask,
    updateSubtask,
    removeSubtask,
  } = useTaskForm();

  // Determine if the task currently shown in the modal is actively syncing
  const isModalTaskSyncing = (() => {
    if (!modalState.isOpen || modalState.type !== 'edit' || !modalState.task) return false;
    const currentId = (modalState.task as any).id;
    return pendingOperations.current.some(op => op.taskId === currentId);
  })();

  // --- Data Handling Callbacks ---
  const handleCreateTask = useCallback(async (taskListId: string, taskData: any) => {
    try {
      await createTask(taskListId, taskData);
      return true;
    } catch (error) {
      console.error('Failed to create task:', error);
      return false;
    }
  }, [createTask]);

  const handleUpdateTask = useCallback(async (taskListId: string, taskId: string, taskData: any) => {
    try {
      await updateTask(taskListId, taskId, taskData);
      return true;
    } catch (error) {
      console.error('Failed to update task:', error);
      return false;
    }
  }, [updateTask]);

  const handleSubmitTask = async (taskListId: string, taskData: any) => {
    try {
      // Import helper lazily to avoid circular deps
      const { encodeEnhancedTaskData } = await import('../../features/tasks/utils/taskHelpers');

      /* 1. Start with any enhanced properties that already exist on the task being edited.
         This prevents us from accidentally stripping data (e.g. labels / priority) in cases
         where the user opens the edit modal but does not touch those fields. */
      const existingEnhancedProps: Record<string, any> = modalState.type === 'edit' && modalState.task
        ? {
            labels: modalState.task.labels,
            priority: modalState.task.priority,
            subtasks: modalState.task.subtasks,
            recurring: modalState.task.recurring,
          }
        : {};

      // 2. Overlay the latest values coming from the form.  We intentionally allow users to
      //    clear a field – e.g. remove all labels – so an empty array should REMOVE the property.
      const enhancedData: Record<string, any> = { ...existingEnhancedProps };

      const mergeOrDelete = (key: keyof typeof taskData, value: any) => {
        if (value === undefined) return;
        if (Array.isArray(value) && value.length === 0) {
          delete enhancedData[key as string];
        } else if (typeof value === 'object' && value !== null && Object.keys(value).length === 0) {
          // Empty object -> delete
          delete enhancedData[key as string];
        } else {
          enhancedData[key as string] = value;
        }
      };

      mergeOrDelete('labels', taskData.labels);
      mergeOrDelete('priority', taskData.priority && taskData.priority !== 'normal' ? taskData.priority : undefined);
      mergeOrDelete('subtasks', taskData.subtasks);
      mergeOrDelete('recurring', taskData.recurring && taskData.recurring.enabled ? taskData.recurring : undefined);

      /* 3. Store metadata in separate store for better reliability */
      if (modalState.type === 'edit' && modalState.task) {
        setTaskMetadata(modalState.task.id, enhancedData);
      }

      /* 4. Build the Google-compatible payload. */
      let googleTaskData: any = {
        title: taskData.title,
        notes: taskData.notes || '',
        due: taskData.due ? new Date(taskData.due + 'T00:00:00.000Z').toISOString() : undefined,
      };

      // 5. For API compatibility, prepare data with metadata in notes field
      if (modalState.type === 'edit' && modalState.task) {
        googleTaskData = prepareTaskForAPI(modalState.task.id, googleTaskData);
      } else {
        // For new tasks, encode enhanced data directly
        if (Object.keys(enhancedData).length > 0) {
          const encodedData = encodeEnhancedTaskData(enhancedData);
          googleTaskData.notes = googleTaskData.notes.trim()
            ? `${googleTaskData.notes} ${encodedData}`
            : encodedData;
        }
      }

      if (modalState.type === 'edit' && modalState.task) {
        // Resolve the authoritative list ID from the store's mapping in case the task was moved
        const mappedListId = taskIdToListId.get(modalState.task.id) || taskListId;
        
        console.log('[Tasks] Updating task:', {
          taskId: modalState.task.id,
          originalListId: taskListId,
          mappedListId,
          taskData: googleTaskData,
          enhancedData
        });
        
        // Apply optimistic update for immediate visual feedback
        optimisticUpdateTask(mappedListId, modalState.task.id, {
          title: googleTaskData.title,
          notes: googleTaskData.notes,
          due: googleTaskData.due,
          labels: enhancedData.labels,
          priority: enhancedData.priority,
          subtasks: enhancedData.subtasks,
          recurring: enhancedData.recurring,
        });
        
        const success = await handleUpdateTask(mappedListId, modalState.task.id, googleTaskData);
        if (!success) {
          addToast('error', 'Update Failed', 'Unable to update the task. Please try again.');
          // Revert optimistic update on failure
          optimisticUpdateTask(mappedListId, modalState.task.id, {
            title: modalState.task.title,
            notes: modalState.task.notes,
            due: modalState.task.due,
            labels: modalState.task.labels,
            priority: modalState.task.priority,
            subtasks: modalState.task.subtasks,
            recurring: modalState.task.recurring,
          });
        }
        return success;
      }
      
      const success = await handleCreateTask(taskListId, googleTaskData);
      if (!success) {
        addToast('error', 'Creation Failed', 'Unable to create the task. Please try again.');
      }
      return success;
    } catch (error) {
      console.error('Error in handleSubmitTask:', error);
      addToast('error', 'Operation Failed', error instanceof Error ? error.message : 'An unexpected error occurred');
      return false;
    }
  };

  const handleToggleCompletion = useCallback(async (taskListId: string, taskId: string, currentStatus: 'needsAction' | 'completed') => {
    const completed = currentStatus !== 'completed';
    optimisticUpdateTask(taskListId, taskId, { status: completed ? 'completed' : 'needsAction' });
    await toggleTaskCompletion(taskListId, taskId, completed);
  }, [toggleTaskCompletion, optimisticUpdateTask]);

  const handleDeleteTask = useCallback(async (e: React.MouseEvent, taskListId: string, taskId: string) => {
    e.preventDefault();
    e.stopPropagation();
    await deleteTask(taskListId, taskId);
  }, [deleteTask]);

  const handleRetrySync = useCallback((taskId: string) => {
    const state = useGoogleStore.getState();
    const syncState = state.taskSyncState.get(taskId);
    
    if (syncState && syncState.status === 'failed') {
      // Clear the failed state
      state.optimisticUpdateTask(syncState.targetListId || '', taskId, {});
      
      // Find the pending operation and retry
      const failedOp = pendingOperations.current.find(op => op.taskId === taskId);
      if (failedOp) {
        processQueue();
      } else if (syncState.originalListId && syncState.targetListId) {
        // If no pending operation, create a new move operation
        pendingOperations.current.push({
          type: 'move',
          taskId,
          sourceListId: syncState.originalListId,
          targetListId: syncState.targetListId,
          originalTaskTitle: 'Task' // We don't have the title here, but it's just for error messages
        });
        processQueue();
      }
    }
  }, [processQueue]);

  // --- Data Initialization ---
  useEffect(() => {
    if (activeAccount && !hasInitialized) {
      const initializeData = async () => {
        try {
          await fetchTaskLists();
          setHasInitialized(true);
        } catch (err) {
          console.error('Failed to initialize tasks:', err);
          setError('Failed to load task lists. Please try again.');
        }
      };
      initializeData();
    }
  }, [activeAccount, hasInitialized, fetchTaskLists, setError]);

  useEffect(() => {
    if (taskLists.length > 0 && hasInitialized) {
      fetchAllTasks().catch((err: any) => {
        console.error('Failed to fetch tasks:', err);
        setError('Failed to load tasks. Please try again.');
      });
    }
  }, [taskLists.length, hasInitialized, fetchAllTasks, setError]);

  // --- Sensor Configuration ---
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: { distance: 5, delay: 0, tolerance: 3 },
    }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  const onTaskClick = (task: any, listId: string) => {
    openEditModal(task, listId);
  };
  
  // --- Render Logic ---
  if ((isLoadingTasks || !hasInitialized) && taskLists.length === 0) {
    return (
      <div className="w-full h-full p-6 lg:p-8">
        {/* View Toggle Controls Skeleton */}
        <Card className="mb-6">
          <div className="flex items-center justify-between p-4">
            <div className="flex items-center gap-4">
              <div className="h-8 bg-[var(--bg-secondary)] rounded animate-pulse w-32"></div>
            </div>
            <div className="h-8 bg-[var(--bg-secondary)] rounded animate-pulse w-24"></div>
          </div>
        </Card>
        
        {/* Skeleton Columns using FlexibleGrid */}
        <FlexibleGrid minItemWidth={320} gap={6} className="w-full">
          {[...Array(3)].map((_, i) => (
            <TaskColumnSkeleton key={i} />
          ))}
        </FlexibleGrid>
      </div>
    );
  }

  if (error) {
    return (
      <div className="w-full h-full p-6 lg:p-8">
        <Card className="border-error bg-error-ghost">
          <div className="flex items-center gap-3 p-4">
            <div className="flex-1">
              <p className="text-error font-medium">Error loading tasks</p>
              <p className="text-error-muted text-sm mt-1">{error}</p>
            </div>
            <Button variant="outline" size="sm" onClick={() => { setError(null); setHasInitialized(false); }}>
              Retry
            </Button>
          </div>
        </Card>
      </div>
    );
  }

  if (!activeAccount) {
    return (
      <div className="w-full h-full p-6 lg:p-8 flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-lg font-semibold text-primary mb-2">No Google Account Connected</h2>
          <p className="text-muted">Please connect a Google account to view your tasks.</p>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-full p-6 lg:p-8">
      {/* Toast Container */}
      <div className="fixed top-20 right-8 z-50 space-y-2">
        {toasts.map(toast => (
          <Toast key={toast.id} variant={toast.variant} title={toast.title} message={toast.message} onDismiss={() => removeToast(toast.id)} />
        ))}
      </div>

      {/* View Toggle Controls */}
      <Card className="mb-6">
        <div className="flex items-center justify-between p-4">
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-1 bg-[var(--bg-secondary)] rounded-[var(--radius-md)] p-1">
              <Button variant={viewMode === 'kanban' ? 'secondary' : 'ghost'} size="sm" onClick={() => setViewMode('kanban')} className="flex items-center gap-2">
                <LayoutGrid size={16} /> Board
              </Button>
              <Button variant={viewMode === 'list' ? 'secondary' : 'ghost'} size="sm" onClick={() => setViewMode('list')} className="flex items-center gap-2">
                <ListIcon size={16} /> List
              </Button>
            </div>
            {isSyncing && (
              <div className="flex items-center gap-2 text-sm text-muted">
                <div className="w-3 h-3 border-2 border-primary border-t-transparent rounded-full animate-spin"></div>
                <span>Syncing...</span>
              </div>
            )}
          </div>
          {kanbanColumns.length > 0 && (
            <Button variant="primary" onClick={() => { if (kanbanColumns.length > 0 && kanbanColumns[0]) { openCreateModal(kanbanColumns[0].taskList.id, kanbanColumns[0].taskList.title); } }} className="flex items-center gap-2">
              <Plus size={16} /> New Task
            </Button>
          )}
        </div>
      </Card>

      {/* Main Content */}
      {viewMode === 'kanban' && (
        <DndContext 
          sensors={sensors} 
          onDragStart={handleDragStart} 
          onDragOver={handleDragOver} 
          onDragEnd={handleDragEnd} 
          collisionDetection={closestCorners}
        >
          <div className="w-full">
            <FlexibleGrid minItemWidth={320} gap={6} className="w-full">
              {kanbanColumns.map(column => (
                <div key={column.taskList.id} className="flex-1 min-w-0">
                  <TaskColumn
                    id={column.taskList.id}
                    taskList={column.taskList}
                    tasks={column.tasks}
                    onTaskClick={onTaskClick}
                    onToggleCompletion={handleToggleCompletion}
                    onDeleteTask={handleDeleteTask}
                    onOpenCreateModal={openCreateModal}
                    isDragStarted={!!dragState.activeTask}
                    onRetrySync={handleRetrySync}
                  />
                </div>
              ))}
            </FlexibleGrid>
          </div>
          <DragOverlay 
            dropAnimation={{ 
              duration: 200, 
              easing: 'cubic-bezier(0.18, 0.67, 0.6, 1.22)' 
            }}
            className="cursor-grabbing"
          >
            {dragState.activeTask ? <CompactDragCard task={dragState.activeTask} /> : null}
          </DragOverlay>
        </DndContext>
      )}
      
      {viewMode === 'list' && (
        <Card className="w-full max-w-none">
          {(() => {
            const allTasks = kanbanColumns.flatMap((column: any) => column.tasks.map((task: any) => ({ ...task, taskListId: column.taskList.id, taskListTitle: column.taskList.title })));
            return (
              <>
                <div className="p-4 border-b border-border-default">
                  <h2 className="text-lg font-semibold text-primary">All Tasks ({allTasks.length})</h2>
                </div>
                <div className="divide-y divide-border-default">
                  {allTasks.map((task: any) => (
                    <div key={`${task.taskListId}-${task.id}`} className="p-4">
                      <TaskCard
                        task={task}
                        listId={task.taskListId}
                        onTaskClick={onTaskClick}
                        onToggleCompletion={handleToggleCompletion}
                        onDeleteTask={handleDeleteTask}
                        isDragStarted={false}
                        onRetrySync={handleRetrySync}
                      />
                    </div>
                  ))}
                </div>
                {allTasks.length === 0 && (
                  <div className="text-center p-6 text-muted">
                    No tasks found. 
                    <Button variant="ghost" onClick={() => { if (kanbanColumns.length > 0) { openCreateModal(kanbanColumns[0].taskList.id, kanbanColumns[0].taskList.title); } }} className="text-primary hover:text-primary-hover ml-1">
                      Create one now!
                    </Button>
                  </div>
                )}
              </>
            );
          })()}
        </Card>
      )}

      <TaskModal modalState={modalState} taskForm={taskForm} formErrors={formErrors} taskLists={taskLists} isLoading={isModalTaskSyncing} onClose={closeModal} onSubmit={handleSubmitTask} onUpdateForm={updateTaskForm} onAddLabel={addLabel} onRemoveLabel={removeLabel} onAddSubtask={addSubtask} onUpdateSubtask={updateSubtask} onRemoveSubtask={removeSubtask} />

      {kanbanColumns.length === 0 && !isLoadingTasks && hasInitialized && (
        <div className="flex items-center justify-center py-12">
          <div className="text-center">
            <div className="w-16 h-16 bg-[var(--bg-secondary)] rounded-full flex items-center justify-center mx-auto mb-4">
              <ListIcon size={24} className="text-muted" />
            </div>
            <h3 className="text-lg font-medium text-primary mb-2">No task lists found</h3>
            <p className="text-muted mb-6">Create your first task list to get started</p>
          </div>
        </div>
      )}
    </div>
  );
} 

END OF FILE: src/app/pages/Tasks.tsx


====================================================================================================
FILE: src/features/tasks/components/index.ts
DESCRIPTION: Task components index file
====================================================================================================

export { TaskCard } from './TaskCard';
export { TaskColumn } from './TaskColumn';
export { CompactDragCard } from './CompactDragCard';
export { TaskModal } from './TaskModal';
export { TaskColumnSkeleton } from './TaskColumnSkeleton'; 

END OF FILE: src/features/tasks/components/index.ts


====================================================================================================
FILE: src/features/tasks/components/TaskCard.tsx
DESCRIPTION: Individual task card component with drag/drop functionality
====================================================================================================

import React, { memo, useMemo, useCallback } from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { CheckCircle, CircleDashed, Trash2, Flag, Hash, GripVertical, AlertTriangle } from 'lucide-react';
import type { SortableTaskItemProps } from '../types';
import { 
  isTaskOverdue, 
  formatDueDate, 
  getStatusBadge, 
  parseEnhancedTaskData, 
  cleanTaskNotes, 
  getSubtaskData 
} from '../utils/taskHelpers';
import { Card, Button, Tag } from '../../../components/ui';
import { useGoogleStore } from '../../../stores/googleStore';

// Memoized TaskCard for performance
export const TaskCard = memo<SortableTaskItemProps>(({ 
  task, 
  listId, 
  onTaskClick, 
  onToggleCompletion, 
  onDeleteTask, 
  isDragStarted,
  onRetrySync
}) => {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ 
    id: task.id,
    // Disable drag handle when dragging is already started
    disabled: isDragStarted
  });

  // Get sync state from store
  const syncState = useGoogleStore(state => state.taskSyncState.get(task.id));
  const isUnsynced = syncState?.status === 'failed';

  // Memoized calculations to prevent recalculation on every render
  const taskData = useMemo(() => {
    // FIRST: prefer already-extracted props from store enhancement
    const directLabels = (task as any).labels as string[] | undefined;
    const directPriority = (task as any).priority as any;

    // Fallback to legacy notes parsing for backward-compat / tasks that still store metadata inline
    const enhancedDataInNotes = parseEnhancedTaskData(task.notes || '');

    const labels = directLabels ?? enhancedDataInNotes.labels ?? [];
    const priority = directPriority ?? enhancedDataInNotes.priority ?? 'normal';

    const cleanNotes = cleanTaskNotes(task.notes || '');
    const isCompleted = task.status === 'completed';
    const isOverdue = isTaskOverdue(task) && !isCompleted;
    const subtaskData = getSubtaskData(task);
    const statusBadge = getStatusBadge(task);

    return {
      labels,
      priority,
      cleanNotes,
      isCompleted,
      isOverdue,
      ...subtaskData,
      statusBadge,
    };
  }, [task]);

  // Optimized drag style calculation
  const dragStyle = useMemo(() => ({
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.7 : 1,
    zIndex: isDragging ? 50 : 'auto',
  }), [transform, transition, isDragging]);

  // Memoized event handlers
  const handleTaskClick = useCallback((e: React.MouseEvent) => {
    if (!isDragStarted && !e.defaultPrevented) {
      onTaskClick(task, listId);
    }
  }, [isDragStarted, onTaskClick, task, listId]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if ((e.key === 'Enter' || e.key === ' ') && !isDragStarted) {
      e.preventDefault();
      onTaskClick(task, listId);
    }
  }, [isDragStarted, onTaskClick, task, listId]);

  const handleToggle = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    onToggleCompletion(listId, task.id, task.status);
  }, [onToggleCompletion, listId, task.id, task.status]);

  const handleDelete = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    onDeleteTask(e, listId, task.id);
  }, [onDeleteTask, listId, task.id]);

  return (
    <div ref={setNodeRef} style={dragStyle}>
      <Card
        className={`group relative bg-[var(--bg-surface)] cursor-pointer transition-all duration-200 hover:bg-[var(--bg-surface-hover)] hover:shadow-sm focus-within:ring-2 focus-within:ring-primary focus-within:ring-offset-1 ${
          isDragging ? 'shadow-lg border-primary rotate-1' : ''
        } ${
          isUnsynced 
            ? 'border-l-4 border-l-error bg-error-ghost border-error'
            : taskData.isCompleted 
              ? 'border-l-4 border-l-success bg-success-ghost border-border-default' 
              : 'border-border-default hover:border-border-hover'
        }`}
        onClick={handleTaskClick}
        role="button"
        tabIndex={0}
        onKeyDown={handleKeyDown}
        aria-label={`Task: ${task.title}. ${taskData.isCompleted ? 'Completed.' : ''} ${task.due ? `Due ${formatDueDate(task.due)}.` : ''} ${taskData.hasSubtasks ? `${taskData.completedSubtasks} of ${taskData.subtaskCount} subtasks.` : ''} Click to edit.`}
      >
      {/* OPTIMIZED: Dedicated drag handle instead of invisible overlay */}
      <div 
        className="absolute left-2 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 cursor-grab active:cursor-grabbing z-30"
        {...attributes}
        {...listeners}
        onClick={(e) => e.stopPropagation()}
        aria-label="Drag to reorder task"
        title="Drag to reorder"
      >
        <GripVertical size={16} className="text-muted hover:text-primary" />
      </div>

      {/* Action Icons - Optimized positioning */}
      <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 z-20">
        <Button
          variant="ghost"
          size="icon"
          onClick={handleDelete}
          className="p-2 text-muted hover:text-error hover:bg-error-ghost rounded focus:outline-none focus:ring-2 focus:ring-error focus:ring-offset-1"
          aria-label={`Delete task: ${task.title}`}
          title="Delete task"
          tabIndex={-1}
        >
          <Trash2 size={14} />
        </Button>
      </div>

      {/* Main Content - OPTIMIZED: Add left padding for drag handle */}
      <div style={{ padding: 'var(--space-4) var(--space-5)', paddingLeft: 'calc(var(--space-5) + 24px)' }} className="relative z-10">
        
        {/* ZONE 1: Title + Checkbox */}
        <div className="flex items-start gap-3 pr-8">
          {/* Status Checkbox */}
          <Button
            variant="ghost"
            size="icon"
            onClick={handleToggle}
            className="flex-shrink-0 mt-1 text-muted hover:text-primary transition-colors focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-1 rounded"
            aria-label={taskData.isCompleted ? "Mark as incomplete" : "Mark as complete"}
            title={taskData.isCompleted ? "Mark as incomplete" : "Mark as complete"}
            tabIndex={-1}
          >
            {taskData.isCompleted ? (
              <CheckCircle size={18} className="text-success" />
            ) : (
              <CircleDashed size={18} className="text-muted" />
            )}
          </Button>
          
          {/* Task Title */}
          <div className="flex-1 min-w-0">
            <h3 
              className={`transition-colors leading-tight font-semibold text-base ${
                taskData.isCompleted ? 'text-muted line-through' : 'text-primary'
              }`}
            >
              {task.title}
            </h3>
            
            {/* NEW: Unsynced Indicator */}
            {isUnsynced && (
              <div className="mt-2 flex items-center gap-2 text-error text-sm">
                <AlertTriangle size={14} />
                <span>Sync failed.</span>
                <Button 
                  variant="ghost" 
                  size="sm" 
                  className="text-error h-auto p-0 underline"
                  onClick={(e) => {
                    e.stopPropagation();
                    onRetrySync?.(task.id);
                  }}
                >
                  Retry
                </Button>
              </div>
            )}

            {/* Priority indicator */}
            {(taskData.priority === 'high' || taskData.priority === 'urgent') && (
              <div className="mt-1">
                <Tag 
                  variant="solid" 
                  color={taskData.priority === 'urgent' ? 'error' : 'warning'} 
                  size="sm"
                  className="inline-flex items-center gap-1"
                >
                  <Flag size={10} />
                  {taskData.priority === 'urgent' ? 'Urgent' : 'High Priority'}
                </Tag>
              </div>
            )}
          </div>
        </div>

        {/* ZONE 2: Description */}
        {taskData.cleanNotes && (
          <div className="pl-6 mt-2">
            <p 
              className={`leading-relaxed text-sm ${
                taskData.isCompleted ? 'text-muted' : 'text-secondary'
              }`}
            >
              {taskData.cleanNotes}
            </p>
          </div>
        )}

        {/* Labels */}
        {taskData.labels.length > 0 && (
          <div className="flex flex-wrap gap-1 pl-6 mt-2">
            {taskData.labels.slice(0, 3).map((label: string, index: number) => (
              <Tag 
                key={index} 
                variant="ghost" 
                color="primary" 
                size="sm"
                className="inline-flex items-center gap-1"
              >
                <Hash size={8} />
                {label}
              </Tag>
            ))}
            {taskData.labels.length > 3 && (
              <Tag 
                variant="ghost" 
                color="muted" 
                size="sm"
              >
                +{taskData.labels.length - 3}
              </Tag>
            )}
          </div>
        )}

        {/* ZONE 3: Metadata Row */}
        {(taskData.hasSubtasks || task.due || taskData.statusBadge) && (
          <div 
            className="flex items-center border-t border-border-muted pt-2 mt-3"
            style={{ 
              fontSize: '0.85rem',
              marginLeft: 'var(--space-6)'
            }}
          >
            <div className="flex items-center gap-3">
              {/* Checklist progress */}
              {taskData.hasSubtasks && (
                <div className="flex items-center gap-1 text-muted">
                  <CheckCircle size={12} />
                  <span>✓ {taskData.completedSubtasks}/{taskData.subtaskCount}</span>
                </div>
              )}
              
              {/* Due Date */}
              {task.due && (
                <>
                  {taskData.hasSubtasks && <span className="text-border-muted">•</span>}
                  <span className={`${
                    taskData.isOverdue ? 'text-error font-medium' : taskData.isCompleted ? 'text-muted' : 'text-secondary'
                  }`}>
                    Due {taskData.isOverdue ? 'yesterday' : formatDueDate(task.due)}
                  </span>
                </>
              )}
            </div>
            
            {/* Status Badge */}
            {taskData.statusBadge && (
              <Tag 
                variant="solid" 
                color="muted" 
                size="sm"
                className="ml-auto"
              >
                {taskData.statusBadge.text}
              </Tag>
            )}
          </div>
        )}
      </div>
    </Card>
    </div>
  );
}, (prevProps, nextProps) => {
  return (
    prevProps.task.id === nextProps.task.id &&
    prevProps.task.title === nextProps.task.title &&
    prevProps.task.status === nextProps.task.status &&
    prevProps.task.notes === nextProps.task.notes &&
    prevProps.task.due === nextProps.task.due &&
    prevProps.task.priority === (nextProps.task as any).priority &&
    JSON.stringify((prevProps.task as any).labels) === JSON.stringify((nextProps.task as any).labels) &&
    prevProps.listId === nextProps.listId &&
    prevProps.isDragStarted === nextProps.isDragStarted
  );
}); 

END OF FILE: src/features/tasks/components/TaskCard.tsx


====================================================================================================
FILE: src/features/tasks/components/TaskColumn.tsx
DESCRIPTION: Kanban column component for task lists
====================================================================================================

import React, { memo, useMemo, useCallback, useRef } from 'react';
import { useDroppable } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { Plus } from 'lucide-react';
import type { GoogleTask, GoogleTaskList } from '../types';
import { TaskCard } from './TaskCard';
import { Card, Button, Tag } from '../../../components/ui';

interface DroppableColumnProps {
  children: React.ReactNode;
  id: string;
  className?: string;
}

export interface TaskColumnProps {
  id: string;
  taskList: GoogleTaskList;
  tasks: GoogleTask[];
  onTaskClick: (task: GoogleTask, listId: string) => void;
  onToggleCompletion: (taskListId: string, taskId: string, currentStatus: 'needsAction' | 'completed') => void;
  onDeleteTask: (e: React.MouseEvent, taskListId: string, taskId: string) => void;
  onOpenCreateModal: (columnId: string, columnTitle: string) => void;
  isDragStarted: boolean;
  onRetrySync?: (taskId: string) => void;
}

// Memoized droppable column component that forwards ref so the parent can access the scroll container
const DroppableColumn = memo(
  React.forwardRef<HTMLDivElement, DroppableColumnProps>(
    ({ children, id, className }, ref) => {
      const { setNodeRef, isOver } = useDroppable({ id });

      // Merge DnD kit's setNodeRef with forwarded ref so both get the DOM element
      const setRefs = React.useCallback(
        (node: HTMLDivElement | null) => {
          setNodeRef(node);
          if (typeof ref === 'function') {
            ref(node);
          } else if (ref) {
            (ref as React.MutableRefObject<HTMLDivElement | null>).current = node;
          }
        },
        [ref, setNodeRef]
      );

      return (
        <div
          ref={setRefs}
          className={`${className} ${isOver ? 'bg-primary-ghost border-primary border-2 border-dashed' : ''} transition-colors duration-150`}
        >
          {children}
        </div>
      );
    }
  )
);

// Optimized TaskColumn with memoization
export const TaskColumn = memo<TaskColumnProps>(({
  taskList,
  tasks,
  onTaskClick,
  onToggleCompletion,
  onDeleteTask,
  onOpenCreateModal,
  isDragStarted,
  onRetrySync,
}) => {
  const parentRef = useRef<HTMLDivElement>(null);

  // Memoized task IDs for SortableContext
  const taskIds = useMemo(() => tasks.map(task => task.id), [tasks]);
  
  const { taskCount, completedCount } = useMemo(() => {
    return {
      taskCount: tasks.filter(t => t.status === 'needsAction').length,
      completedCount: tasks.filter(t => t.status === 'completed').length,
    }
  }, [tasks]);

  // Memoized event handlers to prevent unnecessary re-renders
  const handleOpenCreateModal = useCallback(() => {
    onOpenCreateModal(taskList.id, taskList.title);
  }, [onOpenCreateModal, taskList.id, taskList.title]);

  // Memoized empty state component
  const emptyState = useMemo(() => {
    if (tasks.length > 0) return null;
    
    return (
      <div className="text-center py-8 text-muted">
        <p>No tasks yet</p>
        <p className="text-sm mt-1">Create your first task below</p>
      </div>
    );
  }, [tasks.length]);

  return (
    <Card className="flex flex-col h-full min-h-[600px] bg-[var(--bg-tertiary)] w-full">
      {/* Column Header - Optimized */}
      <div className="p-4 border-b border-border-default bg-[var(--bg-surface)] rounded-t-[var(--radius-lg)]">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-primary">
            {taskList.title}
          </h2>
          <div className="flex items-center gap-3">
            <Tag variant="solid" color="primary" size="sm">
              {taskCount}
            </Tag>
            {completedCount > 0 && (
              <Tag variant="solid" color="success" size="sm">
                ✓ {completedCount}
              </Tag>
            )}
          </div>
        </div>
      </div>

      {/* Tasks Container - Optimized with better visual feedback */}
      <DroppableColumn 
        id={taskList.id} 
        ref={parentRef}
        className="flex-1 overflow-y-auto"
      >
        <div className="p-4 space-y-3">
          {tasks.length === 0 ? (
            emptyState
          ) : (
            <SortableContext 
              items={taskIds} 
              strategy={verticalListSortingStrategy}
            >
              {tasks.map(task => (
                <TaskCard
                  key={task.id}
                  task={task}
                  listId={taskList.id}
                  onTaskClick={onTaskClick}
                  onToggleCompletion={onToggleCompletion}
                  onDeleteTask={onDeleteTask}
                  isDragStarted={isDragStarted}
                  onRetrySync={onRetrySync}
                />
              ))}
            </SortableContext>
          )}
        </div>
      </DroppableColumn>

      {/* Add Task Button - Optimized event handler */}
      <div className="p-4 bg-[var(--bg-surface)] border-t border-border-default rounded-b-[var(--radius-lg)]">
        <Button
          variant="ghost"
          onClick={handleOpenCreateModal}
          className="w-full flex items-center justify-center gap-2 py-3 text-muted bg-[var(--bg-secondary)] hover:bg-[var(--bg-secondary-hover)] hover:text-primary rounded-[var(--radius-md)] border border-dashed border-border-muted hover:border-border-default transition-all duration-200"
          aria-label={`Add new task to ${taskList.title}`}
        >
          <Plus size={18} />
          <span className="font-medium">Add Task</span>
        </Button>
      </div>
    </Card>
  );
}, (prevProps, nextProps) => {
  // Custom comparison for memo optimization
  return (
    prevProps.taskList.id === nextProps.taskList.id &&
    prevProps.taskList.title === nextProps.taskList.title &&
    prevProps.tasks.length === nextProps.tasks.length &&
    prevProps.isDragStarted === nextProps.isDragStarted &&
    // Check if task statuses have changed
    prevProps.tasks.every((prevTask, index) => {
      const nextTask = nextProps.tasks[index];
      return nextTask && 
        prevTask.id === nextTask.id && 
        prevTask.status === nextTask.status &&
        prevTask.title === nextTask.title &&
        (prevTask as any).unsynced === (nextTask as any).unsynced;
    })
  );
}); 

END OF FILE: src/features/tasks/components/TaskColumn.tsx


====================================================================================================
FILE: src/features/tasks/components/TaskColumnSkeleton.tsx
DESCRIPTION: Loading skeleton for task columns
====================================================================================================

import React from 'react';
import { Card } from '../../../components/ui';

export const TaskColumnSkeleton = React.memo(() => {
  return (
    <Card className="flex flex-col h-full min-h-[600px] bg-[var(--bg-tertiary)] w-full">
      {/* Header Skeleton */}
      <div className="p-4 border-b border-border-default bg-[var(--bg-surface)] rounded-t-[var(--radius-lg)]">
        <div className="flex items-center justify-between">
          <div className="h-6 bg-[var(--bg-secondary)] rounded animate-pulse w-24"></div>
          <div className="flex items-center gap-3">
            <div className="h-5 bg-[var(--bg-secondary)] rounded animate-pulse w-6"></div>
            <div className="h-5 bg-[var(--bg-secondary)] rounded animate-pulse w-8"></div>
          </div>
        </div>
      </div>

      {/* Tasks Skeleton */}
      <div className="p-4 space-y-3 flex-1">
        {[...Array(3)].map((_, i) => (
          <div key={i} className="bg-[var(--bg-surface)] rounded-[var(--radius-md)] p-4 border border-border-default">
            <div className="flex items-start gap-3">
              <div className="w-4 h-4 bg-[var(--bg-secondary)] rounded-full animate-pulse mt-1"></div>
              <div className="flex-1 space-y-2">
                <div className="h-4 bg-[var(--bg-secondary)] rounded animate-pulse w-3/4"></div>
                <div className="h-3 bg-[var(--bg-secondary)] rounded animate-pulse w-1/2"></div>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Add Button Skeleton */}
      <div className="p-4 bg-[var(--bg-surface)] border-t border-border-default rounded-b-[var(--radius-lg)]">
        <div className="h-10 bg-[var(--bg-secondary)] rounded-[var(--radius-md)] animate-pulse"></div>
      </div>
    </Card>
  );
});

TaskColumnSkeleton.displayName = 'TaskColumnSkeleton'; 

END OF FILE: src/features/tasks/components/TaskColumnSkeleton.tsx


====================================================================================================
FILE: src/features/tasks/components/TaskModal.tsx
DESCRIPTION: Modal for creating/editing tasks
====================================================================================================

import React, { useState, useEffect } from 'react';
import { X, List, Repeat, Hash, Plus, ChevronDown, ChevronRight, CalendarIcon } from 'lucide-react';
import { Button, Card, Input, Tag } from '../../../components/ui';
import type { TaskModalState, TaskFormData, GoogleTaskList, GoogleTask } from '../types';
import { formatDueDate } from '../utils/taskHelpers';

export interface TaskModalProps {
  modalState: TaskModalState;
  taskForm: TaskFormData;
  formErrors: Record<string, string>;
  taskLists: GoogleTaskList[];
  currentTaskId?: string;
  isLoading?: boolean;
  onClose: () => void;
  onSubmit: (taskListId: string, taskData: TaskFormData) => Promise<boolean>;
  onUpdateForm: (updates: Partial<TaskFormData>) => void;
  onAddLabel: (label: string) => void;
  onRemoveLabel: (label: string) => void;
  onAddSubtask: (title: string) => void;
  onUpdateSubtask: (subtaskId: string, updates: any) => void;
  onRemoveSubtask: (subtaskId: string) => void;
}

interface ExpandedSections {
  subtasks: boolean;
  recurring: boolean;
  labels: boolean;
}

export function TaskModal({
  modalState,
  taskForm,
  formErrors,
  taskLists,
  currentTaskId,
  isLoading = false,
  onClose,
  onSubmit,
  onUpdateForm,
  onAddLabel,
  onRemoveLabel,
  onAddSubtask,
  onUpdateSubtask,
  onRemoveSubtask,
}: TaskModalProps) {
  const [expandedSections, setExpandedSections] = useState<ExpandedSections>({
    subtasks: false,
    recurring: false,
    labels: false,
  });
  
  const [newSubtaskInput, setNewSubtaskInput] = useState('');
  const [newLabelInput, setNewLabelInput] = useState('');

  // Auto-expand sections that have data when editing
  useEffect(() => {
    if (modalState.type === 'edit' && modalState.isOpen) {
      setExpandedSections({
        labels: (taskForm.labels?.length || 0) > 0,
        subtasks: (taskForm.subtasks?.length || 0) > 0,
        recurring: taskForm.recurring?.enabled || false,
      });
    } else if (modalState.type === 'create') {
      // Reset to collapsed for create mode
      setExpandedSections({
        subtasks: false,
        recurring: false,
        labels: false,
      });
    }
  }, [modalState.type, modalState.isOpen, taskForm.labels, taskForm.subtasks, taskForm.recurring]);

  if (!modalState.isOpen) return null;

  const isEditMode = modalState.type === 'edit';
  const selectedTaskList = modalState.columnId || taskLists[0]?.id || '';

  const toggleSection = (section: keyof ExpandedSections) => {
    setExpandedSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };

  const handleAddSubtask = () => {
    if (newSubtaskInput.trim()) {
      onAddSubtask(newSubtaskInput.trim());
      setNewSubtaskInput('');
    }
  };

  const handleAddLabel = () => {
    if (newLabelInput.trim()) {
      onAddLabel(newLabelInput.trim());
      setNewLabelInput('');
    }
  };

  const handleSubmit = async () => {
    const success = await onSubmit(selectedTaskList, taskForm);
    if (success) {
      onClose();
    }
  };

  const updateSubtaskDueDate = (subtaskId: string, due: string) => {
    onUpdateSubtask(subtaskId, { due });
  };

  const toggleSubtask = (subtaskId: string) => {
    const subtask = taskForm.subtasks?.find(s => s.id === subtaskId);
    if (subtask) {
      onUpdateSubtask(subtaskId, { completed: !subtask.completed });
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="fixed inset-0 bg-black bg-opacity-50" onClick={onClose} />
      <Card className="relative z-10 w-full max-w-2xl mx-4 p-6 max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-semibold text-gray-900">
            {isEditMode ? 'Edit Task' : 'Create New Task'}
          </h2>
          <Button
            variant="ghost"
            size="icon"
            onClick={onClose}
            className="focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          >
            <X size={20} />
          </Button>
        </div>

        <div className="space-y-6">
          {/* Basic Information */}
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-900 mb-1">
                Task List
              </label>
              <select
                value={selectedTaskList}
                onChange={(e) => onUpdateForm({ parent: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:border-blue-500"
                disabled={isEditMode} // Can't change task list when editing
              >
                {taskLists.map(taskList => (
                  <option key={taskList.id} value={taskList.id}>
                    {taskList.title}
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-900 mb-1">
                Task Title *
              </label>
              <Input
                type="text"
                value={taskForm.title}
                onChange={(e) => onUpdateForm({ title: e.target.value })}
                placeholder="Enter task title"
                className={`w-full ${formErrors.title ? 'border-red-500' : ''}`}
                autoFocus
              />
              {formErrors.title && (
                <p className="text-red-600 text-sm mt-1">{formErrors.title}</p>
              )}
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-900 mb-1">
                Description
              </label>
              <textarea
                value={taskForm.notes}
                onChange={(e) => onUpdateForm({ notes: e.target.value })}
                placeholder="Add description (optional)"
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:border-blue-500"
                rows={3}
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-900 mb-1">
                  Due Date
                </label>
                <Input
                  type="date"
                  value={taskForm.due}
                  onChange={(e) => onUpdateForm({ due: e.target.value })}
                  className={`w-full ${formErrors.due ? 'border-red-500' : ''}`}
                />
                {formErrors.due && (
                  <p className="text-red-600 text-sm mt-1">{formErrors.due}</p>
                )}
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-900 mb-1">
                  Priority
                </label>
                <select
                  value={taskForm.priority}
                  onChange={(e) => onUpdateForm({ priority: e.target.value as any })}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:border-blue-500"
                >
                  <option value="low">Low</option>
                  <option value="normal">Normal</option>
                  <option value="high">High</option>
                  <option value="urgent">Urgent</option>
                </select>
              </div>
            </div>
          </div>

          {/* Subtasks Section */}
          <div className="border border-gray-300 rounded-lg">
            <button
              type="button"
              onClick={() => toggleSection('subtasks')}
              className="w-full flex items-center justify-between p-4 text-left hover:bg-gray-50 transition-colors"
            >
              <div className="flex items-center gap-2">
                <List size={16} className="text-gray-500" />
                <span className="font-medium text-gray-900">Subtasks</span>
                {(taskForm.subtasks?.length || 0) > 0 && (
                  <Tag variant="solid" color="muted" size="xs">
                    {taskForm.subtasks?.length || 0}
                  </Tag>
                )}
              </div>
              {expandedSections.subtasks ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
            </button>
            {expandedSections.subtasks && (
              <div className="p-4 border-t border-gray-300 space-y-3">
                <div className="flex gap-2">
                  <Input
                    type="text"
                    value={newSubtaskInput}
                    onChange={(e) => setNewSubtaskInput(e.target.value)}
                    placeholder="Add a subtask"
                    className="flex-1"
                    onKeyPress={(e) => e.key === 'Enter' && handleAddSubtask()}
                  />
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleAddSubtask}
                    disabled={!newSubtaskInput.trim()}
                  >
                    <Plus size={16} />
                  </Button>
                </div>
                
                {taskForm.subtasks && taskForm.subtasks.length > 0 && (
                  <div className="space-y-2">
                    {taskForm.subtasks.map(subtask => (
                      <div key={subtask.id} className="p-3 bg-gray-50 rounded-md border border-gray-200">
                        <div className="flex items-center gap-2 mb-2">
                          <input
                            type="checkbox"
                            checked={subtask.completed}
                            onChange={() => toggleSubtask(subtask.id)}
                            className="rounded border-gray-300"
                          />
                          <span className={`flex-1 text-sm font-medium ${subtask.completed ? 'line-through text-gray-500' : 'text-gray-900'}`}>
                            {subtask.title}
                          </span>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => onRemoveSubtask(subtask.id)}
                            className="text-red-600 hover:bg-red-50 p-1"
                          >
                            <X size={14} />
                          </Button>
                        </div>
                        
                        {/* Subtask Due Date */}
                        <div className="flex items-center gap-2 ml-6">
                          <CalendarIcon size={14} className="text-gray-500" />
                          <Input
                            type="date"
                            value={subtask.due ? new Date(subtask.due).toISOString().split('T')[0] : ''}
                            onChange={(e) => updateSubtaskDueDate(subtask.id, e.target.value)}
                            className="text-xs h-8 w-32"
                            placeholder="Due date"
                          />
                          {subtask.due && (
                            <span className={`text-xs ${
                              new Date(subtask.due) < new Date() && !subtask.completed 
                                ? 'text-red-600 font-medium' 
                                : 'text-gray-500'
                            }`}>
                              {formatDueDate(subtask.due)}
                            </span>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Recurring Tasks Section */}
          <div className="border border-gray-300 rounded-lg">
            <button
              type="button"
              onClick={() => toggleSection('recurring')}
              className="w-full flex items-center justify-between p-4 text-left hover:bg-gray-50 transition-colors"
            >
              <div className="flex items-center gap-2">
                <Repeat size={16} className="text-gray-500" />
                <span className="font-medium text-gray-900">Recurring Task</span>
              </div>
              {expandedSections.recurring ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
            </button>
            {expandedSections.recurring && (
              <div className="p-4 border-t border-gray-300 space-y-4">
                <div className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    id="recurring-enabled"
                    checked={taskForm.recurring?.enabled || false}
                    onChange={(e) => onUpdateForm({
                      recurring: { 
                        enabled: e.target.checked,
                        frequency: taskForm.recurring?.frequency || 'daily',
                        interval: taskForm.recurring?.interval || 1,
                        endDate: taskForm.recurring?.endDate || ''
                      }
                    })}
                    className="rounded border-gray-300"
                  />
                  <label htmlFor="recurring-enabled" className="text-sm text-gray-900">
                    Make this task recurring
                  </label>
                </div>
                
                {taskForm.recurring?.enabled && (
                  <div className="space-y-3 ml-6">
                    <div className="grid grid-cols-2 gap-3">
                      <div>
                        <label className="block text-xs font-medium text-gray-500 mb-1">
                          Frequency
                        </label>
                        <select
                          value={taskForm.recurring?.frequency || 'daily'}
                          onChange={(e) => onUpdateForm({
                            recurring: { 
                              enabled: taskForm.recurring?.enabled || false,
                              frequency: e.target.value as 'daily' | 'weekly' | 'monthly' | 'yearly',
                              interval: taskForm.recurring?.interval || 1,
                              endDate: taskForm.recurring?.endDate || ''
                            }
                          })}
                          className={`w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 ${formErrors.recurringFrequency ? 'border-red-500' : ''}`}
                        >
                          <option value="daily">Daily</option>
                          <option value="weekly">Weekly</option>
                          <option value="monthly">Monthly</option>
                          <option value="yearly">Yearly</option>
                        </select>
                        {formErrors.recurringFrequency && (
                          <p className="text-red-600 text-xs mt-1">{formErrors.recurringFrequency}</p>
                        )}
                      </div>
                      <div>
                        <label className="block text-xs font-medium text-gray-500 mb-1">
                          Every
                        </label>
                        <Input
                          type="number"
                          min="1"
                          value={taskForm.recurring?.interval || 1}
                          onChange={(e) => onUpdateForm({
                            recurring: { 
                              enabled: taskForm.recurring?.enabled || false,
                              frequency: taskForm.recurring?.frequency || 'daily',
                              interval: parseInt(e.target.value) || 1,
                              endDate: taskForm.recurring?.endDate || ''
                            }
                          })}
                          className={`w-full text-sm ${formErrors.recurringInterval ? 'border-red-500' : ''}`}
                        />
                        {formErrors.recurringInterval && (
                          <p className="text-red-600 text-xs mt-1">{formErrors.recurringInterval}</p>
                        )}
                      </div>
                    </div>
                    <div>
                      <label className="block text-xs font-medium text-gray-500 mb-1">
                        End Date (optional)
                      </label>
                      <Input
                        type="date"
                        value={taskForm.recurring?.endDate || ''}
                        onChange={(e) => onUpdateForm({
                          recurring: { 
                            enabled: taskForm.recurring?.enabled || false,
                            frequency: taskForm.recurring?.frequency || 'daily',
                            interval: taskForm.recurring?.interval || 1,
                            endDate: e.target.value
                          }
                        })}
                        className={`w-full text-sm ${formErrors.recurringEndDate ? 'border-red-500' : ''}`}
                      />
                      {formErrors.recurringEndDate && (
                        <p className="text-red-600 text-xs mt-1">{formErrors.recurringEndDate}</p>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Labels Section */}
          <div className="border border-gray-300 rounded-lg">
            <button
              type="button"
              onClick={() => toggleSection('labels')}
              className="w-full flex items-center justify-between p-4 text-left hover:bg-gray-50 transition-colors"
            >
              <div className="flex items-center gap-2">
                <Hash size={16} className="text-gray-500" />
                <span className="font-medium text-gray-900">Labels</span>
                {(taskForm.labels?.length || 0) > 0 && (
                  <Tag variant="solid" color="muted" size="xs">
                    {taskForm.labels?.length || 0}
                  </Tag>
                )}
              </div>
              {expandedSections.labels ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
            </button>
            {expandedSections.labels && (
              <div className="p-4 border-t border-gray-300 space-y-3">
                <div className="flex gap-2">
                  <Input
                    type="text"
                    value={newLabelInput}
                    onChange={(e) => setNewLabelInput(e.target.value)}
                    placeholder="Add a label"
                    className="flex-1"
                    onKeyPress={(e) => e.key === 'Enter' && handleAddLabel()}
                  />
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleAddLabel}
                    disabled={!newLabelInput.trim()}
                  >
                    <Plus size={16} />
                  </Button>
                </div>
                
                {taskForm.labels && taskForm.labels.length > 0 && (
                  <div className="flex flex-wrap gap-2">
                    {taskForm.labels.map((label, index) => (
                      <span 
                        key={index} 
                        className="inline-flex items-center gap-1 px-2 py-1 bg-blue-50 text-blue-700 rounded-full text-sm font-medium group hover:bg-blue-100 transition-colors"
                      >
                        <Hash size={12} />
                        {label}
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => onRemoveLabel(label)}
                          className="text-blue-700 hover:bg-blue-200 p-0 h-4 w-4 ml-1 rounded-full opacity-70 group-hover:opacity-100 transition-opacity"
                        >
                          <X size={10} />
                        </Button>
                      </span>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-3 mt-8">
          <Button
            variant="ghost"
            onClick={onClose}
            className="focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          >
            Cancel
          </Button>
          <Button
            variant="primary"
            onClick={handleSubmit}
            disabled={!taskForm.title.trim() || isLoading}
            className="focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          >
            {isLoading ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                {isEditMode ? 'Updating...' : 'Creating...'}
              </>
            ) : (
              isEditMode ? 'Update Task' : 'Create Task'
            )}
          </Button>
        </div>
      </Card>
    </div>
  );
} 

END OF FILE: src/features/tasks/components/TaskModal.tsx


====================================================================================================
FILE: src/features/tasks/components/CompactDragCard.tsx
DESCRIPTION: Compact drag card for task dragging
====================================================================================================

import React from 'react';
import { Card } from '../../../components/ui';
import type { HierarchicalTask } from '../types';

interface CompactDragCardProps {
  task: HierarchicalTask;
}

const CompactDragCard = React.memo(({ task }: CompactDragCardProps) => {
  return (
    <Card 
      className="p-3 border-2 border-dashed border-primary bg-primary-ghost shadow-lg rounded-lg"
      style={{
        opacity: 0.9,
        transform: 'rotate(3deg)', // Slight tilt for visual distinction
      }}
    >
      <p className="text-sm font-medium text-primary truncate">
        {task.title}
      </p>
    </Card>
  );
});

CompactDragCard.displayName = 'CompactDragCard';

export { CompactDragCard }; 

END OF FILE: src/features/tasks/components/CompactDragCard.tsx


====================================================================================================
FILE: src/features/tasks/hooks/index.ts
DESCRIPTION: Task hooks index file
====================================================================================================

export * from './useKanbanDrag';
export * from './useTaskSyncQueue';
export * from './useKanbanUI';
export * from './useTaskForm'; 

END OF FILE: src/features/tasks/hooks/index.ts


====================================================================================================
FILE: src/features/tasks/hooks/useKanbanDrag.ts
DESCRIPTION: Hook for kanban drag and drop functionality
====================================================================================================

import { useState, useCallback, useMemo } from 'react';
import { DragStartEvent, DragOverEvent, DragEndEvent } from '@dnd-kit/core';
import { useGoogleStore } from '../../../stores/googleStore';
import { useShallow } from 'zustand/react/shallow';
import type { HierarchicalTask, DragState } from '../types';

export function useKanbanDrag(
    kanbanColumns: any[], 
    pendingOperations: React.MutableRefObject<any[]>, 
    processQueue: () => void
) {
    const { taskIdToListId, optimisticMoveTask, optimisticReorderTask, activeAccount } = useGoogleStore(
        useShallow((state) => ({
            taskIdToListId: state.taskIdToListId,
            optimisticMoveTask: state.optimisticMoveTask,
            optimisticReorderTask: state.optimisticReorderTask,
            activeAccount: state.activeAccount,
        }))
    );

    // Create a flat task lookup for better performance
    const taskLookup = useMemo(() => {
        const lookup = new Map<string, HierarchicalTask>();
        
        const addTasksToLookup = (tasks: HierarchicalTask[]) => {
            for (const task of tasks) {
                lookup.set(task.id, task);
                if (task.children) {
                    addTasksToLookup(task.children);
                }
            }
        };
        
        kanbanColumns.forEach(column => {
            addTasksToLookup(column.tasks);
        });
        
        return lookup;
    }, [kanbanColumns]);

    const [dragState, setDragState] = useState<DragState>({
        activeTask: null,
        sourceListId: null,
    });

    const handleDragStart = useCallback((event: DragStartEvent) => {
        const { active } = event;
        const sourceListId = taskIdToListId.get(active.id as string);
        const task = taskLookup.get(active.id as string);

        if (task && sourceListId) {
            setDragState({
                activeTask: task,
                sourceListId: sourceListId,
            });
        }
    }, [taskLookup, taskIdToListId]);

    const handleDragOver = useCallback((event: DragOverEvent) => {
        const { active, over } = event;
        if (!over || active.id === over.id) return;
        
        const activeId = active.id as string;
        const overId = over.id as string;
        const sourceListId = dragState.sourceListId;
        
        const overIsAColumn = kanbanColumns.some(c => c.taskList.id === overId);
        
        const targetListId = overIsAColumn ? overId : taskIdToListId.get(overId);

        if (!sourceListId || !targetListId) return;

        if (sourceListId !== targetListId) {
            optimisticMoveTask(activeId, sourceListId, targetListId);
            setDragState(prev => ({ ...prev, sourceListId: targetListId }));
        } else {
            // Only reorder if we're not dragging over a column
            if(!overIsAColumn) {
                optimisticReorderTask(sourceListId, activeId, overId);
            }
        }
    }, [dragState.sourceListId, kanbanColumns, optimisticMoveTask, optimisticReorderTask, taskIdToListId]);

    const handleDragEnd = useCallback(async (event: DragEndEvent) => {
        const { active, over } = event;
        
        if (over && active.id !== over.id && dragState.activeTask && activeAccount) {
            const { activeTask, sourceListId } = dragState;

            // Determine target list ID
            const overIsColumn = kanbanColumns.some(c => c.taskList.id === over.id);
            const targetListId = overIsColumn ? over.id as string : taskIdToListId.get(over.id as string);
            
            if (targetListId && sourceListId) {
                let previous: string | undefined;

                // For reordering within same list or moving to different list
                if (!overIsColumn) {
                    // Dropping on a task - use that task as the previous reference
                    previous = over.id as string;
                } else {
                    // Dropping on a column - add to the end
                    const targetColumn = kanbanColumns.find(c => c.taskList.id === targetListId);
                    if (targetColumn && targetColumn.tasks.length > 0) {
                        previous = targetColumn.tasks[targetColumn.tasks.length - 1].id;
                    }
                }

                pendingOperations.current.push({
                    id: `${activeTask.id}-${Date.now()}`,
                    taskId: activeTask.id,
                    accountId: activeAccount.id,
                    sourceListId: sourceListId,
                    targetListId: targetListId,
                    previous: previous,
                    timestamp: Date.now(),
                    originalTask: activeTask
                });
                
                // Process queue immediately instead of using setTimeout
                processQueue();
            }
        }
        
        setDragState({ activeTask: null, sourceListId: null });
    }, [dragState, kanbanColumns, processQueue, taskIdToListId, pendingOperations, activeAccount]);

    return {
        dragState,
        handleDragStart,
        handleDragOver,
        handleDragEnd,
    };
} 

END OF FILE: src/features/tasks/hooks/useKanbanDrag.ts


====================================================================================================
FILE: src/features/tasks/hooks/useKanbanUI.ts
DESCRIPTION: Hook for kanban UI state management
====================================================================================================

import { useState, useCallback, useEffect } from 'react';
import { useHeader } from '../../../app/contexts/HeaderContext';

interface ToastMessage {
    id: string;
    variant: 'info' | 'success' | 'warning' | 'error';
    title: string;
    message: string;
}

export function useKanbanUI() {
    const { setHeaderProps, clearHeaderProps } = useHeader();
    const [viewMode, setViewMode] = useState<'kanban' | 'list'>('kanban');
    const [error, setError] = useState<string | null>(null);
    const [toasts, setToasts] = useState<ToastMessage[]>([]);

    useEffect(() => {
        setHeaderProps({ title: "Tasks" });
        return () => clearHeaderProps();
    }, [setHeaderProps, clearHeaderProps]);
    
    const addToast = useCallback((variant: ToastMessage['variant'], title: string, message: string) => {
        const id = Date.now().toString();
        setToasts(prev => [...prev, { id, variant, title, message }]);
    }, []);

    const removeToast = useCallback((id: string) => {
        setToasts(prev => prev.filter(toast => toast.id !== id));
    }, []);

    return {
        viewMode,
        setViewMode,
        error,
        setError,
        toasts,
        addToast,
        removeToast,
        setHasInitialized: useState(false)[1] // We only need the setter
    };
} 

END OF FILE: src/features/tasks/hooks/useKanbanUI.ts


====================================================================================================
FILE: src/features/tasks/hooks/useTaskForm.ts
DESCRIPTION: Hook for task form handling
====================================================================================================

import { useState, useCallback } from 'react';
import type { TaskFormData, TaskModalState, EnhancedGoogleTask } from '../types';

export function useTaskForm() {
  const [modalState, setModalState] = useState<TaskModalState>({
    type: null,
    columnId: null,
    columnTitle: null,
    isOpen: false,
    task: null,
  });

  const [taskForm, setTaskForm] = useState<TaskFormData>({
    title: '',
    notes: '',
    due: '',
    priority: 'normal',
    recurring: {
      enabled: false,
      frequency: 'weekly',
      interval: 1,
      endDate: '',
    },
    labels: [],
    subtasks: [],
  });

  const [formErrors, setFormErrors] = useState<Record<string, string>>({});

  const openCreateModal = useCallback((columnId: string, columnTitle: string) => {
    setModalState({
      type: 'create',
      columnId,
      columnTitle,
      isOpen: true,
      task: null,
    });
    
    // Reset form
    setTaskForm({
      title: '',
      notes: '',
      due: '',
      priority: 'normal',
      recurring: {
        enabled: false,
        frequency: 'weekly',
        interval: 1,
        endDate: '',
      },
      labels: [],
      subtasks: [],
    });
    setFormErrors({});
  }, []);

  const openEditModal = useCallback((task: EnhancedGoogleTask, listId: string) => {
    setModalState({
      type: 'edit',
      columnId: listId,
      columnTitle: null,
      isOpen: true,
      task: task,
    });

    // Populate form with task data (enhanced data is already extracted by store)
    setTaskForm({
      title: task.title,
      notes: task.notes || '', // Notes are already cleaned by store
      due: task.due ? new Date(task.due).toISOString().split('T')[0] : '',
      priority: task.priority || 'normal',
      recurring: task.recurring || {
        enabled: false,
        frequency: 'weekly',
        interval: 1,
        endDate: '',
      },
      labels: [...(task.labels || [])], // Create a new array to avoid reference issues
      subtasks: [...(task.subtasks || [])], // Create a new array to avoid reference issues
    });
    setFormErrors({});
  }, []);

  const closeModal = useCallback(() => {
    setModalState({
      type: null,
      columnId: null,
      columnTitle: null,
      isOpen: false,
      task: null,
    });
    
    // Reset form state completely to prevent data leaking between tasks
    setTaskForm({
      title: '',
      notes: '',
      due: '',
      priority: 'normal',
      recurring: {
        enabled: false,
        frequency: 'weekly',
        interval: 1,
        endDate: '',
      },
      labels: [],
      subtasks: [],
    });
    setFormErrors({});
  }, []);

  const updateTaskForm = useCallback((updates: Partial<TaskFormData>) => {
    setTaskForm(prev => ({ ...prev, ...updates }));
    
    // Clear relevant errors when fields are updated
    if (updates.title !== undefined && formErrors.title) {
      setFormErrors(prev => ({ ...prev, title: '' }));
    }
  }, [formErrors]);

  const addLabel = useCallback((label: string) => {
    if (label.trim() && !taskForm.labels?.includes(label.trim())) {
      setTaskForm(prev => ({
        ...prev,
        labels: [...(prev.labels || []), label.trim()]
      }));
    }
  }, [taskForm.labels]);

  const removeLabel = useCallback((labelToRemove: string) => {
    setTaskForm(prev => ({
      ...prev,
      labels: (prev.labels || []).filter(label => label !== labelToRemove)
    }));
  }, []);

  const addSubtask = useCallback((title: string) => {
    if (title.trim()) {
      const newSubtask = {
        id: Date.now().toString(),
        title: title.trim(),
        completed: false,
        due: '',
      };
      setTaskForm(prev => ({
        ...prev,
        subtasks: [...(prev.subtasks || []), newSubtask]
      }));
    }
  }, []);

  const updateSubtask = useCallback((subtaskId: string, updates: Partial<{ id: string; title: string; completed: boolean; due: string; }>) => {
    setTaskForm(prev => ({
      ...prev,
      subtasks: (prev.subtasks || []).map(subtask =>
        subtask.id === subtaskId ? { ...subtask, ...updates } : subtask
      )
    }));
  }, []);

  const removeSubtask = useCallback((subtaskId: string) => {
    setTaskForm(prev => ({
      ...prev,
      subtasks: (prev.subtasks || []).filter(subtask => subtask.id !== subtaskId)
    }));
  }, []);

  const validateForm = useCallback((): boolean => {
    const errors: Record<string, string> = {};

    if (!taskForm.title.trim()) {
      errors.title = 'Task title is required';
    }

    if (taskForm.due) {
      const dueDate = new Date(taskForm.due);
      if (isNaN(dueDate.getTime())) {
        errors.due = 'Invalid due date';
      }
    }

    if (taskForm.recurring?.enabled) {
      if (!taskForm.recurring.frequency) {
        errors.recurringFrequency = 'Recurring frequency is required';
      }
      if (taskForm.recurring.interval < 1) {
        errors.recurringInterval = 'Interval must be at least 1';
      }
      if (taskForm.recurring.endDate) {
        const endDate = new Date(taskForm.recurring.endDate);
        if (isNaN(endDate.getTime())) {
          errors.recurringEndDate = 'Invalid end date';
        } else if (taskForm.due && endDate <= new Date(taskForm.due)) {
          errors.recurringEndDate = 'End date must be after due date';
        }
      }
    }

    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  }, [taskForm]);

  const resetForm = useCallback(() => {
    setTaskForm({
      title: '',
      notes: '',
      due: '',
      priority: 'normal',
      recurring: {
        enabled: false,
        frequency: 'weekly',
        interval: 1,
        endDate: '',
      },
      labels: [],
      subtasks: [],
    });
    setFormErrors({});
  }, []);

  return {
    // State
    modalState,
    taskForm,
    formErrors,

    // Actions
    openCreateModal,
    openEditModal,
    closeModal,
    updateTaskForm,
    addLabel,
    removeLabel,
    addSubtask,
    updateSubtask,
    removeSubtask,
    validateForm,
    resetForm,
  };
} 

END OF FILE: src/features/tasks/hooks/useTaskForm.ts


====================================================================================================
FILE: src/features/tasks/hooks/useTaskSyncQueue.ts
DESCRIPTION: Hook for task synchronization queue management
====================================================================================================

import { useState, useRef, useCallback, useEffect } from "react";
import { useGoogleStore } from "../../../stores/googleStore";

type ToastFn = (variant: 'error', title: string, message: string) => void;

export function useTaskSyncQueue(addToast: ToastFn) {
    const pendingOperations = useRef<any[]>([]);
    const [isSyncing, setIsSyncing] = useState<boolean>(false);
    const workerRef = useRef<Worker | null>(null);
    const toastFnRef = useRef(addToast);

    // Keep the toast function ref updated without causing re-renders
    useEffect(() => {
        toastFnRef.current = addToast;
    }, [addToast]);

    useEffect(() => {
        // Initialize the worker with error handling
        try {
            workerRef.current = new Worker(new URL('../workers/taskSync.worker.ts', import.meta.url), {
                type: 'module',
            });

            // Handle messages from the worker - extract to avoid stale closure
            const messageHandler = (event: MessageEvent<any>) => {
                const { type, payload } = event.data;
                const store = useGoogleStore.getState();

                switch (type) {
                    case 'sync-started':
                        setIsSyncing(true);
                        break;
                    case 'operation-success':
                        console.log(`Task ${payload.taskId} synced successfully (Operation ID: ${payload.operationId}).`);
                        // Remove successful operation from queue
                        pendingOperations.current = pendingOperations.current.filter(op => op.operationId !== payload.operationId);
                        // Only mark as synced if this was the expected operation
                        const syncState = store.taskSyncState.get(payload.taskId);
                        if (syncState && syncState.status === 'pending') {
                            // Update the task's list mapping
                            if (payload.targetListId) {
                                store.taskIdToListId.set(payload.taskId, payload.targetListId);
                            }
                            // Mark as synced in store (don't trigger another move operation)
                            store.optimisticUpdateTask('', payload.taskId, { unsynced: false });
                            // Update sync state
                            store.taskSyncState.set(payload.taskId, {
                                ...syncState,
                                status: 'synced',
                                operationId: payload.operationId
                            });
                        }
                        break;
                    case 'operation-failure':
                        console.error(`Failed to sync task ${payload.taskId}:`, payload.error);
                        // Keep failed operation in queue for retry - don't remove it from pendingOperations
                        // Use the stable ref to call the toast function
                        toastFnRef.current('error', 'Sync Failed', `Could not move task "${payload.originalTaskTitle}". Click to retry.`);
                        // Mark sync state as failed but keep operation in queue
                        const failedSyncState = store.taskSyncState.get(payload.taskId);
                        if (failedSyncState) {
                            store.taskSyncState.set(payload.taskId, {
                                ...failedSyncState,
                                status: 'failed',
                                operationId: payload.operationId
                            });
                        }
                        break;
                    case 'sync-finished':
                        // Use functional update to avoid stale closure
                        setIsSyncing(false);
                        // Check if there are remaining operations to process (failed operations)
                        if (pendingOperations.current.length > 0) {
                            // Use requestAnimationFrame for smoother performance
                            requestAnimationFrame(() => {
                                // Call processQueue directly to avoid circular dependency
                                if (!workerRef.current || pendingOperations.current.length === 0) {
                                    return;
                                }
                                const operationsToProcess = [...pendingOperations.current];
                                workerRef.current.postMessage(operationsToProcess);
                            });
                        }
                        break;
                }
            };

            const errorHandler = (error: ErrorEvent) => {
                console.error('Worker error:', error);
                setIsSyncing(false);
                toastFnRef.current('error', 'Sync Error', 'Task synchronization worker encountered an error');
            };

            workerRef.current.onmessage = messageHandler;
            workerRef.current.onerror = errorHandler;

        } catch (error) {
            console.error('Failed to initialize worker:', error);
            // Gracefully handle worker initialization failure
            workerRef.current = null;
            toastFnRef.current('error', 'Sync Unavailable', 'Task synchronization is temporarily unavailable');
        }

        return () => {
            if (workerRef.current) {
                workerRef.current.onmessage = null; // Clear handler to prevent stale closure
                workerRef.current.onerror = null;
                workerRef.current.terminate();
            }
        };
    }, []); // No dependencies needed since we inline the queue processing

    const processQueue = () => {
        if (!workerRef.current || pendingOperations.current.length === 0) {
            return;
        }

        const operationsToProcess = [...pendingOperations.current];
        // Don't clear the queue immediately - wait for worker to process operations
        // The queue will be cleared when operations succeed or fail
        
        // Set syncing state when starting to process
        setIsSyncing(true);
        workerRef.current.postMessage(operationsToProcess);
    };

    return {
        pendingOperations,
        isSyncing,
        processQueue,
    };
} 

END OF FILE: src/features/tasks/hooks/useTaskSyncQueue.ts


====================================================================================================
FILE: src/features/tasks/utils/taskHelpers.ts
DESCRIPTION: Task helper functions and utilities
====================================================================================================

import type { GoogleTask, StatusBadge } from '../types';
import { useTaskMetadataStore } from '../../../stores/taskMetadataStore';

export const isTaskOverdue = (task: GoogleTask): boolean => {
  if (!task.due) return false;
  const dueDate = new Date(task.due);
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  return dueDate < today && task.status === 'needsAction';
};

export const formatDueDate = (dateStr: string): string => {
  const date = new Date(dateStr);
  return date.toLocaleDateString('en-US', { 
    month: 'short', 
    day: 'numeric', 
    year: 'numeric' 
  });
};

export const getStatusBadge = (task: GoogleTask): StatusBadge | null => {
  const isCompleted = task.status === 'completed';
  const isOverdue = isTaskOverdue(task) && !isCompleted;
  const isDueToday = task.due && new Date(task.due).toDateString() === new Date().toDateString();
  
  if (isCompleted) return { text: 'Complete', color: 'bg-green-100 text-green-800', textColor: '#155724' };
  if (isOverdue) return { text: 'Overdue', color: 'bg-red-100 text-red-800', textColor: '#721c24' };
  if (isDueToday) return { text: 'Due today', color: 'bg-orange-100 text-orange-800', textColor: '#9c4221' };
  return null;
};

export const parseEnhancedTaskData = (notes: string) => {
  const libreOllamaPattern = /\[LibreOllama:(.+?)\]$/;
  const match = notes.match(libreOllamaPattern);
  if (match) {
    try {
      return JSON.parse(match[1]);
    } catch (e) {
      return {};
    }
  }
  return {};
};

export const cleanTaskNotes = (notes: string): string => {
  return notes ? notes.replace(/\[LibreOllama:(.+?)\]$/, '').trim() : '';
};

export const encodeEnhancedTaskData = (data: any): string => {
  return `[LibreOllama:${JSON.stringify(data)}]`;
};

export const getSubtaskData = (task: GoogleTask) => {
  const subtaskCount = (task as any).children?.length || 0;
  const completedSubtasks = (task as any).children?.filter((child: any) => child.status === 'completed').length || 0;
  const hasSubtasks = subtaskCount > 0;
  
  return { subtaskCount, completedSubtasks, hasSubtasks };
};

// Enhanced task data helpers using metadata store
export const getTaskMetadata = (taskId: string) => {
  const metadataStore = useTaskMetadataStore.getState();
  return metadataStore.getTaskMetadata(taskId);
};

export const setTaskMetadata = (taskId: string, metadata: any) => {
  const metadataStore = useTaskMetadataStore.getState();
  metadataStore.setTaskMetadata(taskId, metadata);
};

export const syncTaskMetadata = (task: GoogleTask) => {
  const metadataStore = useTaskMetadataStore.getState();
  
  // Import existing metadata from notes field if present
  if (task.notes) {
    metadataStore.importFromNotesField(task.id, task.notes);
  }
  
  return metadataStore.getTaskMetadata(task.id);
};

export const prepareTaskForAPI = (taskId: string, taskData: any) => {
  const metadataStore = useTaskMetadataStore.getState();
  const metadata = metadataStore.getTaskMetadata(taskId);
  
  if (metadata) {
    // Export metadata to notes field for API compatibility
    const metadataString = metadataStore.exportToNotesField(taskId);
    const cleanNotes = taskData.notes ? cleanTaskNotes(taskData.notes) : '';
    
    return {
      ...taskData,
      notes: cleanNotes + (metadataString ? ` ${metadataString}` : '')
    };
  }
  
  return taskData;
}; 

// Throttle function for performance optimization
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout | null = null;
  let lastExecTime = 0;
  
  return (...args: Parameters<T>) => {
    const currentTime = Date.now();
    
    if (currentTime - lastExecTime > delay) {
      func.apply(null, args);
      lastExecTime = currentTime;
    } else {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        func.apply(null, args);
        lastExecTime = Date.now();
      }, delay - (currentTime - lastExecTime));
    }
  };
}

// Debounce function for performance optimization
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout | null = null;
  
  return (...args: Parameters<T>) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => func.apply(null, args), delay);
  };
}

// Optimized drag state manager
export class DragStateManager {
  private static instance: DragStateManager;
  private dragStartTime: number = 0;
  private isDragging: boolean = false;
  
  static getInstance(): DragStateManager {
    if (!DragStateManager.instance) {
      DragStateManager.instance = new DragStateManager();
    }
    return DragStateManager.instance;
  }
  
  startDrag(): void {
    this.isDragging = true;
    this.dragStartTime = performance.now();
  }
  
  endDrag(): number {
    this.isDragging = false;
    return performance.now() - this.dragStartTime;
  }
  
  isDragActive(): boolean {
    return this.isDragging;
  }
} 

END OF FILE: src/features/tasks/utils/taskHelpers.ts


====================================================================================================
FILE: src/features/tasks/types/index.ts
DESCRIPTION: Task type definitions
====================================================================================================

import { GoogleTask, HierarchicalTask, EnhancedGoogleTask } from '../../../types/google';

export interface DragState {
  activeTask: HierarchicalTask | null;
  sourceListId: string | null;
}

export interface TaskContextMenu {
  isOpen: boolean;
  taskId: string | null;
  taskListId: string | null;
  x: number;
  y: number;
}

export interface SortableTaskItemProps {
  task: GoogleTask;
  listId: string;
  onTaskClick: (task: GoogleTask, listId: string) => void;
  onToggleCompletion: (taskListId: string, taskId: string, currentStatus: 'needsAction' | 'completed') => void;
  onDeleteTask: (e: React.MouseEvent, taskListId: string, taskId: string) => void;
  isDragStarted: boolean;
  onRetrySync?: (taskId: string) => void;
}

export interface DroppableColumnProps {
  children: React.ReactNode;
  id: string;
  className?: string;
}

export interface TaskModalState {
  type: 'edit' | 'archive' | 'delete' | 'create' | null;
  columnId: string | null;
  columnTitle: string | null;
  isOpen: boolean;
  task?: EnhancedGoogleTask | null;
}

export interface TaskFormData {
  title: string;
  notes: string;
  due: string;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  parent?: string;
  position?: string;
  recurring?: {
    enabled: boolean;
    frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
    interval: number;
    endDate: string;
  };
  labels?: string[];
  subtasks?: Array<{
    id: string;
    title: string;
    completed: boolean;
    due: string;
  }>;
}

export interface StatusBadge {
  text: string;
  color: string;
  textColor: string;
}

// Re-export from Google types
export type { GoogleTask, GoogleTaskList, HierarchicalTask, TaskCreateData, EnhancedGoogleTask } from '../../../types/google'; 

END OF FILE: src/features/tasks/types/index.ts


====================================================================================================
FILE: src/features/tasks/workers/taskSync.worker.ts
DESCRIPTION: Background worker for task synchronization
====================================================================================================

// This is the Task Synchronization Web Worker.

// Import the invoke function for Tauri API calls
import { invoke } from '@tauri-apps/api/core';

// Use the appropriate invoke function based on environment
// In workers, we don't have access to window, so we check import.meta.env directly
const isDevMode = import.meta.env?.DEV || false;

// Mock function for development
const mockInvoke = async (command: string, args: any): Promise<any> => {
    console.log(`[Worker Mock] Invoking command: ${command}`, args);
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 500));

    // Simulate occasional failure for testing (reduced rate for better UX)
    if (Math.random() > 0.9) {
        throw new Error('Simulated network failure');
    }

    // Return mock success response based on command
    switch (command) {
        case 'move_task':
            return {
                id: args.taskId,
                title: 'Mock Task',
                status: 'needsAction',
                updated: new Date().toISOString(),
                selfLink: `https://example.com/task-${args.taskId}`,
                etag: `etag-${Date.now()}`,
            };
        default:
            return { success: true };
    }
};

const apiInvoke = isDevMode ? mockInvoke : invoke;

const performMoveTask = async (operation: any) => {
    console.log(`[Worker] Syncing task: ${operation.taskId} to list ${operation.targetListId}`);
    
    try {
        // Call the actual Tauri API to move the task
        const response = await apiInvoke('move_task', {
            accountId: operation.accountId,
            taskListId: operation.targetListId,
            taskId: operation.taskId,
            options: {
                parent: operation.parent,
                previous: operation.previous,
            }
        });
        
        console.log(`[Worker] Task ${operation.taskId} moved successfully`);
        return { success: true, data: response };
    } catch (error) {
        console.error(`[Worker] Failed to move task ${operation.taskId}:`, error);
        return { 
            success: false, 
            error: error instanceof Error ? error.message : 'Failed to move task' 
        };
    }
};


self.onmessage = async (event: MessageEvent<any[]>) => {
    const operations = event.data;

    console.log(`[Worker] Received ${operations.length} operations to process.`);
    self.postMessage({ type: 'sync-started' });

    // Process operations sequentially to prevent race conditions
    for (const op of operations) {
        const operationId = op.operationId || `op-${Date.now()}-${Math.random()}`;
        console.log(`[Worker] Processing operation ${operationId} for task ${op.taskId}`);
        
        const result = await performMoveTask(op);

        if (result.success) {
            // Add small delay to ensure mock service internal queue is settled
            await new Promise(resolve => setTimeout(resolve, 100));
            
            self.postMessage({
                type: 'operation-success',
                payload: { 
                    taskId: op.taskId,
                    operationId,
                    sourceListId: op.sourceListId,
                    targetListId: op.targetListId
                },
            });
        } else {
            self.postMessage({
                type: 'operation-failure',
                payload: { 
                    taskId: op.taskId,
                    operationId,
                    originalTaskTitle: op.originalTask.title,
                    sourceListId: op.sourceListId,
                    targetListId: op.targetListId,
                    error: result.error,
                },
            });
        }
    }

    self.postMessage({ type: 'sync-finished' });
};

export {}; 

END OF FILE: src/features/tasks/workers/taskSync.worker.ts


====================================================================================================
FILE: src/features/tasks/index.ts
DESCRIPTION: Main task feature index file
====================================================================================================

// Components
export * from './components';

// Hooks
export * from './hooks';

// Types
export * from './types';

// Utils
export * from './utils/taskHelpers'; 

END OF FILE: src/features/tasks/index.ts


====================================================================================================
FILE: src/stores/googleStore.ts
DESCRIPTION: Main Google store with task management functionality
====================================================================================================

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { produce } from 'immer';
import { 
  GoogleAccount, 
  GoogleTask, 
  GoogleTaskList, 
  GoogleCalendarEvent, 
  KanbanColumn,
  HierarchicalTask,
  TaskCreateData,
  EnhancedGoogleTask
} from '../types/google';
import { googleTasksService } from '../services/google/googleTasksService';
import { googleCalendarService } from '../services/google/googleCalendarService';
import { getMockAccount } from '../services/google/mockGoogleService';
import { useTaskMetadataStore } from './taskMetadataStore';

const isDevMode = import.meta.env.DEV;

// Utility function to move an item in an array
function arrayMove<T>(array: T[], from: number, to: number): T[] {
  const newArray = [...array];
  const [item] = newArray.splice(from, 1);
  newArray.splice(to, 0, item);
  return newArray;
}

// Utility function to parse LibreOllama data from notes
const parseTaskData = (task: GoogleTask): { cleanNotes: string; additionalData: any } => {
  const notes = task.notes || '';
  const libreOllamaPattern = /\[LibreOllama:(.+?)\]$/;
  const match = notes.match(libreOllamaPattern);
  
  if (match) {
    try {
      const additionalData = JSON.parse(match[1]);
      const cleanNotes = notes.replace(libreOllamaPattern, '').trim();
      return { cleanNotes, additionalData };
    } catch (e) {
      console.error('Failed to parse LibreOllama data from:', notes, 'Error:', e);
      return { cleanNotes: notes, additionalData: {} };
    }
  }
  
  return { cleanNotes: notes, additionalData: {} };
};

// Utility function to enhance task with parsed data
const enhanceTask = (task: GoogleTask): EnhancedGoogleTask => {
  const { cleanNotes, additionalData } = parseTaskData(task);
  const enhanced: EnhancedGoogleTask = {
    ...task,
    notes: cleanNotes,
    ...additionalData
  };
  
  return enhanced;
};

// Utility function to organize tasks hierarchically
const organizeTasks = (tasks: GoogleTask[]): HierarchicalTask[] => {
  const taskMap = new Map<string, HierarchicalTask>();
  const rootTasks: HierarchicalTask[] = [];
  
  // First pass: create hierarchical task objects and clean notes
  tasks.forEach(task => {
    const enhancedTask = enhanceTask(task);
    const hierarchicalTask: HierarchicalTask = {
      ...enhancedTask,
      children: [],
      depth: 0,
    };
    
    taskMap.set(task.id, hierarchicalTask);
  });
  
  // Second pass: organize hierarchy and calculate depth
  tasks.forEach(task => {
    const hierarchicalTask = taskMap.get(task.id)!;
    
    if (task.parent && taskMap.has(task.parent)) {
      // This is a subtask
      const parent = taskMap.get(task.parent)!;
      parent.children.push(hierarchicalTask);
      hierarchicalTask.depth = parent.depth + 1;
    } else {
      // This is a root task
      rootTasks.push(hierarchicalTask);
    }
  });
  
  // Sort by position within each level
  const sortTasksByPosition = (tasks: HierarchicalTask[]) => {
    tasks.sort((a, b) => a.position.localeCompare(b.position));
    tasks.forEach(task => {
      if (task.children.length > 0) {
        sortTasksByPosition(task.children);
      }
    });
  };
  
  sortTasksByPosition(rootTasks);
  return rootTasks;
};

interface GoogleStore {
  // Account management
  accounts: GoogleAccount[];
  activeAccount: GoogleAccount | null;
  
  // Tasks data
  taskLists: GoogleTaskList[];
  kanbanColumns: KanbanColumn[];
  taskIdToListId: Map<string, string>; // NEW: Fast lookup map
  isLoadingTasks: boolean;
  lastUpdateTime: number; // Track last update to prevent overwrites
  
  // Sync state management
  taskSyncState: Map<string, {
    status: 'synced' | 'pending' | 'failed';
    originalListId?: string;
    targetListId?: string;
    lastError?: string;
    retryCount: number;
    operationId?: string;
    originalTask?: HierarchicalTask;
  }>;
  
  // Calendar data
  calendarEvents: GoogleCalendarEvent[];
  isLoadingCalendar: boolean;
  
  // UI state
  draggedTask: HierarchicalTask | null;
  
  // Actions
  setActiveAccount: (account: GoogleAccount | null) => void;
  addAccount: (account: GoogleAccount) => void;
  removeAccount: (accountId: string) => void;
  
  // Task actions
  fetchTaskLists: () => Promise<void>;
  fetchTasksForList: (taskListId: string) => Promise<void>;
  fetchAllTasks: () => Promise<void>;
  createTask: (taskListId: string, taskData: TaskCreateData) => Promise<GoogleTask | null>;
  updateTask: (taskListId: string, taskId: string, updates: Partial<TaskCreateData>) => Promise<GoogleTask>;
  moveTask: (taskId: string, fromListId: string, toListId: string, position?: string) => Promise<GoogleTask>;
  toggleTaskCompletion: (taskListId: string, taskId: string, completed: boolean) => Promise<void>;
  deleteTask: (taskListId: string, taskId: string) => Promise<void>;
  createSubtask: (taskListId: string, parentTaskId: string, taskData: TaskCreateData) => Promise<void>;
  
  // OPTIMISTIC UPDATE METHODS - Instant UI updates
  optimisticMoveTask: (taskId: string, fromListId: string, toListId: string) => void;
  optimisticUpdateTask: (taskListId: string, taskId: string, updates: Partial<any>) => void;
  optimisticToggleTaskCompletion: (taskListId: string, taskId: string, completed: boolean) => void;
  optimisticReorderTask: (taskListId: string, activeId: string, overId: string) => void;
  
  // Task list management
  updateTaskList: (taskListId: string, title: string) => Promise<void>;
  deleteTaskList: (taskListId: string) => Promise<void>;
  archiveTaskList: (taskListId: string) => Promise<void>;
  createTaskList: (title: string) => Promise<void>;
  
  // Calendar actions
  fetchCalendarEvents: (timeMin?: string, timeMax?: string) => Promise<void>;
  createCalendarEvent: (eventData: any) => Promise<void>;
  
  // Drag and drop
  setDraggedTask: (task: HierarchicalTask | null) => void;
  
  // Utility
  clearData: () => void;
}

export const useGoogleStore = create<GoogleStore>()(
  devtools(
    (set, get) => ({
      // Initial state
      accounts: isDevMode ? [getMockAccount()] : [],
      activeAccount: isDevMode ? getMockAccount() : null,
      taskLists: [],
      kanbanColumns: [],
      taskIdToListId: new Map(), // NEW: Initialize map
      taskSyncState: new Map(), // Initialize sync state tracking
      isLoadingTasks: false,
      lastUpdateTime: 0,
      calendarEvents: [],
      isLoadingCalendar: false,
      draggedTask: null,

      // Account management
      setActiveAccount: (account) => {
        set(produce((draft) => {
          draft.activeAccount = account;
        }));
        if (account) {
          get().fetchTaskLists();
          get().fetchCalendarEvents();
        }
      },

      addAccount: (account) => {
        set(produce((draft) => {
          draft.accounts.push(account);
          if (!draft.activeAccount) {
            draft.activeAccount = account;
          }
        }));
      },

      removeAccount: (accountId) => {
        set(produce((draft) => {
          draft.accounts = draft.accounts.filter(acc => acc.id !== accountId);
          if (draft.activeAccount?.id === accountId) {
            draft.activeAccount = null;
          }
        }));
      },

      // Task actions
      fetchTaskLists: async () => {
        const { activeAccount } = get();
        if (!activeAccount) return;

        set(produce(draft => { draft.isLoadingTasks = true; }));
        try {
          const response = await googleTasksService.getTaskLists(activeAccount);
          if (response.success && response.data) {
            set(produce(draft => {
              draft.taskLists = response.data;
              draft.kanbanColumns = response.data.map(taskList => ({
                taskList,
                tasks: [],
                isLoading: false
              }));
            }));
          }
        } catch (error) {
          console.error('Error fetching task lists:', error);
        } finally {
          set(produce(draft => { draft.isLoadingTasks = false; }));
        }
      },

      fetchTasksForList: async (taskListId: string) => {
        const { activeAccount } = get();
        if (!activeAccount) return;

        set(produce(draft => {
          const column = draft.kanbanColumns.find(col => col.taskList.id === taskListId);
          if (column) column.isLoading = true;
        }));

        try {
          const response = await googleTasksService.getTasks(activeAccount, taskListId);
          if (response.success && response.data) {
            const tasks = response.data.items || [];
            const hierarchicalTasks = organizeTasks(tasks);
            
            set(produce(draft => {
              const column = draft.kanbanColumns.find(col => col.taskList.id === taskListId);
              if (column) {
                column.tasks = hierarchicalTasks;
                column.isLoading = false;
              }
              tasks.forEach(task => draft.taskIdToListId.set(task.id, taskListId));
            }));
          }
        } catch (error) {
          console.error(`Error fetching tasks for list ${taskListId}:`, error);
          set(produce(draft => {
            const column = draft.kanbanColumns.find(col => col.taskList.id === taskListId);
            if (column) column.isLoading = false;
          }));
        }
      },

      fetchAllTasks: async () => {
        const { activeAccount, taskLists, lastUpdateTime } = get();
        if (!activeAccount) return;

        // Skip fetch if a recent update occurred within last 2 seconds
        const timeSinceLastUpdate = Date.now() - lastUpdateTime;
        if (timeSinceLastUpdate < 2000) {
          return;
        }

        set(produce(draft => { draft.isLoadingTasks = true; }));
        try {
            const allTasksData = await googleTasksService.getAllTasks(activeAccount, taskLists);
            
            set(produce(draft => {
                const newTaskIdToListId = new Map<string, string>();
                draft.kanbanColumns.forEach(col => {
                    const tasksForList = allTasksData[col.taskList.id] || [];
                    col.tasks = organizeTasks(tasksForList);
                    tasksForList.forEach(task => newTaskIdToListId.set(task.id, col.taskList.id));
                });
                draft.taskIdToListId = newTaskIdToListId;
                draft.isLoadingTasks = false;
            }));

        } catch (error) {
          console.error('Error fetching all tasks:', error);
          set(produce(draft => { draft.isLoadingTasks = false; }));
        }
      },
      
      createTask: async (taskListId: string, taskData: TaskCreateData): Promise<GoogleTask | null> => {
        const { activeAccount } = get();
        if (!activeAccount) throw new Error("No active account");

        try {
            const response = await googleTasksService.createTask(activeAccount, taskListId, taskData);
            
            if (response === null) {
                return null;
            }

            if (response.success && response.data) {
              const newTask = response.data;
              set(produce(draft => {
                const column = draft.kanbanColumns.find(c => c.taskList.id === taskListId);
                if (column) {
                  const enhancedTask = enhanceTask(newTask);
                  column.tasks.push(enhancedTask);
                  draft.taskIdToListId.set(newTask.id, taskListId);
                }
              }));
              return newTask;
            } else if (response.success && response.data === null) {
              return null;
            } else {
              const errorMessage = typeof response.error === 'object' && response.error?.message 
                ? response.error.message 
                : response.error || 'Failed to create task';
              throw new Error(errorMessage);
            }
        } catch (error: any) {
            console.error("Failed to create task:", error);
            // Handle GoogleApiError objects properly
            const errorMessage = typeof error === 'object' && error?.message 
              ? error.message 
              : String(error) || 'An unknown error occurred during task creation';
            throw new Error(errorMessage);
        }
      },

      updateTask: async (taskListId: string, taskId: string, updates: Partial<TaskCreateData>) => {
        const { activeAccount, taskSyncState, kanbanColumns } = get();
        if (!activeAccount) throw new Error("No active account");
        
        // Handle edge cases gracefully
        if (!taskId || taskId === null || taskId === undefined || taskId === '') {
          console.warn(`[Store] Invalid task ID: ${taskId}`);
          return;
        }
        
        // INSTRUMENTATION: Log initial state
        console.log('[UPDATE TASK] Initial State:', JSON.stringify({
          timestamp: Date.now(),
          taskId,
          taskListId,
          updates,
          columns: kanbanColumns.map(c => ({ 
            id: c.taskList.id, 
            taskCount: c.tasks.length,
            tasks: c.tasks.map(t => ({ id: t.id, title: t.title })) 
          })),
          map: Array.from(get().taskIdToListId.entries()),
          targetTask: kanbanColumns.find(c => c.taskList.id === taskListId)?.tasks.find(t => t.id === taskId)
        }, null, 2));
        
        // Check if optimistic update has already been applied by looking at task state
        let taskAlreadyUpdated = false;
        let currentTask: HierarchicalTask | null = null;
        
        for (const column of kanbanColumns) {
          const findTask = (tasks: HierarchicalTask[]): HierarchicalTask | null => {
            for (const task of tasks) {
              if (task.id === taskId) return task;
              if (task.children) {
                const found = findTask(task.children);
                if (found) return found;
              }
            }
            return null;
          };
          
          currentTask = findTask(column.tasks);
          if (currentTask) {
            // Check if the current task already has the optimistic updates applied
            taskAlreadyUpdated = Object.keys(updates).some(key => 
              currentTask[key] === updates[key]
            );
            break;
          }
        }
        
        console.log('[UPDATE TASK] Optimistic Check:', JSON.stringify({
          taskAlreadyUpdated,
          currentTask: currentTask ? { id: currentTask.id, title: currentTask.title } : null
        }, null, 2));
        
        // STEP 1: Snapshot current state before any changes
        const previousSnapshot = {
          kanbanColumns: JSON.parse(JSON.stringify(kanbanColumns)),
          taskIdToListId: new Map(get().taskIdToListId),
          taskSyncState: new Map(get().taskSyncState)
        };
        
        console.log('[UPDATE TASK] Snapshot Created:', JSON.stringify({
          timestamp: Date.now(),
          snapshotColumns: previousSnapshot.kanbanColumns.map(c => ({ 
            id: c.taskList.id, 
            taskCount: c.tasks.length,
            tasks: c.tasks.map(t => ({ id: t.id, title: t.title })) 
          })),
          snapshotMap: Array.from(previousSnapshot.taskIdToListId.entries())
        }, null, 2));
        
        // STEP 2: Apply optimistic update ONLY if not already applied
        if (!taskAlreadyUpdated) {
          console.log('[UPDATE TASK] Applying optimistic update...');
          set(produce(draft => {
            for (const column of draft.kanbanColumns) {
              const updateInTasks = (tasks: HierarchicalTask[]): boolean => {
                for (let i = 0; i < tasks.length; i++) {
                  if (tasks[i].id === taskId) {
                    tasks[i] = { ...tasks[i], ...updates };
                    return true;
                  }
                  if (tasks[i].children && updateInTasks(tasks[i].children)) {
                    return true;
                  }
                }
                return false;
              };
              
              if (updateInTasks(column.tasks)) {
                break;
              }
            }
          }));
          
          console.log('[UPDATE TASK] After optimistic update:', JSON.stringify({
            timestamp: Date.now(),
            columns: get().kanbanColumns.map(c => ({ 
              id: c.taskList.id, 
              taskCount: c.tasks.length,
              tasks: c.tasks.map(t => ({ id: t.id, title: t.title })) 
            })),
            map: Array.from(get().taskIdToListId.entries()),
            targetTask: get().kanbanColumns.find(c => c.taskList.id === taskListId)?.tasks.find(t => t.id === taskId)
          }, null, 2));
        } else {
          console.log('[UPDATE TASK] Skipping optimistic update (already applied)');
        }
        
        // STEP 3: Attempt API call outside of any produce calls
        const syncState = taskSyncState.get(taskId);
        const isUnsynced = syncState && syncState.status !== 'synced';
        
        // Determine which lists to try
        const listsToTry: string[] = [];
        
        if (isUnsynced && syncState) {
            if (syncState.targetListId) listsToTry.push(syncState.targetListId);
            if (syncState.originalListId && syncState.originalListId !== syncState.targetListId) {
                listsToTry.push(syncState.originalListId);
            }
        } else {
            listsToTry.push(taskListId);
        }
        
        // Add all other lists as fallbacks
        for (const column of kanbanColumns) {
            if (!listsToTry.includes(column.taskList.id)) {
                listsToTry.push(column.taskList.id);
            }
        }
        
        const attemptUpdate = async (listIds: string[], currentIndex = 0): Promise<any> => {
            if (currentIndex >= listIds.length) {
                throw new Error('Task not found in any list');
            }
            
            const listId = listIds[currentIndex];
            try {
                const response = await googleTasksService.updateTask(activeAccount, listId, taskId, updates);
                if (response.success && response.data) {
                    return response.data;
                }
                const errorMessage = typeof response.error === 'object' && response.error?.message 
                  ? response.error.message 
                  : response.error || 'Failed to update task';
                throw new Error(errorMessage);
            } catch (error: any) {
                if (error.message?.includes('not found') && currentIndex < listIds.length - 1) {
                    console.log(`[Store] Task not found in ${listId}, trying next list...`);
                    return attemptUpdate(listIds, currentIndex + 1);
                }
                throw error;
            }
        };
        
        try {
            const updatedTask = await attemptUpdate(listsToTry);
            const enhancedTask = enhanceTask(updatedTask);
            
            // STEP 4: Update store with successful API response (separate produce call)
            set(produce(draft => {
                if (syncState) {
                    draft.taskSyncState.set(taskId, {
                        ...syncState,
                        status: 'synced'
                    });
                }
                
                let updated = false;
                for (const column of draft.kanbanColumns) {
                    const updateInTasks = (tasks: HierarchicalTask[]): boolean => {
                        for (let i = 0; i < tasks.length; i++) {
                            if (tasks[i].id === taskId) {
                                const existingTask = tasks[i];
                                tasks[i] = { 
                                    ...existingTask,
                                    ...enhancedTask,
                                    labels: enhancedTask.labels || existingTask.labels,
                                    priority: enhancedTask.priority || existingTask.priority,
                                    subtasks: enhancedTask.subtasks || existingTask.subtasks,
                                    recurring: enhancedTask.recurring || existingTask.recurring,
                                };
                                return true;
                            }
                            if (tasks[i].children && updateInTasks(tasks[i].children)) {
                                return true;
                            }
                        }
                        return false;
                    };
                    
                    if (updateInTasks(column.tasks)) {
                        updated = true;
                        break;
                    }
                }
                
                if (!updated) {
                    console.error(`[Store] Failed to find task ${taskId} in any column`);
                }
                
                draft.lastUpdateTime = Date.now();
            }));
            
            return updatedTask;
        } catch (error) {
            console.error(`[Store] Failed to update task after all attempts:`, error);
            
            // INSTRUMENTATION: Log state immediately on catch
            console.log('[UPDATE TASK] Immediate catch state:', JSON.stringify({
              timestamp: Date.now(),
              error: error instanceof Error ? error.message : String(error),
              columns: get().kanbanColumns.map(c => ({ 
                id: c.taskList.id, 
                taskCount: c.tasks.length,
                tasks: c.tasks.map(t => ({ id: t.id, title: t.title })) 
              })),
              map: Array.from(get().taskIdToListId.entries()),
              targetTask: get().kanbanColumns.find(c => c.taskList.id === taskListId)?.tasks.find(t => t.id === taskId)
            }, null, 2));
            
            // STEP 5: CRITICAL - Rollback to snapshot on API failure (separate produce call)
            // This preserves the optimistic update by doing nothing (optimistic update already applied)
            // The optimistic state remains as-is, which is the desired behavior
            
            // Only log the error, do NOT modify store state here
            // The optimistic update should remain visible to the user
            
            console.log('[UPDATE TASK] Preserving optimistic update on API failure');
            
            const errorMessage = typeof error === 'object' && error?.message 
              ? error.message 
              : String(error) || 'An unknown error occurred during task update';
            throw new Error(errorMessage);
        }
      },

      deleteTask: async (taskListId: string, taskId: string) => {
        const { activeAccount } = get();
        if (!activeAccount) throw new Error("No active account");

        try {
          const response = await googleTasksService.deleteTask(activeAccount, taskListId, taskId);
          
          if (response.success) {
            // Clean up metadata
            const metadataStore = useTaskMetadataStore.getState();
            metadataStore.deleteTaskMetadata(taskId);
            
            set(produce(draft => {
              const column = draft.kanbanColumns.find(c => c.taskList.id === taskListId);
              if (column) {
                const removeTask = (tasks: HierarchicalTask[]): HierarchicalTask[] => {
                    return tasks.filter(task => {
                        if (task.id === taskId) return false;
                        if (task.children) {
                            task.children = removeTask(task.children);
                        }
                        return true;
                    });
                };
                column.tasks = removeTask(column.tasks);
                draft.taskIdToListId.delete(taskId);
              }
            }));
          } else {
            // Handle GoogleApiError objects properly
            const errorMessage = typeof response.error === 'object' && response.error?.message 
              ? response.error.message 
              : response.error || 'Failed to delete task';
            throw new Error(errorMessage);
          }
        } catch (error: any) {
            console.error("Failed to delete task:", error);
            // Handle GoogleApiError objects properly
            const errorMessage = typeof error === 'object' && error?.message 
              ? error.message 
              : String(error) || 'An unknown error occurred during task deletion';
            throw new Error(errorMessage);
        }
      },

      moveTask: async (taskId: string, fromListId: string, toListId: string, position?: string) => {
        const { activeAccount } = get();
        if (!activeAccount) throw new Error("No active account");
        
        // STEP 1: Snapshot current state before optimistic move
        const previousSnapshot = {
          kanbanColumns: JSON.parse(JSON.stringify(get().kanbanColumns)),
          taskIdToListId: new Map(get().taskIdToListId),
          taskSyncState: new Map(get().taskSyncState)
        };
        
        // Find the task in its current location (it might have been moved optimistically)
        let taskToMove: HierarchicalTask | null = null;
        let currentListId: string | null = null;
        const currentState = get();
        
        // Search for the task in all columns to find its current location
        for (const column of currentState.kanbanColumns) {
          const findTask = (tasks: HierarchicalTask[]): HierarchicalTask | null => {
            for (const task of tasks) {
              if (task.id === taskId) return task;
              if (task.children) {
                const found = findTask(task.children);
                if (found) return found;
              }
            }
            return null;
          };
          
          const found = findTask(column.tasks);
          if (found) {
            taskToMove = found;
            currentListId = column.taskList.id;
            break;
          }
        }
        
        if (!taskToMove) {
          throw new Error(`Task ${taskId} not found in any list`);
        }
        
        // If the task is already in the target list, don't apply optimistic move again
        const needsOptimisticMove = currentListId !== toListId;
        
        // STEP 2: Apply optimistic move in isolated produce call (no throwing)
        if (needsOptimisticMove) {
          set(produce(draft => {
            const fromColumn = draft.kanbanColumns.find(c => c.taskList.id === currentListId);
            const toColumn = draft.kanbanColumns.find(c => c.taskList.id === toListId);

            if (fromColumn && toColumn) {
                let taskToMove: HierarchicalTask | null = null;
                
                // Remove task from current column
                const findAndRemove = (tasks: HierarchicalTask[], id: string): HierarchicalTask[] => {
                    return tasks.filter(task => {
                        if (task.id === id) {
                            taskToMove = task;
                            return false;
                        }
                        if (task.children) {
                            task.children = findAndRemove(task.children, id);
                        }
                        return true;
                    });
                };
                
                fromColumn.tasks = findAndRemove(fromColumn.tasks, taskId);
                
                if (taskToMove) {
                    // Mark as pending sync
                    const operationId = `op-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    draft.taskSyncState.set(taskId, {
                        status: 'pending',
                        originalListId: currentListId,
                        targetListId: toListId,
                        retryCount: 0,
                        operationId,
                        originalTask: taskToMove
                    });
                    
                    // Add to target column
                    toColumn.tasks.push(taskToMove);
                    draft.taskIdToListId.set(taskId, toListId);
                }
            }
          }));
        }
        
        // STEP 3: Attempt API call outside of any produce calls
        try {
            const response = await googleTasksService.moveTask(activeAccount, taskId, fromListId, toListId, { previous: position });
            
            if (response.success && response.data) {
              // STEP 4: Update store with successful API response (separate produce call)
              set(produce(draft => {
                  // Mark as synced after successful move
                  const syncState = draft.taskSyncState.get(taskId);
                  if (syncState) {
                      draft.taskSyncState.set(taskId, {
                          ...syncState,
                          status: 'synced'
                      });
                  }
                  
                  // Update task with response data but preserve optimistic updates
                  const toColumn = draft.kanbanColumns.find(c => c.taskList.id === toListId);
                  if (toColumn) {
                      const updateInTasks = (tasks: HierarchicalTask[]): boolean => {
                          for (let i = 0; i < tasks.length; i++) {
                              if (tasks[i].id === taskId) {
                                  const existingTask = tasks[i];
                                  tasks[i] = { ...existingTask, ...enhanceTask(response.data) };
                                  return true;
                              }
                              if (tasks[i].children && updateInTasks(tasks[i].children)) {
                                  return true;
                              }
                          }
                          return false;
                      };
                      updateInTasks(toColumn.tasks);
                  }
              }));
              return response.data;
            } else {
              const errorMessage = typeof response.error === 'object' && response.error?.message 
                ? response.error.message 
                : response.error || 'Failed to move task';
              throw new Error(errorMessage);
            }
        } catch (error: any) {
            console.error(`[Store] Failed to move task:`, error);
            
            // STEP 5: CRITICAL - Preserve optimistic move on API failure
            // The optimistic move was already applied above, so we DO NOT modify the store here
            // The task should remain in the target list with its optimistic changes
            
            // Update sync state to reflect failure (separate produce call)
            set(produce(draft => {
                const syncState = draft.taskSyncState.get(taskId);
                if (syncState) {
                    draft.taskSyncState.set(taskId, {
                        ...syncState,
                        status: 'failed',
                        lastError: error instanceof Error ? error.message : String(error),
                        retryCount: (syncState.retryCount || 0) + 1
                    });
                }
            }));
            
            const errorMessage = typeof error === 'object' && error?.message 
              ? error.message 
              : String(error) || 'An unknown error occurred during task move';
            throw new Error(errorMessage);
        }
      },
      
      toggleTaskCompletion: async (taskListId: string, taskId: string, completed: boolean) => {
        get().optimisticToggleTaskCompletion(taskListId, taskId, completed);
        const { activeAccount } = get();
        if (!activeAccount) throw new Error("No active account");
        
        try {
            const response = await googleTasksService.updateTask(activeAccount, taskListId, taskId, {
                status: completed ? 'completed' : 'needsAction',
                completed: completed ? new Date().toISOString() : undefined
            });

            if (response.success && response.data) {
                // Update store to reflect the completion status change
                set(produce(draft => {
                    const column = draft.kanbanColumns.find(c => c.taskList.id === taskListId);
                    if (column) {
                        const findAndToggle = (tasks: HierarchicalTask[]): boolean => {
                            for (const task of tasks) {
                                if (task.id === taskId) {
                                    task.status = completed ? 'completed' : 'needsAction';
                                    task.completed = completed ? new Date().toISOString() : undefined;
                                    return true;
                                }
                                if (task.children && findAndToggle(task.children)) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        findAndToggle(column.tasks);
                    }
                }));
            } else {
                // Handle GoogleApiError objects properly
                const errorMessage = typeof response.error === 'object' && response.error?.message 
                  ? response.error.message 
                  : response.error || 'Failed to toggle task completion';
                throw new Error(errorMessage);
            }
        } catch (error: any) {
            console.error("Failed to toggle task completion:", error);
            // Revert optimistic update on failure
            get().optimisticToggleTaskCompletion(taskListId, taskId, !completed);
            // Handle GoogleApiError objects properly
            const errorMessage = typeof error === 'object' && error?.message 
              ? error.message 
              : String(error) || 'An unknown error occurred during task completion toggle';
            throw new Error(errorMessage);
        }
      },

      optimisticMoveTask: (taskId: string, fromListId: string, toListId: string) => {
        set(produce(draft => {
            const fromColumn = draft.kanbanColumns.find(c => c.taskList.id === fromListId);
            const toColumn = draft.kanbanColumns.find(c => c.taskList.id === toListId);

            // FIXED: Avoid explicit return - restructure with if block instead
            if (fromColumn && toColumn) {
                let taskToMove: HierarchicalTask | null = null;
                const findAndRemove = (tasks: HierarchicalTask[], id: string): HierarchicalTask[] => {
                    return tasks.filter(task => {
                        if (task.id === id) {
                            taskToMove = task;
                            return false;
                        }
                        if (task.children) {
                            task.children = findAndRemove(task.children, id);
                        }
                        return true;
                    });
                };
                
                fromColumn.tasks = findAndRemove(fromColumn.tasks, taskId);
                
                if (taskToMove) {
                    // Mark as pending sync with operation ID
                    const operationId = `op-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    draft.taskSyncState.set(taskId, {
                        status: 'pending',
                        originalListId: fromListId,
                        targetListId: toListId,
                        retryCount: 0,
                        operationId,
                        originalTask: taskToMove
                    });
                    
                    toColumn.tasks.push(taskToMove);
                    draft.taskIdToListId.set(taskId, toListId);
                }
            }
        }));
      },

      optimisticReorderTask: (taskListId: string, activeId: string, overId: string) => {
        set(produce(draft => {
            const column = draft.kanbanColumns.find(c => c.taskList.id === taskListId);
            
            // FIXED: Avoid explicit return - restructure with if block instead
            if (column) {
                let activeTask: HierarchicalTask | null = null;
                
                const findAndRemove = (tasks: HierarchicalTask[]): HierarchicalTask[] => {
                    return tasks.filter(task => {
                        if (task.id === activeId) {
                            activeTask = task;
                            return false;
                        }
                        if (task.children) {
                            task.children = findAndRemove(task.children);
                        }
                        return true;
                    });
                };

                const findAndInsert = (tasks: HierarchicalTask[]): boolean => {
                    for(let i = 0; i < tasks.length; i++) {
                        if (tasks[i].id === overId) {
                            tasks.splice(i, 0, activeTask!);
                            return true;
                        }
                        if (tasks[i].children && findAndInsert(tasks[i].children)) {
                            return true;
                        }
                    }
                    return false;
                };

                column.tasks = findAndRemove(column.tasks);
                if (activeTask) {
                    if(!findAndInsert(column.tasks)) {
                        // if overId was not found (e.g. dragging over column), add to end
                        column.tasks.push(activeTask);
                    }
                }
            }
        }));
      },

      optimisticUpdateTask: (taskListId: string, taskId: string, updates: Partial<any>) => {
        set(produce(draft => {
          // If we're clearing unsynced flag, update sync state
          if ('unsynced' in updates && !updates.unsynced) {
            const syncState = draft.taskSyncState.get(taskId);
            if (syncState) {
              draft.taskSyncState.set(taskId, {
                ...syncState,
                status: 'synced'
              });
            }
          }
          
          // FIXED: Search in the specified taskListId first, then fall back to other columns
          const findAndUpdate = (tasks: HierarchicalTask[]): boolean => {
            for (let i = 0; i < tasks.length; i++) {
              if (tasks[i].id === taskId) {
                // Use spread pattern for Immer compatibility
                tasks[i] = { ...tasks[i], ...updates };
                return true;
              }
              if (tasks[i].children && findAndUpdate(tasks[i].children)) {
                return true;
              }
            }
            return false;
          };

          // First, try to find and update in the specified column
          const targetColumn = draft.kanbanColumns.find(c => c.taskList.id === taskListId);
          if (targetColumn && findAndUpdate(targetColumn.tasks)) {
            // Update taskIdToListId map to ensure consistency
            draft.taskIdToListId.set(taskId, taskListId);
            return; // Found and updated, exit early
          }
          
          // If not found in target column, search other columns as fallback
          for (const column of draft.kanbanColumns) {
            if (column.taskList.id === taskListId) continue; // Skip already checked column
            
            if (findAndUpdate(column.tasks)) {
              // Update taskIdToListId map to reflect actual location
              draft.taskIdToListId.set(taskId, column.taskList.id);
              break;
            }
          }
        }));
      },
      
      optimisticToggleTaskCompletion: (taskListId: string, taskId: string, completed: boolean) => {
          set(produce(draft => {
              const column = draft.kanbanColumns.find(c => c.taskList.id === taskListId);
              
              // FIXED: Avoid explicit return - restructure with if block instead
              if (column) {
                  const findAndToggle = (tasks: HierarchicalTask[]) => {
                      for (const task of tasks) {
                          if (task.id === taskId) {
                              task.status = completed ? 'completed' : 'needsAction';
                              task.completed = completed ? new Date().toISOString() : undefined;
                              return true;
                          }
                          if (task.children && findAndToggle(task.children)) {
                              return true;
                          }
                      }
                      return false;
                  };

                  findAndToggle(column.tasks);
              }
          }));
      },
      
      createSubtask: async (taskListId: string, parentTaskId: string, taskData: TaskCreateData) => {
          const { activeAccount } = get();
          if (!activeAccount) return;

          try {
            console.log('Creating subtask with data:', taskData, 'for parent:', parentTaskId);
            
            // Create subtask with parent reference
            const subtaskData: TaskCreateData = {
              ...taskData,
              parent: parentTaskId
            };
            
            await get().createTask(taskListId, subtaskData);
          } catch (error) {
            console.error('Error creating subtask:', error);
          }
      },

      // Task list management
      updateTaskList: async (taskListId: string, title: string) => {
        const { activeAccount } = get();
        if (!activeAccount) return;

        try {
          const response = await googleTasksService.updateTaskList(activeAccount, taskListId, title);
          if (response.success && response.data) {
            console.log('Task list updated successfully:', response.data);
            // Refresh task lists to get updated data
            await get().fetchTaskLists();
          }
        } catch (error) {
          console.error('Error updating task list:', error);
          throw error;
        }
      },

      deleteTaskList: async (taskListId: string) => {
        const { activeAccount } = get();
        if (!activeAccount) return;

        try {
          const response = await googleTasksService.deleteTaskList(activeAccount, taskListId);
          if (response.success) {
            console.log('Task list deleted successfully');
            // Refresh task lists to get updated data
            await get().fetchTaskLists();
          }
        } catch (error) {
          console.error('Error deleting task list:', error);
          throw error;
        }
      },

      archiveTaskList: async (taskListId: string) => {
        const { activeAccount } = get();
        if (!activeAccount) return;

        try {
          const response = await googleTasksService.archiveTaskList(activeAccount, taskListId);
          if (response.success) {
            console.log('Task list archived successfully');
            // Refresh task lists to get updated data
            await get().fetchTaskLists();
          }
        } catch (error) {
          console.error('Error archiving task list:', error);
          throw error;
        }
      },

      createTaskList: async (title: string) => {
        const { activeAccount } = get();
        if (!activeAccount) return;

        try {
          const response = await googleTasksService.createTaskList(activeAccount, title);
          if (response.success && response.data) {
            console.log('Task list created successfully:', response.data);
            // Refresh task lists to get updated data
            await get().fetchTaskLists();
          }
        } catch (error) {
          console.error('Error creating task list:', error);
          throw error;
        }
      },

      // Calendar actions
      fetchCalendarEvents: async (timeMin?: string, timeMax?: string) => {
        const { activeAccount } = get();
        if (!activeAccount) return;

        set(produce(draft => { draft.isLoadingCalendar = true; }));
        try {
          const response = await googleCalendarService.getEvents(activeAccount, 'primary', timeMin, timeMax);
          if (response.success && response.data) {
            set(produce(draft => { draft.calendarEvents = response.data.items || []; }));
          }
        } catch (error) {
          console.error('Error fetching calendar events:', error);
        } finally {
          set(produce(draft => { draft.isLoadingCalendar = false; }));
        }
      },

      createCalendarEvent: async (eventData: any) => {
        const { activeAccount } = get();
        if (!activeAccount) return;

        try {
          const response = await googleCalendarService.createEvent(activeAccount, eventData);
          if (response.success && response.data) {
            set((state) => ({
              calendarEvents: [...state.calendarEvents, response.data!]
            }));
          }
        } catch (error) {
          console.error('Error creating calendar event:', error);
        }
      },

      // Drag and drop
      setDraggedTask: (task) => set(produce(draft => { draft.draggedTask = task; })),

      // Utility
      clearData: () => set(produce(draft => {
        draft.accounts = [];
        draft.activeAccount = null;
        draft.taskLists = [];
        draft.kanbanColumns = [];
        draft.taskIdToListId = new Map();
        draft.calendarEvents = [];
        draft.draggedTask = null;
        draft.lastUpdateTime = 0;
      })),
    }),
    {
      name: 'google-store',
    }
  )
); 

END OF FILE: src/stores/googleStore.ts


====================================================================================================
FILE: src/stores/taskMetadataStore.ts
DESCRIPTION: Task metadata store for additional task properties
====================================================================================================

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export interface TaskMetadata {
  taskId: string;
  labels: string[];
  priority: 'low' | 'normal' | 'high';
  subtasks: Array<{
    id: string;
    title: string;
    completed: boolean;
    due: string;
  }>;
  recurring: {
    enabled: boolean;
    frequency: 'daily' | 'weekly' | 'monthly';
    interval: number;
    endDate: string;
  };
  lastUpdated: number;
}

interface TaskMetadataStore {
  metadata: Map<string, TaskMetadata>;
  
  // Actions
  setTaskMetadata: (taskId: string, metadata: Partial<TaskMetadata>) => void;
  getTaskMetadata: (taskId: string) => TaskMetadata | null;
  deleteTaskMetadata: (taskId: string) => void;
  clearAllMetadata: () => void;
  
  // Bulk operations
  importFromNotesField: (taskId: string, notes: string) => void;
  exportToNotesField: (taskId: string) => string;
}

export const useTaskMetadataStore = create<TaskMetadataStore>()(
  persist(
    (set, get) => ({
      metadata: new Map(),
      
      setTaskMetadata: (taskId: string, updates: Partial<TaskMetadata>) => {
        set(state => {
          const newMetadata = new Map(state.metadata);
          const existing = newMetadata.get(taskId);
          
          const updatedMetadata: TaskMetadata = {
            taskId,
            labels: updates.labels || existing?.labels || [],
            priority: updates.priority || existing?.priority || 'normal',
            subtasks: updates.subtasks || existing?.subtasks || [],
            recurring: updates.recurring || existing?.recurring || {
              enabled: false,
              frequency: 'weekly',
              interval: 1,
              endDate: ''
            },
            lastUpdated: Date.now()
          };
          
          newMetadata.set(taskId, updatedMetadata);
          
          return { metadata: newMetadata };
        });
      },
      
      getTaskMetadata: (taskId: string) => {
        const metadata = get().metadata.get(taskId);
        return metadata || null;
      },
      
      deleteTaskMetadata: (taskId: string) => {
        set(state => {
          const newMetadata = new Map(state.metadata);
          newMetadata.delete(taskId);
          return { metadata: newMetadata };
        });
      },
      
      clearAllMetadata: () => {
        set({ metadata: new Map() });
      },
      
      importFromNotesField: (taskId: string, notes: string) => {
        try {
          const match = notes.match(/\[LibreOllama:(.+)\]/);
          if (match) {
            const data = JSON.parse(match[1]);
            get().setTaskMetadata(taskId, {
              labels: data.labels || [],
              priority: data.priority || 'normal',
              subtasks: data.subtasks || [],
              recurring: data.recurring || {
                enabled: false,
                frequency: 'weekly',
                interval: 1,
                endDate: ''
              }
            });
          }
        } catch (error) {
          console.error(`Failed to import metadata for task ${taskId}:`, error);
        }
      },
      
      exportToNotesField: (taskId: string) => {
        const metadata = get().getTaskMetadata(taskId);
        if (!metadata) return '';
        
        const exportData = {
          labels: metadata.labels,
          priority: metadata.priority,
          subtasks: metadata.subtasks,
          recurring: metadata.recurring
        };
        
        return `[LibreOllama:${JSON.stringify(exportData)}]`;
      }
    }),
    {
      name: 'task-metadata-store',
      // Custom storage for Map serialization with safety checks
      storage: {
        getItem: (name) => {
          // Check if localStorage is available
          if (typeof localStorage === 'undefined') {
            console.warn('localStorage not available, returning null');
            return null;
          }
          
          try {
            const str = localStorage.getItem(name);
            if (!str) return null;
            const data = JSON.parse(str);
            return {
              ...data,
              state: {
                ...data.state,
                metadata: new Map(data.state.metadata || [])
              }
            };
          } catch (error) {
            console.error('Error reading from localStorage:', error);
            return null;
          }
        },
        setItem: (name, value) => {
          // Check if localStorage is available
          if (typeof localStorage === 'undefined') {
            console.warn('localStorage not available, skipping save');
            return;
          }
          
          try {
            const serialized = {
              ...value,
              state: {
                ...value.state,
                metadata: Array.from(value.state.metadata.entries())
              }
            };
            localStorage.setItem(name, JSON.stringify(serialized));
          } catch (error) {
            console.error('Error writing to localStorage:', error);
          }
        },
        removeItem: (name) => {
          // Check if localStorage is available
          if (typeof localStorage === 'undefined') {
            console.warn('localStorage not available, skipping remove');
            return;
          }
          
          try {
            localStorage.removeItem(name);
          } catch (error) {
            console.error('Error removing from localStorage:', error);
          }
        },
      },
    }
  )
); 

END OF FILE: src/stores/taskMetadataStore.ts


====================================================================================================
FILE: src/services/google/googleTasksService.ts
DESCRIPTION: Google Tasks API service
====================================================================================================

import { invoke } from '@tauri-apps/api/core';
import { mockInvoke } from './mockGoogleService';
import { 
  GoogleAccount, 
  GoogleTask, 
  GoogleTaskList, 
  TaskMoveRequest, 
  ApiResponse, 
  PaginatedResponse,
  GoogleApiError 
} from '../../types/google';

// Use mock in development mode, but allow tests to override with vi.mocked(invoke)
const isDevMode = import.meta.env.DEV;
const isTestMode = import.meta.env.MODE === 'test';

// In test mode, always use invoke (which can be mocked with vi.mocked)
// In dev mode, use mockInvoke unless invoke is explicitly mocked
const apiInvoke = isTestMode ? invoke : (isDevMode ? mockInvoke : invoke);

class GoogleTasksService {
  private async handleApiError(error: any): Promise<GoogleApiError> {
    console.error('Google Tasks API Error:', error);
    return {
      code: error.code || 500,
      message: error.message || 'An error occurred',
      status: error.status || 'INTERNAL_ERROR'
    };
  }

  async getTaskLists(account: GoogleAccount): Promise<ApiResponse<GoogleTaskList[]>> {
    try {
      const response = await apiInvoke('get_task_lists', {
        accountId: account.id,
      });
      
      return {
        success: true,
        data: response as GoogleTaskList[]
      };
    } catch (error) {
      return {
        success: false,
        error: await this.handleApiError(error)
      };
    }
  }

  async getTasks(
    account: GoogleAccount,
    taskListId: string,
    showCompleted: boolean = false,
    showDeleted: boolean = false,
    maxResults: number = 100
  ): Promise<ApiResponse<PaginatedResponse<GoogleTask>>> {
    try {
      const response = await apiInvoke('get_tasks', {
        accountId: account.id,
        taskListId,
        showCompleted,
        showDeleted,
        maxResults,
      });

      return {
        success: true,
        data: response as PaginatedResponse<GoogleTask>
      };
    } catch (error) {
      return {
        success: false,
        error: await this.handleApiError(error)
      };
    }
  }

  async createTask(
    account: GoogleAccount,
    taskListId: string,
    taskData: {
      title: string;
      notes?: string;
      due?: string;
      parent?: string;
      previous?: string;
    }
  ): Promise<ApiResponse<GoogleTask>> {
    try {
      const response = await apiInvoke('create_task', {
        accountId: account.id,
        taskListId,
        taskData,
      });

      return {
        success: true,
        data: response as GoogleTask
      };
    } catch (error) {
      return {
        success: false,
        error: await this.handleApiError(error)
      };
    }
  }

  async updateTask(
    account: GoogleAccount,
    taskListId: string,
    taskId: string,
    taskData: {
      title?: string;
      notes?: string;
      status?: 'needsAction' | 'completed';
      due?: string;
      completed?: string;
    }
  ): Promise<ApiResponse<GoogleTask>> {
    try {
      const response = await apiInvoke('update_task', {
        accountId: account.id,
        taskListId,
        taskId,
        taskData,
      });

      return {
        success: true,
        data: response as GoogleTask
      };
    } catch (error) {
      return {
        success: false,
        error: await this.handleApiError(error)
      };
    }
  }

  async moveTask(
    account: GoogleAccount,
    taskIdOrRequest: string | TaskMoveRequest,
    fromListId?: string,
    toListId?: string,
    options: { parent?: string; previous?: string } = {}
  ): Promise<ApiResponse<GoogleTask>> {
    // Support both the new unified object signature and the legacy positional signature
    let request: TaskMoveRequest;

    if (typeof taskIdOrRequest === 'string') {
      // Legacy call: moveTask(account, taskId, fromListId, toListId, { previous })
      request = {
        taskId: taskIdOrRequest,
        taskListId: toListId ?? fromListId ?? '', // target list (fall back to fromListId if only two lists)
        parent: options.parent,
        previous: options.previous,
      } as TaskMoveRequest;
    } else {
      // New unified object call
      request = taskIdOrRequest;
    }

    try {
      const response = await apiInvoke('move_task', {
        accountId: account.id,
        taskListId: request.taskListId,
        taskId: request.taskId,
        options: {
          parent: request.parent,
          previous: request.previous,
        }
      });
       
      return {
        success: true,
        data: response as GoogleTask
      };
    } catch (error) {
      return {
        success: false,
        error: await this.handleApiError(error)
      };
    }
  }

  async deleteTask(
    account: GoogleAccount,
    taskListId: string,
    taskId: string
  ): Promise<ApiResponse<void>> {
    try {
      await apiInvoke('delete_task', {
        accountId: account.id,
        taskListId,
        taskId,
      });

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: await this.handleApiError(error)
      };
    }
  }

  async markTaskCompleted(
    account: GoogleAccount,
    taskListId: string,
    taskId: string,
    completed: boolean
  ): Promise<ApiResponse<GoogleTask>> {
    return this.updateTask(account, taskListId, taskId, {
      status: completed ? 'completed' : 'needsAction',
      completed: completed ? new Date().toISOString() : undefined,
    });
  }

  // Task List Management Functions
  async updateTaskList(
    account: GoogleAccount,
    taskListId: string,
    title: string
  ): Promise<ApiResponse<GoogleTaskList>> {
    try {
      const response = await apiInvoke('update_task_list', {
        accountId: account.id,
        taskListId,
        title,
      });

      return {
        success: true,
        data: response as GoogleTaskList
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to update task list'
      };
    }
  }

  async createTaskList(
    account: GoogleAccount,
    title: string
  ): Promise<ApiResponse<GoogleTaskList>> {
    try {
      const response = await apiInvoke('create_task_list', {
        accountId: account.id,
        title,
      });

      return {
        success: true,
        data: response as GoogleTaskList
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to create task list'
      };
    }
  }

  async deleteTaskList(
    account: GoogleAccount,
    taskListId: string
  ): Promise<ApiResponse<void>> {
    try {
      await apiInvoke('delete_task_list', {
        accountId: account.id,
        taskListId,
      });

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: await this.handleApiError(error)
      };
    }
  }

  async archiveTaskList(
    account: GoogleAccount,
    taskListId: string
  ): Promise<ApiResponse<void>> {
    try {
      await apiInvoke('archive_task_list', {
        accountId: account.id,
        taskListId,
      });

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: await this.handleApiError(error)
      };
    }
  }

  async getAllTasks(
    account: GoogleAccount,
    taskLists: GoogleTaskList[]
  ): Promise<Record<string, GoogleTask[]>> {
    const results: Record<string, GoogleTask[]> = {};
    
    for (const list of taskLists) {
      try {
        const response = await this.getTasks(account, list.id);
        results[list.id] = response.success && response.data ? response.data.items ?? [] : [];
      } catch (error) {
        console.error(`Failed to fetch tasks for list ${list.id}:`, error);
        results[list.id] = [];
      }
    }
    
    return results;
  }
}

export const googleTasksService = new GoogleTasksService(); 

END OF FILE: src/services/google/googleTasksService.ts


====================================================================================================
FILE: src/services/google/mockGoogleService.ts
DESCRIPTION: Mock Google service for testing
====================================================================================================

import { GoogleAccount, GoogleTask, GoogleTaskList, GoogleCalendarEvent } from '../../types/google';

// Task operation queue to prevent race conditions
const taskOperationQueue = new Map<string, Promise<any>>();

// Mock data for testing
const mockAccount: GoogleAccount = {
  id: 'mock-account-1',
  email: 'test@example.com',
  name: 'Test User',
  picture: 'https://via.placeholder.com/150',
  accessToken: 'mock-access-token',
  refreshToken: 'mock-refresh-token',
  expiresAt: Date.now() + 3600000, // 1 hour from now
};

const mockTaskLists: GoogleTaskList[] = [
  {
    id: 'list-1',
    title: 'My Tasks',
    updated: new Date().toISOString(),
    selfLink: 'https://example.com/list-1',
    etag: 'etag-1',
  },
  {
    id: 'list-2',
    title: 'Work Projects',
    updated: new Date().toISOString(),
    selfLink: 'https://example.com/list-2',
    etag: 'etag-2',
  },
  {
    id: 'list-3',
    title: 'Personal',
    updated: new Date().toISOString(),
    selfLink: 'https://example.com/list-3',
    etag: 'etag-3',
  },
];

const mockTasks: Record<string, GoogleTask[]> = {
  'list-1': [
    {
      id: 'task-1',
      title: 'Complete project proposal',
      notes: 'Need to finish the technical specifications [LibreOllama:{"priority":"high","labels":["urgent","work"],"subtasks":[{"id":"1","title":"Research requirements","completed":true,"due":""},{"id":"2","title":"Write draft","completed":false,"due":""}]}]',
      status: 'needsAction',
      due: new Date(Date.now() + 86400000).toISOString(), // Tomorrow
      position: '1',
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/task-1',
      etag: 'etag-task-1',
    },
    {
      id: 'task-1-sub-1',
      title: 'Draft technical specifications',
      notes: 'First subtask [LibreOllama:{"priority":"normal","labels":["writing"]}]',
      status: 'needsAction',
      parent: 'task-1',
      position: '1',
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/task-1-sub-1',
      etag: 'etag-task-1-sub-1',
    },
    {
      id: 'task-1-sub-2',
      title: 'Review with team',
      notes: 'Second subtask [LibreOllama:{"priority":"normal","labels":["review","teamwork"]}]',
      status: 'completed',
      parent: 'task-1',
      position: '2',
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/task-1-sub-2',
      etag: 'etag-task-1-sub-2',
    },
    {
      id: 'task-2',
      title: 'Review team feedback',
      notes: '[LibreOllama:{"priority":"medium","labels":["feedback","review"],"recurring":{"enabled":true,"frequency":"weekly","interval":1,"endDate":""}}]',
      status: 'needsAction',
      due: new Date(Date.now() + 2 * 86400000).toISOString(), // Day after tomorrow
      position: '2',
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/task-2',
      etag: 'etag-task-2',
    },
  ],
  'list-2': [
    {
      id: 'task-3',
      title: 'Client meeting preparation',
      notes: 'Prepare slides and demo [LibreOllama:{"priority":"high","labels":["client","presentation","important"],"subtasks":[{"id":"1","title":"Create slides","completed":false,"due":""},{"id":"2","title":"Prepare demo","completed":false,"due":""}]}]',
      status: 'needsAction',
      due: new Date(Date.now() + 3 * 86400000).toISOString(),
      position: '1',
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/task-3',
      etag: 'etag-task-3',
    },
    {
      id: 'task-4',
      title: 'Update documentation',
      notes: '[LibreOllama:{"priority":"low","labels":["documentation","maintenance"]}]',
      status: 'completed',
      completed: new Date(Date.now() - 86400000).toISOString(), // Yesterday
      position: '2',
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/task-4',
      etag: 'etag-task-4',
    },
  ],
  'list-3': [
    {
      id: 'task-5',
      title: 'Grocery shopping',
      notes: '[LibreOllama:{"priority":"normal","labels":["personal","shopping"],"subtasks":[{"id":"1","title":"Milk","completed":false,"due":""},{"id":"2","title":"Bread","completed":false,"due":""},{"id":"3","title":"Eggs","completed":true,"due":""}]}]',
      status: 'needsAction',
      position: '1',
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/task-5',
      etag: 'etag-task-5',
    },
  ],
};

const mockCalendarEvents: GoogleCalendarEvent[] = [
  {
    id: 'event-1',
    summary: 'Team Stand-up',
    description: 'Daily team synchronization',
    start: {
      dateTime: new Date(Date.now() + 3600000).toISOString(), // 1 hour from now
      timeZone: 'UTC',
    },
    end: {
      dateTime: new Date(Date.now() + 7200000).toISOString(), // 2 hours from now
      timeZone: 'UTC',
    },
    status: 'confirmed',
    created: new Date().toISOString(),
    updated: new Date().toISOString(),
    etag: 'etag-event-1',
  },
  {
    id: 'event-2',
    summary: 'Project Review',
    description: 'Monthly project review meeting',
    start: {
      dateTime: new Date(Date.now() + 86400000).toISOString(), // Tomorrow
      timeZone: 'UTC',
    },
    end: {
      dateTime: new Date(Date.now() + 90000000).toISOString(), // Tomorrow + 1 hour
      timeZone: 'UTC',
    },
    status: 'confirmed',
    created: new Date().toISOString(),
    updated: new Date().toISOString(),
    etag: 'etag-event-2',
  },
];

// Queue task operations to prevent race conditions
const queueTaskOperation = async <T>(taskId: string, operationType: string, operation: () => Promise<T>): Promise<T> => {
  console.log(`[Mock] Queuing ${operationType} operation for task ${taskId}`);
  
  // Wait for any existing operation on this task to complete
  const existingOperation = taskOperationQueue.get(taskId);
  if (existingOperation) {
    console.log(`[Mock] Waiting for existing operation on task ${taskId} to complete...`);
    try {
      await existingOperation;
    } catch (error) {
      // Ignore errors from previous operations
      console.log(`[Mock] Previous operation for task ${taskId} failed, continuing...`);
    }
  }

  // Create and queue the new operation with proper error handling
  const newOperation = (async () => {
    try {
      console.log(`[Mock] Starting ${operationType} operation for task ${taskId}`);
      const result = await operation();
      console.log(`[Mock] Completed ${operationType} operation for task ${taskId}`);
      return result;
    } catch (error) {
      console.error(`[Mock] Failed ${operationType} operation for task ${taskId}:`, error);
      throw error;
    }
  })();
  
  taskOperationQueue.set(taskId, newOperation);

  try {
    const result = await newOperation;
    return result;
  } finally {
    // Clean up completed operation
    if (taskOperationQueue.get(taskId) === newOperation) {
      taskOperationQueue.delete(taskId);
      console.log(`[Mock] Cleaned up ${operationType} operation for task ${taskId}`);
    }
  }
};

// Mock the Tauri invoke function for development
export const mockInvoke = (command: string, args: any): Promise<any> => {
  console.log(`[Mock] Invoking command: ${command}`, args);
  
  return new Promise((resolve, reject) => {
    // Reduced delay for better performance (was random 200-1200ms, now 100-300ms)
    setTimeout(() => {
      try {
                 switch (command) {
           case 'get_task_lists':
             resolve(mockTaskLists);
             break;
            
          case 'get_tasks':
            const taskListId = args.taskListId;
            const tasks = mockTasks[taskListId] || [];
            resolve({ items: tasks });
            break;
            
          case 'create_task':
            const newTask: GoogleTask = {
              id: `task-${Date.now()}`,
              title: args.taskData.title,
              notes: args.taskData.notes,
              status: 'needsAction',
              due: args.taskData.due, // Already in ISO format from the frontend
              parent: args.taskData.parent, // Support parent field
              position: args.taskData.position || '1',
              updated: new Date().toISOString(),
              selfLink: `https://example.com/task-${Date.now()}`,
              etag: `etag-${Date.now()}`,
            };
            
            // Add to mock data
            if (!mockTasks[args.taskListId]) {
              mockTasks[args.taskListId] = [];
            }
            mockTasks[args.taskListId].push(newTask);
            
            resolve(newTask);
            break;
            
          case 'update_task':
            // Queue update operations to prevent race conditions
            queueTaskOperation(args.taskId, 'update', async () => {
              const listId = args.taskListId;
              const taskId = args.taskId;
              
              console.log(`[Mock] 🔄 Updating task ${taskId} in list ${listId} with data:`, args.taskData);
              
              // Search all lists for the task (in case it was moved)
              let foundTask = null;
              let foundListId = null;
              
              for (const currentListId in mockTasks) {
                const taskList = mockTasks[currentListId];
                const taskIndex = taskList.findIndex(t => t.id === taskId);
                if (taskIndex !== -1) {
                  foundTask = taskList[taskIndex];
                  foundListId = currentListId;
                  
                  const updatedTask = { 
                    ...foundTask, 
                    ...args.taskData, 
                    updated: new Date().toISOString() 
                  };
                  taskList[taskIndex] = updatedTask;
                  
                  console.log(`[Mock] ✅ Task updated successfully in list ${currentListId}`);
                  console.log(`[Mock] Updated fields:`, {
                    title: foundTask.title !== updatedTask.title ? `"${foundTask.title}" -> "${updatedTask.title}"` : 'unchanged',
                    due: foundTask.due !== updatedTask.due ? `"${foundTask.due}" -> "${updatedTask.due}"` : 'unchanged',
                    notes: foundTask.notes !== updatedTask.notes ? `"${foundTask.notes}" -> "${updatedTask.notes}"` : 'unchanged'
                  });
                  return updatedTask;
                }
              }
              
              console.log(`[Mock] ❌ Task ${taskId} not found in any list`);
              throw new Error('Task not found');
            })
            .then(resolve)
            .catch(reject);
            return; // Exit early since we're handling async
            
          case 'move_task':
            // Queue move operations to prevent race conditions
            queueTaskOperation(args.taskId, 'move', async () => {
              const targetListId = args.taskListId;
              const moveTaskId = args.taskId;
              const moveOptions = args.options || {};
              let foundTask = null;
              let sourceListId = null;
              
              // First, find the task in any list
              for (const listId in mockTasks) {
                const taskIndex = mockTasks[listId].findIndex(t => t.id === moveTaskId);
                if (taskIndex !== -1) {
                  // Create a deep copy to preserve all properties
                  foundTask = JSON.parse(JSON.stringify(mockTasks[listId][taskIndex]));
                  sourceListId = listId;
                  
                  // Remove from source list
                  mockTasks[listId].splice(taskIndex, 1);
                  break;
                }
              }
              
              if (!foundTask) {
                console.log(`[Mock] ❌ Task ${moveTaskId} not found in any list`);
                throw new Error('Task not found in any list');
              }
              
              // Update task properties from options
              if (moveOptions.parent !== undefined) {
                foundTask.parent = moveOptions.parent;
              }
              
              if (moveOptions.previous !== undefined) {
                foundTask.position = moveOptions.previous;
              }
              
              foundTask.updated = new Date().toISOString();
              
              // Add to target list
              if (!mockTasks[targetListId]) {
                mockTasks[targetListId] = [];
              }
              mockTasks[targetListId].push(foundTask);
              
              console.log(`[Mock] ✅ Moved task ${moveTaskId} from ${sourceListId} to ${targetListId}`);
              console.log(`[Mock] Task data preserved:`, foundTask);
              return foundTask;
            })
            .then(resolve)
            .catch(reject);
            return; // Exit early since we're handling async
            
          case 'delete_task':
            const delListId = args.taskListId;
            const delTaskId = args.taskId;
            const delTaskList = mockTasks[delListId];
            
            if (delTaskList) {
              const taskIndex = delTaskList.findIndex(t => t.id === delTaskId);
              if (taskIndex !== -1) {
                delTaskList.splice(taskIndex, 1);
                resolve(undefined);
              } else {
                reject(new Error('Task not found'));
              }
            } else {
              reject(new Error('Task list not found'));
            }
            break;
            
          case 'get_calendar_events':
            resolve({ items: mockCalendarEvents });
            break;
            
          case 'create_calendar_event':
            const newEvent: GoogleCalendarEvent = {
              id: `event-${Date.now()}`,
              summary: args.eventData.summary,
              description: args.eventData.description,
              start: args.eventData.start,
              end: args.eventData.end,
              status: 'confirmed',
              created: new Date().toISOString(),
              updated: new Date().toISOString(),
              etag: `etag-event-${Date.now()}`,
            };
            mockCalendarEvents.push(newEvent);
            resolve(newEvent);
            break;

          // Task List Management
          case 'update_task_list':
            const updatedList = mockTaskLists.find(list => list.id === args.taskListId);
            if (updatedList) {
              updatedList.title = args.title;
              updatedList.updated = new Date().toISOString();
            }
            resolve(updatedList);
            break;

          case 'create_task_list':
            const newTaskList: GoogleTaskList = {
              id: `tasklist-${Date.now()}`,
              title: args.title,
              updated: new Date().toISOString(),
              selfLink: `https://www.googleapis.com/tasks/v1/users/@me/lists/tasklist-${Date.now()}`,
              etag: `etag-list-${Date.now()}`,
            };
            mockTaskLists.push(newTaskList);
            resolve(newTaskList);
            break;

          case 'delete_task_list':
            const deleteListIndex = mockTaskLists.findIndex(list => list.id === args.taskListId);
            if (deleteListIndex !== -1) {
              mockTaskLists.splice(deleteListIndex, 1);
              delete mockTasks[args.taskListId]; // Also delete all tasks in the list
              resolve(undefined);
            } else {
              reject(new Error('Task list not found'));
            }
            break;

          case 'archive_task_list':
            // For mock purposes, we'll just mark it as archived (could add an archived field later)
            const archiveListIndex = mockTaskLists.findIndex(list => list.id === args.taskListId);
            if (archiveListIndex !== -1) {
              // For now, just simulate successful archiving
              console.log(`Task list ${args.taskListId} archived (mock)`);
              resolve(undefined);
            } else {
              reject(new Error('Task list not found'));
            }
            break;
            
          default:
            reject(new Error(`Unknown command: ${command}`));
        }
      } catch (error) {
        reject(error);
      }
    }, Math.random() * 200 + 100); // Reduced delay: 100-300ms for better performance
  });
};

// Export the mock account for testing
export const getMockAccount = (): GoogleAccount => mockAccount; 

END OF FILE: src/services/google/mockGoogleService.ts


====================================================================================================
FILE: src/types/google.ts
DESCRIPTION: Google API types including task definitions
====================================================================================================

// Google Calendar and Tasks API Types

export interface GoogleAccount {
  id: string;
  email: string;
  name: string;
  picture?: string;
  accessToken: string;
  refreshToken: string;
  expiresAt: number;
}

export interface GoogleCalendarEvent {
  id: string;
  summary: string;
  description?: string;
  start: {
    dateTime?: string;
    date?: string;
    timeZone?: string;
  };
  end: {
    dateTime?: string;
    date?: string;
    timeZone?: string;
  };
  location?: string;
  attendees?: Array<{
    email: string;
    displayName?: string;
    responseStatus?: 'needsAction' | 'declined' | 'tentative' | 'accepted';
  }>;
  creator?: {
    email: string;
    displayName?: string;
  };
  organizer?: {
    email: string;
    displayName?: string;
  };
  status?: 'confirmed' | 'tentative' | 'cancelled';
  visibility?: 'default' | 'public' | 'private' | 'confidential';
  created?: string;
  updated?: string;
  etag?: string;
}

export interface GoogleTaskList {
  id: string;
  title: string;
  updated: string;
  selfLink: string;
  etag: string;
}

export interface GoogleTask {
  id: string;
  title: string;
  notes?: string;
  status: 'needsAction' | 'completed';
  due?: string;
  completed?: string;
  deleted?: boolean;
  hidden?: boolean;
  parent?: string;
  position: string;
  updated: string;
  selfLink: string;
  etag: string;
  links?: Array<{
    type: string;
    description?: string;
    link: string;
  }>;
}

interface SubTask {
  id: string;
  title: string;
  completed: boolean;
  due: string;
}

interface RecurringConfig {
  enabled: boolean;
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
  interval: number;
  endDate: string;
}

export interface EnhancedGoogleTask extends GoogleTask {
  labels?: string[];
  priority?: 'low' | 'normal' | 'high' | 'urgent';
  subtasks?: SubTask[];
  recurring?: RecurringConfig;
}

// Hierarchical task structure for UI display with enhanced properties
export interface HierarchicalTask extends EnhancedGoogleTask {
  children: HierarchicalTask[];
  depth: number;  // Nesting level for UI rendering
}

// Task creation data with support for parent relationship
export interface TaskCreateData {
  title: string;
  notes?: string;
  due?: string;
  parent?: string;
  position?: string;
  priority?: 'low' | 'normal' | 'high' | 'urgent';
  subtasks?: Array<{
    id: string;
    title: string;
    completed: boolean;
    due?: string;
  }>;
  labels?: string[];
  recurring?: {
    enabled: boolean;
    frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
    interval: number;
    endDate?: string;
  };
}

export interface TaskMoveRequest {
  taskId: string;
  taskListId: string;
  parent?: string;
  previous?: string;
}

export interface CalendarEventCreateRequest {
  summary: string;
  description?: string;
  start: {
    dateTime: string;
    timeZone: string;
  };
  end: {
    dateTime: string;
    timeZone: string;
  };
  location?: string;
  attendees?: Array<{
    email: string;
  }>;
}

export interface ScheduleTaskModalData {
  taskId: string;
  taskTitle: string;
  date: string;
  startTime: string;
  endTime: string;
  description?: string;
  location?: string;
}

// UI-specific types
export interface TaskCardProps {
  task: HierarchicalTask;
  onToggleComplete: (taskId: string, completed: boolean) => void;
  onDragStart?: (task: HierarchicalTask) => void;
  isDragging?: boolean;
  isOverdue?: boolean;
}

export interface CalendarViewType {
  type: 'dayGridMonth' | 'timeGridWeek' | 'timeGridDay' | 'listWeek';
  title: string;
  buttonText: string;
}

export interface DragDropContext {
  activeTask: HierarchicalTask | null;
  draggedOver: Date | null;
  isDragging: boolean;
}

export interface KanbanColumn {
  taskList: GoogleTaskList;
  tasks: HierarchicalTask[];  // Changed to hierarchical tasks
  isLoading: boolean;
  error?: string;
}

export interface GoogleApiError {
  code: number;
  message: string;
  status: string;
}

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: GoogleApiError;
}

export interface PaginatedResponse<T> {
  items: T[];
  nextPageToken?: string;
  etag?: string;
}



END OF FILE: src/types/google.ts


====================================================================================================
FILE: vitest.hoisted.setup.ts
DESCRIPTION: Test setup file with task mock data
====================================================================================================

import { vi } from 'vitest';
import React from 'react';

// Create a proper Vitest mock function with default implementation
const mockInvoke = vi.hoisted(() => {
  return vi.fn().mockImplementation((command: string, args: any): Promise<any> => {
    console.log(`[Mock] Invoking command: ${command}`, args);
    
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          switch (command) {
            case 'get_task_lists':
              resolve([
                {
                  id: 'list-1',
                  title: 'My Tasks',
                  updated: new Date().toISOString(),
                  selfLink: 'https://example.com/list-1',
                  etag: 'etag-1',
                },
                {
                  id: 'list-2',
                  title: 'Work Tasks',
                  updated: new Date().toISOString(),
                  selfLink: 'https://example.com/list-2',
                  etag: 'etag-2',
                }
              ]);
              break;
              
            case 'get_tasks':
              const taskListId = args.taskListId;
              const mockTasks = {
                'list-1': [
                  {
                    id: 'task-1',
                    title: 'Complete project proposal',
                    notes: 'Test notes',
                    status: 'needsAction',
                    due: new Date(Date.now() + 86400000).toISOString(),
                    position: '1',
                    updated: new Date().toISOString(),
                    selfLink: 'https://example.com/task-1',
                    etag: 'etag-task-1',
                  }
                ],
                'list-2': []
              };
              resolve({ items: mockTasks[taskListId] || [] });
              break;
              
            case 'create_task':
              const newTask = {
                id: `task-${Date.now()}`,
                title: args.taskData.title,
                notes: args.taskData.notes,
                status: 'needsAction',
                due: args.taskData.due,
                parent: args.taskData.parent,
                position: args.taskData.position || '1',
                updated: new Date().toISOString(),
                selfLink: `https://example.com/task-${Date.now()}`,
                etag: `etag-${Date.now()}`,
              };
              resolve(newTask);
              break;
              
            case 'update_task':
              const updatedTask = {
                id: args.taskId,
                title: args.taskData.title || 'Updated Task',
                notes: args.taskData.notes || 'Updated notes',
                status: args.taskData.status || 'needsAction',
                due: args.taskData.due,
                updated: new Date().toISOString(),
                selfLink: `https://example.com/task-${args.taskId}`,
                etag: `etag-${args.taskId}`,
                completed: args.taskData.completed || (args.taskData.status === 'completed' ? new Date().toISOString() : undefined),
              };
              resolve(updatedTask);
              break;
              
            case 'move_task':
              const movedTask = {
                id: args.taskId,
                title: 'Moved Task',
                notes: 'Moved notes',
                status: 'needsAction',
                updated: new Date().toISOString(),
                selfLink: `https://example.com/task-${args.taskId}`,
                etag: `etag-${args.taskId}`,
                position: args.options?.previous || '1',
                parent: args.options?.parent,
              };
              resolve(movedTask);
              break;
              
            case 'delete_task':
              resolve(undefined);
              break;
              
            default:
              reject(new Error(`Unknown command: ${command}`));
          }
        } catch (error) {
          reject(error);
        }
      }, 100); // Fast response for tests
    });
  });
});

// Use vi.hoisted for shared mock variables to prevent circular dependencies
const mocks = vi.hoisted(() => ({
  invoke: mockInvoke,
  listen: vi.fn(),
  transformCallback: vi.fn(),
  mockIPC: vi.fn(),
  clearMocks: vi.fn(),
}));

// Export the mockInvoke function for test access
export { mockInvoke };

// Mock the mockGoogleService to return our hoisted mockInvoke
vi.mock('src/services/google/mockGoogleService', () => ({
  mockInvoke: mockInvoke,
  getMockAccount: () => ({
    id: 'mock-account-1',
    email: 'test@example.com',
    name: 'Test User',
    picture: 'https://via.placeholder.com/150',
    accessToken: 'mock-access-token',
    refreshToken: 'mock-refresh-token',
    expiresAt: Date.now() + 3600000,
  }),
}));

// Mock Tauri API with proper IPC patterns
vi.mock('@tauri-apps/api/core', () => ({
  invoke: mockInvoke,
}));

// Mock Tauri IPC mocks for proper testing
vi.mock('@tauri-apps/api/mocks', () => ({
  mockIPC: mocks.mockIPC,
  clearMocks: mocks.clearMocks,
}));

// Mock Tauri event API
vi.mock('@tauri-apps/api/event', () => ({
  listen: mocks.listen,
  emit: vi.fn(),
}));

// Mock DnD Kit with React.createElement instead of JSX
vi.mock('@dnd-kit/core', () => ({
  DndContext: vi.fn().mockImplementation(({ children }) => 
    React.createElement('div', { 'data-testid': 'dnd-context' }, children)
  ),
  useDraggable: vi.fn(() => ({
    attributes: {},
    listeners: {},
    setNodeRef: vi.fn(),
    transform: null,
    isDragging: false,
  })),
  useDroppable: vi.fn(() => ({
    setNodeRef: vi.fn(),
    isOver: false,
    active: null,
  })),
  DragOverlay: vi.fn().mockImplementation(({ children }) => 
    React.createElement('div', { 'data-testid': 'drag-overlay' }, children)
  ),
}));

// Mock @dnd-kit/sortable
vi.mock('@dnd-kit/sortable', () => ({
  SortableContext: vi.fn().mockImplementation(({ children }) => 
    React.createElement('div', { 'data-testid': 'sortable-context' }, children)
  ),
  useSortable: vi.fn(() => ({
    attributes: {},
    listeners: {},
    setNodeRef: vi.fn(),
    transform: null,
    transition: null,
    isDragging: false,
  })),
  arrayMove: vi.fn((array, from, to) => {
    const newArray = [...array];
    newArray.splice(to, 0, newArray.splice(from, 1)[0]);
    return newArray;
  }),
}));

// Mock React Testing Library with proper async utilities
vi.mock('@testing-library/react', async (importOriginal) => {
  const actual = await importOriginal() as any;
  return {
    ...actual,
    act: vi.fn().mockImplementation(actual.act),
    waitFor: vi.fn().mockImplementation(actual.waitFor),
    findByText: vi.fn().mockImplementation(actual.findByText),
    findByTestId: vi.fn().mockImplementation(actual.findByTestId),
  };
});

// Mock Web Worker API with proper message handling
global.Worker = vi.fn().mockImplementation(() => {
  const worker = {
    postMessage: vi.fn(),
    terminate: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    onmessage: null,
    onerror: null,
  };
  
  // Simulate worker behavior
  setTimeout(() => {
    if (worker.onmessage) {
      worker.onmessage({ data: { type: 'sync-started' } } as MessageEvent);
      setTimeout(() => {
        if (worker.onmessage) {
          worker.onmessage({ data: { type: 'sync-finished' } } as MessageEvent);
        }
      }, 100);
    }
  }, 50);
  
  return worker;
});

// Set up proper before/after hooks
beforeEach(() => {
  vi.clearAllMocks();
  // Reset the mock to its default implementation
  mockInvoke.mockReset();
  mockInvoke.mockImplementation((command: string, args: any): Promise<any> => {
    console.log(`[Mock] Invoking command: ${command}`, args);
    
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          switch (command) {
            case 'get_task_lists':
              resolve([
                {
                  id: 'list-1',
                  title: 'My Tasks',
                  updated: new Date().toISOString(),
                  selfLink: 'https://example.com/list-1',
                  etag: 'etag-1',
                },
                {
                  id: 'list-2',
                  title: 'Work Tasks',
                  updated: new Date().toISOString(),
                  selfLink: 'https://example.com/list-2',
                  etag: 'etag-2',
                }
              ]);
              break;
              
            case 'get_tasks':
              const taskListId = args.taskListId;
              const mockTasks = {
                'list-1': [
                  {
                    id: 'task-1',
                    title: 'Complete project proposal',
                    notes: 'Test notes',
                    status: 'needsAction',
                    due: new Date(Date.now() + 86400000).toISOString(),
                    position: '1',
                    updated: new Date().toISOString(),
                    selfLink: 'https://example.com/task-1',
                    etag: 'etag-task-1',
                  }
                ],
                'list-2': []
              };
              resolve({ items: mockTasks[taskListId] || [] });
              break;
              
            case 'create_task':
              const newTask = {
                id: `task-${Date.now()}`,
                title: args.taskData.title,
                notes: args.taskData.notes,
                status: 'needsAction',
                due: args.taskData.due,
                parent: args.taskData.parent,
                position: args.taskData.position || '1',
                updated: new Date().toISOString(),
                selfLink: `https://example.com/task-${Date.now()}`,
                etag: `etag-${Date.now()}`,
              };
              resolve(newTask);
              break;
              
            case 'update_task':
              const updatedTask = {
                id: args.taskId,
                title: args.taskData.title || 'Updated Task',
                notes: args.taskData.notes || 'Updated notes',
                status: args.taskData.status || 'needsAction',
                due: args.taskData.due,
                updated: new Date().toISOString(),
                selfLink: `https://example.com/task-${args.taskId}`,
                etag: `etag-${args.taskId}`,
                completed: args.taskData.completed || (args.taskData.status === 'completed' ? new Date().toISOString() : undefined),
              };
              resolve(updatedTask);
              break;
              
            case 'move_task':
              const movedTask = {
                id: args.taskId,
                title: 'Moved Task',
                notes: 'Moved notes',
                status: 'needsAction',
                updated: new Date().toISOString(),
                selfLink: `https://example.com/task-${args.taskId}`,
                etag: `etag-${args.taskId}`,
                position: args.options?.previous || '1',
                parent: args.options?.parent,
              };
              resolve(movedTask);
              break;
              
            case 'delete_task':
              resolve(undefined);
              break;
              
            default:
              reject(new Error(`Unknown command: ${command}`));
          }
        } catch (error) {
          reject(error);
        }
      }, 100); // Fast response for tests
    });
  });
});


END OF FILE: vitest.hoisted.setup.ts


====================================================================================================
FILE: src/features/tasks/tests/component-integration.test.tsx
DESCRIPTION: Component integration tests
====================================================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { mockInvoke } from '../../../services/google/mockGoogleService';
import { useGoogleStore } from '../../../stores/googleStore';
import { useTaskMetadataStore } from '../../../stores/taskMetadataStore';

// Mock the Tauri invoke function
vi.mock('@tauri-apps/api/core', () => ({
  invoke: vi.fn().mockImplementation(mockInvoke),
}));

// Mock DND Kit
vi.mock('@dnd-kit/core', () => ({
  DndContext: vi.fn().mockImplementation(({ children }: { children: React.ReactNode }) => 
    React.createElement('div', { 'data-testid': 'dnd-context' }, children)
  ),
  DragOverlay: vi.fn().mockImplementation(({ children }: { children: React.ReactNode }) => 
    React.createElement('div', { 'data-testid': 'drag-overlay' }, children)
  ),
  useSensor: vi.fn(),
  useSensors: vi.fn().mockReturnValue([]),
  PointerSensor: vi.fn(),
  KeyboardSensor: vi.fn(),
  closestCorners: vi.fn(),
}));

vi.mock('@dnd-kit/sortable', () => ({
  sortableKeyboardCoordinates: vi.fn(),
}));

// Mock Zustand with React
vi.mock('zustand/react/shallow', () => ({
  useShallow: (fn: any) => fn,
}));

// Mock React imports
import React from 'react';
import Tasks from '../../../app/pages/Tasks';
import { TaskCard } from '../components/TaskCard';
import { TaskColumn } from '../components/TaskColumn';
import { TaskModal } from '../components/TaskModal';

// Mock components that are complex to test
vi.mock('../../../components/ui', () => ({
  Card: vi.fn().mockImplementation(({ children, className }: { children: React.ReactNode; className?: string }) => 
    React.createElement('div', { className, 'data-testid': 'card' }, children)
  ),
  Button: vi.fn().mockImplementation(({ children, onClick, variant, size, className }: { 
    children: React.ReactNode; 
    onClick?: () => void; 
    variant?: string; 
    size?: string; 
    className?: string; 
  }) => 
    React.createElement('button', { 
      onClick, 
      className, 
      'data-testid': 'button',
      'data-variant': variant,
      'data-size': size
    }, children)
  ),
  Toast: vi.fn().mockImplementation(({ title, message, variant }: { title: string; message: string; variant: string }) => 
    React.createElement('div', { 'data-testid': 'toast', 'data-variant': variant }, [
      React.createElement('div', { 'data-testid': 'toast-title', key: 'title' }, title),
      React.createElement('div', { 'data-testid': 'toast-message', key: 'message' }, message)
    ])
  ),
  FlexibleGrid: vi.fn().mockImplementation(({ children, className }: { children: React.ReactNode; className?: string }) => 
    React.createElement('div', { className, 'data-testid': 'flexible-grid' }, children)
  ),
}));

// Mock Lucide React icons
vi.mock('lucide-react', () => ({
  Plus: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'plus-icon' }, '+')),
  LayoutGrid: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'layout-grid-icon' }, '⊞')),
  List: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'list-icon' }, '☰')),
  Calendar: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'calendar-icon' }, '📅')),
  Clock: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'clock-icon' }, '🕐')),
  Tag: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'tag-icon' }, '🏷️')),
  User: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'user-icon' }, '👤')),
  CheckCircle: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'check-circle-icon' }, '✓')),
  XCircle: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'x-circle-icon' }, '✗')),
  MoreHorizontal: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'more-horizontal-icon' }, '⋯')),
  Edit: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'edit-icon' }, '✏️')),
  Trash: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'trash-icon' }, '🗑️')),
  Move: vi.fn().mockImplementation(() => React.createElement('span', { 'data-testid': 'move-icon' }, '↔️')),
}));

// Mock console methods
const mockConsole = {
  log: vi.fn(),
  error: vi.fn(),
  warn: vi.fn(),
};

beforeEach(() => {
  vi.spyOn(console, 'log').mockImplementation(mockConsole.log);
  vi.spyOn(console, 'error').mockImplementation(mockConsole.error);
  vi.spyOn(console, 'warn').mockImplementation(mockConsole.warn);
});

afterEach(() => {
  vi.restoreAllMocks();
  mockConsole.log.mockClear();
  mockConsole.error.mockClear();
  mockConsole.warn.mockClear();
});

describe('Component Integration Tests', () => {
  let mockStore: any;
  let mockMetadataStore: any;

  beforeEach(() => {
    // Mock store state
    mockStore = {
      taskLists: [
        { id: 'list-1', title: 'To Do', updated: '2024-01-01', selfLink: '', etag: '' },
        { id: 'list-2', title: 'In Progress', updated: '2024-01-01', selfLink: '', etag: '' },
        { id: 'list-3', title: 'Done', updated: '2024-01-01', selfLink: '', etag: '' },
      ],
      kanbanColumns: [
        {
          taskList: { id: 'list-1', title: 'To Do' },
          tasks: [
            { id: 'task-1', title: 'Task 1', notes: 'Notes 1', status: 'needsAction' },
            { id: 'task-2', title: 'Task 2', notes: 'Notes 2', status: 'needsAction' },
          ],
        },
        {
          taskList: { id: 'list-2', title: 'In Progress' },
          tasks: [
            { id: 'task-3', title: 'Task 3', notes: 'Notes 3', status: 'needsAction' },
          ],
        },
        {
          taskList: { id: 'list-3', title: 'Done' },
          tasks: [
            { id: 'task-4', title: 'Task 4', notes: 'Notes 4', status: 'completed' },
          ],
        },
      ],
      isLoadingTasks: false,
      activeAccount: {
        id: 'account-1',
        email: 'test@example.com',
        name: 'Test User',
      },
      createTask: vi.fn(),
      updateTask: vi.fn(),
      deleteTask: vi.fn(),
      toggleTaskCompletion: vi.fn(),
      fetchTaskLists: vi.fn(),
      fetchAllTasks: vi.fn(),
      optimisticUpdateTask: vi.fn(),
      taskIdToListId: new Map([
        ['task-1', 'list-1'],
        ['task-2', 'list-1'],
        ['task-3', 'list-2'],
        ['task-4', 'list-3'],
      ]),
      fetchTasksForList: vi.fn(),
    };

    mockMetadataStore = {
      metadata: new Map(),
      setTaskMetadata: vi.fn(),
      getTaskMetadata: vi.fn().mockReturnValue(null),
      deleteTaskMetadata: vi.fn(),
      clearAllMetadata: vi.fn(),
      importFromNotesField: vi.fn(),
      exportToNotesField: vi.fn().mockReturnValue(''),
    };

    // Mock store hooks
    vi.mocked(useGoogleStore).mockReturnValue(mockStore);
    vi.mocked(useTaskMetadataStore).mockReturnValue(mockMetadataStore);
  });

  describe('Tasks Page Integration', () => {
    it('should render tasks page with kanban columns', async () => {
      render(React.createElement(Tasks));

      // Check for view toggle controls
      expect(screen.getByText('Board')).toBeInTheDocument();
      expect(screen.getByText('List')).toBeInTheDocument();

      // Check for kanban columns
      expect(screen.getByText('To Do')).toBeInTheDocument();
      expect(screen.getByText('In Progress')).toBeInTheDocument();
      expect(screen.getByText('Done')).toBeInTheDocument();

      // Check for tasks
      expect(screen.getByText('Task 1')).toBeInTheDocument();
      expect(screen.getByText('Task 2')).toBeInTheDocument();
      expect(screen.getByText('Task 3')).toBeInTheDocument();
      expect(screen.getByText('Task 4')).toBeInTheDocument();
    });

    it('should handle view mode toggle', async () => {
      render(React.createElement(Tasks));

      // Start in kanban view
      expect(screen.getByText('Board')).toBeInTheDocument();
      expect(screen.getByText('List')).toBeInTheDocument();

      // Switch to list view
      const listButton = screen.getByText('List');
      fireEvent.click(listButton);

      // Should show list view
      await waitFor(() => {
        expect(screen.getByText('All Tasks')).toBeInTheDocument();
      });
    });

    it('should handle task creation', async () => {
      mockStore.createTask.mockResolvedValue({
        id: 'new-task',
        title: 'New Task',
        notes: 'New notes',
        status: 'needsAction',
      });

      render(React.createElement(Tasks));

      // Click new task button
      const newTaskButton = screen.getByText('New Task');
      fireEvent.click(newTaskButton);

      // Should open modal
      await waitFor(() => {
        expect(screen.getByText('Create Task')).toBeInTheDocument();
      });
    });

    it('should handle task updates', async () => {
      mockStore.updateTask.mockResolvedValue({
        id: 'task-1',
        title: 'Updated Task',
        notes: 'Updated notes',
        status: 'needsAction',
      });

      render(React.createElement(Tasks));

      // Click on a task to edit it
      const taskElement = screen.getByText('Task 1');
      fireEvent.click(taskElement);

      // Should open edit modal
      await waitFor(() => {
        expect(screen.getByText('Edit Task')).toBeInTheDocument();
      });
    });

    it('should handle task deletion', async () => {
      mockStore.deleteTask.mockResolvedValue(undefined);

      render(React.createElement(Tasks));

      // Find and click delete button (implementation depends on TaskCard)
      const deleteButtons = screen.getAllByTestId('trash-icon');
      if (deleteButtons.length > 0) {
        fireEvent.click(deleteButtons[0]);
        
        await waitFor(() => {
          expect(mockStore.deleteTask).toHaveBeenCalled();
        });
      }
    });

    it('should handle task completion toggle', async () => {
      mockStore.toggleTaskCompletion.mockResolvedValue({
        id: 'task-1',
        title: 'Task 1',
        status: 'completed',
      });

      render(React.createElement(Tasks));

      // Find and click completion checkbox
      const checkboxes = screen.getAllByTestId('check-circle-icon');
      if (checkboxes.length > 0) {
        fireEvent.click(checkboxes[0]);
        
        await waitFor(() => {
          expect(mockStore.toggleTaskCompletion).toHaveBeenCalled();
        });
      }
    });

    it('should handle loading state', async () => {
      mockStore.isLoadingTasks = true;
      mockStore.taskLists = [];

      render(React.createElement(Tasks));

      // Should show loading skeleton
      expect(screen.getByTestId('flexible-grid')).toBeInTheDocument();
    });

    it('should handle error state', async () => {
      mockStore.taskLists = [];
      mockStore.isLoadingTasks = false;

      render(React.createElement(Tasks));

      // Should show error message
      expect(screen.getByText('No task lists found')).toBeInTheDocument();
    });

    it('should handle no active account', async () => {
      mockStore.activeAccount = null;

      render(React.createElement(Tasks));

      // Should show no account message
      expect(screen.getByText('No Google Account Connected')).toBeInTheDocument();
    });
  });

  describe('TaskCard Integration', () => {
    const mockTask = {
      id: 'task-1',
      title: 'Test Task',
      notes: 'Test notes',
      status: 'needsAction' as const,
      due: '2024-12-31',
      labels: ['urgent', 'work'],
      priority: 'high' as const,
    };

    it('should render task card with basic information', () => {
      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskCard
          task={mockTask}
          listId="list-1"
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      expect(screen.getByText('Test Task')).toBeInTheDocument();
      expect(screen.getByText('Test notes')).toBeInTheDocument();
    });

    it('should handle task click', () => {
      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskCard
          task={mockTask}
          listId="list-1"
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      const taskElement = screen.getByText('Test Task');
      fireEvent.click(taskElement);

      expect(mockHandlers.onTaskClick).toHaveBeenCalledWith(mockTask, 'list-1');
    });

    it('should handle completion toggle', () => {
      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskCard
          task={mockTask}
          listId="list-1"
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      const checkIcon = screen.getByTestId('check-circle-icon');
      fireEvent.click(checkIcon);

      expect(mockHandlers.onToggleCompletion).toHaveBeenCalledWith(
        'list-1',
        'task-1',
        'needsAction'
      );
    });

    it('should handle task deletion', () => {
      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskCard
          task={mockTask}
          listId="list-1"
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      const deleteIcon = screen.getByTestId('trash-icon');
      fireEvent.click(deleteIcon);

      expect(mockHandlers.onDeleteTask).toHaveBeenCalled();
    });

    it('should show due date indicator', () => {
      const taskWithDueDate = {
        ...mockTask,
        due: '2024-12-31',
      };

      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskCard
          task={taskWithDueDate}
          listId="list-1"
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      expect(screen.getByTestId('calendar-icon')).toBeInTheDocument();
    });

    it('should show priority indicator', () => {
      const taskWithPriority = {
        ...mockTask,
        priority: 'high' as const,
      };

      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskCard
          task={taskWithPriority}
          listId="list-1"
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      // Priority indicator should be visible (implementation specific)
      expect(screen.getByText('Test Task')).toBeInTheDocument();
    });

    it('should show labels', () => {
      const taskWithLabels = {
        ...mockTask,
        labels: ['urgent', 'work'],
      };

      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskCard
          task={taskWithLabels}
          listId="list-1"
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      // Labels should be visible (implementation specific)
      expect(screen.getByText('Test Task')).toBeInTheDocument();
    });
  });

  describe('TaskColumn Integration', () => {
    const mockTaskList = {
      id: 'list-1',
      title: 'Test Column',
      updated: '2024-01-01',
      selfLink: '',
      etag: '',
    };

    const mockTasks = [
      { id: 'task-1', title: 'Task 1', notes: 'Notes 1', status: 'needsAction' as const },
      { id: 'task-2', title: 'Task 2', notes: 'Notes 2', status: 'needsAction' as const },
    ];

    it('should render task column with tasks', () => {
      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onOpenCreateModal: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskColumn
          id="list-1"
          taskList={mockTaskList}
          tasks={mockTasks}
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      expect(screen.getByText('Test Column')).toBeInTheDocument();
      expect(screen.getByText('Task 1')).toBeInTheDocument();
      expect(screen.getByText('Task 2')).toBeInTheDocument();
    });

    it('should handle create task in column', () => {
      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onOpenCreateModal: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskColumn
          id="list-1"
          taskList={mockTaskList}
          tasks={mockTasks}
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      const addButton = screen.getByTestId('plus-icon');
      fireEvent.click(addButton);

      expect(mockHandlers.onOpenCreateModal).toHaveBeenCalledWith('list-1', 'Test Column');
    });

    it('should show task count', () => {
      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onOpenCreateModal: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskColumn
          id="list-1"
          taskList={mockTaskList}
          tasks={mockTasks}
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      expect(screen.getByText('2')).toBeInTheDocument();
    });

    it('should handle empty column', () => {
      const mockHandlers = {
        onTaskClick: vi.fn(),
        onToggleCompletion: vi.fn(),
        onDeleteTask: vi.fn(),
        onOpenCreateModal: vi.fn(),
        onRetrySync: vi.fn(),
      };

      render(
        <TaskColumn
          id="list-1"
          taskList={mockTaskList}
          tasks={[]}
          isDragStarted={false}
          {...mockHandlers}
        />
      );

      expect(screen.getByText('Test Column')).toBeInTheDocument();
      expect(screen.getByText('0')).toBeInTheDocument();
    });
  });

  describe('TaskModal Integration', () => {
    const mockTask = {
      id: 'task-1',
      title: 'Test Task',
      notes: 'Test notes',
      status: 'needsAction' as const,
      due: '2024-12-31',
      labels: ['urgent', 'work'],
      priority: 'high' as const,
    };

    const mockModalState = {
      type: 'edit' as const,
      columnId: 'list-1',
      columnTitle: 'Test Column',
      isOpen: true,
      task: mockTask,
    };

    const mockTaskForm = {
      title: 'Test Task',
      notes: 'Test notes',
      due: '2024-12-31',
      priority: 'high' as const,
      labels: ['urgent', 'work'],
      subtasks: [],
    };

    const mockTaskLists = [
      { id: 'list-1', title: 'To Do', updated: '2024-01-01', selfLink: '', etag: '' },
      { id: 'list-2', title: 'In Progress', updated: '2024-01-01', selfLink: '', etag: '' },
    ];

    it('should render task modal in edit mode', () => {
      const mockHandlers = {
        onClose: vi.fn(),
        onSubmit: vi.fn(),
        onUpdateForm: vi.fn(),
        onAddLabel: vi.fn(),
        onRemoveLabel: vi.fn(),
        onAddSubtask: vi.fn(),
        onUpdateSubtask: vi.fn(),
        onRemoveSubtask: vi.fn(),
      };

      render(
        <TaskModal
          modalState={mockModalState}
          taskForm={mockTaskForm}
          formErrors={{}}
          taskLists={mockTaskLists}
          isLoading={false}
          {...mockHandlers}
        />
      );

      expect(screen.getByText('Edit Task')).toBeInTheDocument();
      expect(screen.getByDisplayValue('Test Task')).toBeInTheDocument();
      expect(screen.getByDisplayValue('Test notes')).toBeInTheDocument();
    });

    it('should render task modal in create mode', () => {
      const createModalState = {
        type: 'create' as const,
        columnId: 'list-1',
        columnTitle: 'Test Column',
        isOpen: true,
        task: null,
      };

      const emptyTaskForm = {
        title: '',
        notes: '',
        due: '',
        priority: 'normal' as const,
        labels: [],
        subtasks: [],
      };

      const mockHandlers = {
        onClose: vi.fn(),
        onSubmit: vi.fn(),
        onUpdateForm: vi.fn(),
        onAddLabel: vi.fn(),
        onRemoveLabel: vi.fn(),
        onAddSubtask: vi.fn(),
        onUpdateSubtask: vi.fn(),
        onRemoveSubtask: vi.fn(),
      };

      render(
        <TaskModal
          modalState={createModalState}
          taskForm={emptyTaskForm}
          formErrors={{}}
          taskLists={mockTaskLists}
          isLoading={false}
          {...mockHandlers}
        />
      );

      expect(screen.getByText('Create Task')).toBeInTheDocument();
    });

    it('should handle form submission', () => {
      const mockHandlers = {
        onClose: vi.fn(),
        onSubmit: vi.fn(),
        onUpdateForm: vi.fn(),
        onAddLabel: vi.fn(),
        onRemoveLabel: vi.fn(),
        onAddSubtask: vi.fn(),
        onUpdateSubtask: vi.fn(),
        onRemoveSubtask: vi.fn(),
      };

      render(
        <TaskModal
          modalState={mockModalState}
          taskForm={mockTaskForm}
          formErrors={{}}
          taskLists={mockTaskLists}
          isLoading={false}
          {...mockHandlers}
        />
      );

      const submitButton = screen.getByText('Save Task');
      fireEvent.click(submitButton);

      expect(mockHandlers.onSubmit).toHaveBeenCalledWith('list-1', mockTaskForm);
    });

    it('should handle modal close', () => {
      const mockHandlers = {
        onClose: vi.fn(),
        onSubmit: vi.fn(),
        onUpdateForm: vi.fn(),
        onAddLabel: vi.fn(),
        onRemoveLabel: vi.fn(),
        onAddSubtask: vi.fn(),
        onUpdateSubtask: vi.fn(),
        onRemoveSubtask: vi.fn(),
      };

      render(
        <TaskModal
          modalState={mockModalState}
          taskForm={mockTaskForm}
          formErrors={{}}
          taskLists={mockTaskLists}
          isLoading={false}
          {...mockHandlers}
        />
      );

      const cancelButton = screen.getByText('Cancel');
      fireEvent.click(cancelButton);

      expect(mockHandlers.onClose).toHaveBeenCalled();
    });

    it('should handle form updates', () => {
      const mockHandlers = {
        onClose: vi.fn(),
        onSubmit: vi.fn(),
        onUpdateForm: vi.fn(),
        onAddLabel: vi.fn(),
        onRemoveLabel: vi.fn(),
        onAddSubtask: vi.fn(),
        onUpdateSubtask: vi.fn(),
        onRemoveSubtask: vi.fn(),
      };

      render(
        <TaskModal
          modalState={mockModalState}
          taskForm={mockTaskForm}
          formErrors={{}}
          taskLists={mockTaskLists}
          isLoading={false}
          {...mockHandlers}
        />
      );

      const titleInput = screen.getByDisplayValue('Test Task');
      fireEvent.change(titleInput, { target: { value: 'Updated Task' } });

      expect(mockHandlers.onUpdateForm).toHaveBeenCalledWith('title', 'Updated Task');
    });

    it('should handle label management', () => {
      const mockHandlers = {
        onClose: vi.fn(),
        onSubmit: vi.fn(),
        onUpdateForm: vi.fn(),
        onAddLabel: vi.fn(),
        onRemoveLabel: vi.fn(),
        onAddSubtask: vi.fn(),
        onUpdateSubtask: vi.fn(),
        onRemoveSubtask: vi.fn(),
      };

      render(
        <TaskModal
          modalState={mockModalState}
          taskForm={mockTaskForm}
          formErrors={{}}
          taskLists={mockTaskLists}
          isLoading={false}
          {...mockHandlers}
        />
      );

      // Add label
      const addLabelButton = screen.getByText('Add Label');
      fireEvent.click(addLabelButton);

      expect(mockHandlers.onAddLabel).toHaveBeenCalledWith('');
    });

    it('should show validation errors', () => {
      const mockHandlers = {
        onClose: vi.fn(),
        onSubmit: vi.fn(),
        onUpdateForm: vi.fn(),
        onAddLabel: vi.fn(),
        onRemoveLabel: vi.fn(),
        onAddSubtask: vi.fn(),
        onUpdateSubtask: vi.fn(),
        onRemoveSubtask: vi.fn(),
      };

      const formErrors = {
        title: 'Title is required',
        due: 'Invalid date format',
      };

      render(
        <TaskModal
          modalState={mockModalState}
          taskForm={mockTaskForm}
          formErrors={formErrors}
          taskLists={mockTaskLists}
          isLoading={false}
          {...mockHandlers}
        />
      );

      expect(screen.getByText('Title is required')).toBeInTheDocument();
      expect(screen.getByText('Invalid date format')).toBeInTheDocument();
    });

    it('should handle loading state', () => {
      const mockHandlers = {
        onClose: vi.fn(),
        onSubmit: vi.fn(),
        onUpdateForm: vi.fn(),
        onAddLabel: vi.fn(),
        onRemoveLabel: vi.fn(),
        onAddSubtask: vi.fn(),
        onUpdateSubtask: vi.fn(),
        onRemoveSubtask: vi.fn(),
      };

      render(
        <TaskModal
          modalState={mockModalState}
          taskForm={mockTaskForm}
          formErrors={{}}
          taskLists={mockTaskLists}
          isLoading={true}
          {...mockHandlers}
        />
      );

      const submitButton = screen.getByText('Save Task');
      expect(submitButton).toBeDisabled();
    });
  });

  describe('End-to-End Integration', () => {
    it('should handle complete task creation flow', async () => {
      mockStore.createTask.mockResolvedValue({
        id: 'new-task',
        title: 'New Task',
        notes: 'New notes',
        status: 'needsAction',
      });

      render(React.createElement(Tasks));

      // Click new task button
      const newTaskButton = screen.getByText('New Task');
      fireEvent.click(newTaskButton);

      // Fill form
      await waitFor(() => {
        const titleInput = screen.getByPlaceholderText('Task title');
        fireEvent.change(titleInput, { target: { value: 'New Task' } });
        
        const notesInput = screen.getByPlaceholderText('Task notes');
        fireEvent.change(notesInput, { target: { value: 'New notes' } });
      });

      // Submit form
      const submitButton = screen.getByText('Create Task');
      fireEvent.click(submitButton);

      await waitFor(() => {
        expect(mockStore.createTask).toHaveBeenCalledWith('list-1', {
          title: 'New Task',
          notes: 'New notes',
        });
      });
    });

    it('should handle complete task editing flow', async () => {
      mockStore.updateTask.mockResolvedValue({
        id: 'task-1',
        title: 'Updated Task',
        notes: 'Updated notes',
        status: 'needsAction',
      });

      render(React.createElement(Tasks));

      // Click on task
      const taskElement = screen.getByText('Task 1');
      fireEvent.click(taskElement);

      // Edit form
      await waitFor(() => {
        const titleInput = screen.getByDisplayValue('Task 1');
        fireEvent.change(titleInput, { target: { value: 'Updated Task' } });
      });

      // Submit form
      const submitButton = screen.getByText('Save Task');
      fireEvent.click(submitButton);

      await waitFor(() => {
        expect(mockStore.updateTask).toHaveBeenCalledWith('list-1', 'task-1', {
          title: 'Updated Task',
          notes: 'Notes 1',
        });
      });
    });

    it('should handle task movement between columns', async () => {
      // This would require DND Kit integration testing
      // For now, we'll test the store integration
      mockStore.moveTask = vi.fn().mockResolvedValue({
        id: 'task-1',
        title: 'Task 1',
        status: 'needsAction',
      });

      render(React.createElement(Tasks));

      // Simulate drag and drop (implementation depends on DND Kit setup)
      // This would involve more complex setup for testing drag and drop
      expect(screen.getByText('Task 1')).toBeInTheDocument();
    });

    it('should handle error states throughout the flow', async () => {
      mockStore.createTask.mockRejectedValue(new Error('Creation failed'));

      render(React.createElement(Tasks));

      // Click new task button
      const newTaskButton = screen.getByText('New Task');
      fireEvent.click(newTaskButton);

      // Fill and submit form
      await waitFor(() => {
        const titleInput = screen.getByPlaceholderText('Task title');
        fireEvent.change(titleInput, { target: { value: 'New Task' } });
        
        const submitButton = screen.getByText('Create Task');
        fireEvent.click(submitButton);
      });

      // Should show error toast
      await waitFor(() => {
        expect(screen.getByTestId('toast')).toBeInTheDocument();
        expect(screen.getByText('Creation Failed')).toBeInTheDocument();
      });
    });

    it('should handle concurrent operations', async () => {
      const task1Promise = Promise.resolve({
        id: 'task-1',
        title: 'Task 1',
        status: 'completed',
      });

      const task2Promise = Promise.resolve({
        id: 'task-2',
        title: 'Task 2',
        status: 'completed',
      });

      mockStore.toggleTaskCompletion
        .mockResolvedValueOnce(task1Promise)
        .mockResolvedValueOnce(task2Promise);

      render(React.createElement(Tasks));

      // Click multiple task checkboxes rapidly
      const checkboxes = screen.getAllByTestId('check-circle-icon');
      fireEvent.click(checkboxes[0]);
      fireEvent.click(checkboxes[1]);

      await waitFor(() => {
        expect(mockStore.toggleTaskCompletion).toHaveBeenCalledTimes(2);
      });
    });
  });
}); 


END OF FILE: src/features/tasks/tests/component-integration.test.tsx


====================================================================================================
FILE: src/features/tasks/tests/drag-drop.test.ts
DESCRIPTION: Drag and drop functionality tests
====================================================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { DragStartEvent, DragOverEvent, DragEndEvent } from '@dnd-kit/core';
import { useKanbanDrag } from '../hooks/useKanbanDrag';
import { useGoogleStore } from '../../../stores/googleStore';
import { mockInvoke } from '../../../services/google/mockGoogleService';

// Mock the Tauri invoke function
vi.mock('@tauri-apps/api/core', () => ({
  invoke: vi.fn().mockImplementation(mockInvoke),
}));

// Mock zustand
vi.mock('../../../stores/googleStore', () => ({
  useGoogleStore: vi.fn(),
}));

// Mock console methods
const mockConsole = {
  log: vi.fn(),
  error: vi.fn(),
  warn: vi.fn(),
};

beforeEach(() => {
  vi.spyOn(console, 'log').mockImplementation(mockConsole.log);
  vi.spyOn(console, 'error').mockImplementation(mockConsole.error);
  vi.spyOn(console, 'warn').mockImplementation(mockConsole.warn);
});

afterEach(() => {
  vi.restoreAllMocks();
  mockConsole.log.mockClear();
  mockConsole.error.mockClear();
  mockConsole.warn.mockClear();
});

describe('Drag and Drop Tests', () => {
  let mockStore: any;
  let mockPendingOperations: any;
  let mockProcessQueue: any;
  let mockKanbanColumns: any;

  beforeEach(() => {
    // Create mock store functions
    mockStore = {
      taskIdToListId: new Map([
        ['task-1', 'list-1'],
        ['task-2', 'list-1'],
        ['task-3', 'list-2'],
        ['task-4', 'list-2'],
        ['task-5', 'list-3'],
      ]),
      optimisticMoveTask: vi.fn(),
      optimisticReorderTask: vi.fn(),
      activeAccount: {
        id: 'account-1',
        email: 'test@example.com',
        name: 'Test User',
      },
    };

    // Create mock pending operations
    mockPendingOperations = {
      current: [],
    };

    // Create mock process queue
    mockProcessQueue = vi.fn();

    // Create mock kanban columns
    mockKanbanColumns = [
      {
        taskList: { id: 'list-1', title: 'To Do' },
        tasks: [
          { id: 'task-1', title: 'Task 1', status: 'needsAction' },
          { id: 'task-2', title: 'Task 2', status: 'needsAction' },
        ],
      },
      {
        taskList: { id: 'list-2', title: 'In Progress' },
        tasks: [
          { id: 'task-3', title: 'Task 3', status: 'needsAction' },
          { id: 'task-4', title: 'Task 4', status: 'needsAction' },
        ],
      },
      {
        taskList: { id: 'list-3', title: 'Done' },
        tasks: [
          { id: 'task-5', title: 'Task 5', status: 'completed' },
        ],
      },
    ];

    // Mock the useGoogleStore hook
    vi.mocked(useGoogleStore).mockReturnValue(mockStore);
  });

  describe('Drag Initialization', () => {
    it('should initialize with empty drag state', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      expect(result.current.dragState.activeTask).toBeNull();
      expect(result.current.dragState.sourceListId).toBeNull();
    });

    it('should provide drag event handlers', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      expect(result.current.handleDragStart).toBeDefined();
      expect(result.current.handleDragOver).toBeDefined();
      expect(result.current.handleDragEnd).toBeDefined();
    });
  });

  describe('Drag Start', () => {
    it('should set drag state on drag start', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      expect(result.current.dragState.activeTask).toEqual(
        expect.objectContaining({ id: 'task-1', title: 'Task 1' })
      );
      expect(result.current.dragState.sourceListId).toBe('list-1');
    });

    it('should handle drag start with non-existent task', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      const dragStartEvent: DragStartEvent = {
        active: { id: 'non-existent-task', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      expect(result.current.dragState.activeTask).toBeNull();
      expect(result.current.dragState.sourceListId).toBeNull();
    });

    it('should handle drag start with task not in taskIdToListId map', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Remove task from map
      mockStore.taskIdToListId.delete('task-1');

      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      expect(result.current.dragState.activeTask).toBeNull();
      expect(result.current.dragState.sourceListId).toBeNull();
    });
  });

  describe('Drag Over', () => {
    it('should handle drag over same item', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // Drag over same item
      const dragOverEvent: DragOverEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        delta: { x: 0, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragOver(dragOverEvent);
      });

      expect(mockStore.optimisticMoveTask).not.toHaveBeenCalled();
      expect(mockStore.optimisticReorderTask).not.toHaveBeenCalled();
    });

    it('should handle drag over different task in same list', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // Drag over different task in same list
      const dragOverEvent: DragOverEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'task-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 0, y: 20 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragOver(dragOverEvent);
      });

      expect(mockStore.optimisticReorderTask).toHaveBeenCalledWith('list-1', 'task-1', 'task-2');
      expect(mockStore.optimisticMoveTask).not.toHaveBeenCalled();
    });

    it('should handle drag over different list', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // Drag over different list
      const dragOverEvent: DragOverEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragOver(dragOverEvent);
      });

      expect(mockStore.optimisticMoveTask).toHaveBeenCalledWith('task-1', 'list-1', 'list-2');
      expect(result.current.dragState.sourceListId).toBe('list-2');
    });

    it('should handle drag over task in different list', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // Drag over task in different list
      const dragOverEvent: DragOverEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'task-3', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragOver(dragOverEvent);
      });

      expect(mockStore.optimisticMoveTask).toHaveBeenCalledWith('task-1', 'list-1', 'list-2');
      expect(result.current.dragState.sourceListId).toBe('list-2');
    });

    it('should handle drag over with no target', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // Drag over nothing
      const dragOverEvent: DragOverEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
        delta: { x: 0, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragOver(dragOverEvent);
      });

      expect(mockStore.optimisticMoveTask).not.toHaveBeenCalled();
      expect(mockStore.optimisticReorderTask).not.toHaveBeenCalled();
    });
  });

  describe('Drag End', () => {
    it('should handle drag end with successful drop on column', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // End drag on column
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(1);
      expect(mockPendingOperations.current[0]).toEqual(
        expect.objectContaining({
          taskId: 'task-1',
          sourceListId: 'list-1',
          targetListId: 'list-2',
          accountId: 'account-1',
        })
      );
      expect(mockProcessQueue).toHaveBeenCalled();
    });

    it('should handle drag end with drop on task', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // End drag on task
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'task-3', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(1);
      expect(mockPendingOperations.current[0]).toEqual(
        expect.objectContaining({
          taskId: 'task-1',
          sourceListId: 'list-1',
          targetListId: 'list-2',
          previous: 'task-3',
        })
      );
      expect(mockProcessQueue).toHaveBeenCalled();
    });

    it('should handle drag end with drop on task in same list', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // End drag on task in same list
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'task-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 0, y: 20 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(1);
      expect(mockPendingOperations.current[0]).toEqual(
        expect.objectContaining({
          taskId: 'task-1',
          sourceListId: 'list-1',
          targetListId: 'list-1',
          previous: 'task-2',
        })
      );
      expect(mockProcessQueue).toHaveBeenCalled();
    });

    it('should handle drag end with drop on empty column', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Create empty column
      const emptyColumn = {
        taskList: { id: 'list-empty', title: 'Empty' },
        tasks: [],
      };
      const columnsWithEmpty = [...mockKanbanColumns, emptyColumn];

      const { result: resultWithEmpty } = renderHook(() => 
        useKanbanDrag(columnsWithEmpty, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        resultWithEmpty.current.handleDragStart(dragStartEvent);
      });

      // End drag on empty column
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-empty', data: { current: {} }, rect: { current: {} } },
        delta: { x: 200, y: 0 },
        collisions: [],
      };

      act(() => {
        resultWithEmpty.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(1);
      expect(mockPendingOperations.current[0]).toEqual(
        expect.objectContaining({
          taskId: 'task-1',
          sourceListId: 'list-1',
          targetListId: 'list-empty',
          previous: undefined,
        })
      );
      expect(mockProcessQueue).toHaveBeenCalled();
    });

    it('should handle drag end with no drop target', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // End drag with no target
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
        delta: { x: 0, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(0);
      expect(mockProcessQueue).not.toHaveBeenCalled();
    });

    it('should handle drag end with same source and target', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // End drag on same item
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        delta: { x: 0, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(0);
      expect(mockProcessQueue).not.toHaveBeenCalled();
    });

    it('should reset drag state after drag end', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      expect(result.current.dragState.activeTask).not.toBeNull();

      // End drag
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(result.current.dragState.activeTask).toBeNull();
      expect(result.current.dragState.sourceListId).toBeNull();
    });
  });

  describe('Error Handling', () => {
    it('should handle missing activeAccount', () => {
      const storeWithoutAccount = {
        ...mockStore,
        activeAccount: null,
      };

      vi.mocked(useGoogleStore).mockReturnValue(storeWithoutAccount);

      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // End drag
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(0);
      expect(mockProcessQueue).not.toHaveBeenCalled();
    });

    it('should handle missing taskIdToListId mapping', () => {
      const storeWithoutMapping = {
        ...mockStore,
        taskIdToListId: new Map(),
      };

      vi.mocked(useGoogleStore).mockReturnValue(storeWithoutMapping);

      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      expect(result.current.dragState.activeTask).toBeNull();
      expect(result.current.dragState.sourceListId).toBeNull();
    });

    it('should handle optimistic update failures', () => {
      // Mock console.error to avoid noise in tests
      const originalError = console.error;
      console.error = vi.fn();

      const storeWithFailingOptimistic = {
        ...mockStore,
        optimisticMoveTask: vi.fn().mockImplementation(() => {
          throw new Error('Optimistic update failed');
        }),
      };

      vi.mocked(useGoogleStore).mockReturnValue(storeWithFailingOptimistic);

      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // This should not crash - the drag handler should handle the error gracefully
      const dragOverEvent: DragOverEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      // The drag handler should catch the error and not let it propagate
      act(() => {
        result.current.handleDragOver(dragOverEvent);
      });

      // The drag operation should continue normally despite the optimistic update failure
      expect(result.current.dragState.activeTask).toBeDefined();

      // Restore console.error
      console.error = originalError;
    });
  });

  describe('Complex Scenarios', () => {
    it('should handle rapid drag movements', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // Multiple rapid drag over events
      const dragOverEvents = [
        { id: 'task-2', targetListId: 'list-1' },
        { id: 'list-2', targetListId: 'list-2' },
        { id: 'task-3', targetListId: 'list-2' },
        { id: 'list-3', targetListId: 'list-3' },
      ];

      dragOverEvents.forEach(({ id, targetListId }) => {
        const dragOverEvent: DragOverEvent = {
          active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
          over: { id, data: { current: {} }, rect: { current: {} } },
          delta: { x: 100, y: 0 },
          collisions: [],
        };

        act(() => {
          result.current.handleDragOver(dragOverEvent);
        });
      });

      // Should handle all movements without crashing
      expect(result.current.dragState.activeTask).not.toBeNull();
    });

    it('should handle drag between multiple columns', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // Move through multiple columns
      const dragOverList2: DragOverEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragOver(dragOverList2);
      });

      expect(result.current.dragState.sourceListId).toBe('list-2');

      const dragOverList3: DragOverEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-3', data: { current: {} }, rect: { current: {} } },
        delta: { x: 200, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragOver(dragOverList3);
      });

      expect(result.current.dragState.sourceListId).toBe('list-3');

      // End drag
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-3', data: { current: {} }, rect: { current: {} } },
        delta: { x: 200, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(1);
      expect(mockPendingOperations.current[0].targetListId).toBe('list-3');
    });

    it('should handle drag with position calculation', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Start drag
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      // End drag on column with tasks (should set previous to last task)
      const dragEndEvent: DragEndEvent = {
        active: { id: 'task-1', data: { current: {} }, rect: { current: {} } },
        over: { id: 'list-2', data: { current: {} }, rect: { current: {} } },
        delta: { x: 100, y: 0 },
        collisions: [],
      };

      act(() => {
        result.current.handleDragEnd(dragEndEvent);
      });

      expect(mockPendingOperations.current).toHaveLength(1);
      expect(mockPendingOperations.current[0].previous).toBe('task-4'); // Last task in list-2
    });

    it('should handle concurrent drag operations', () => {
      const { result } = renderHook(() => 
        useKanbanDrag(mockKanbanColumns, mockPendingOperations, mockProcessQueue)
      );

      // Simulate multiple drag operations
      const dragOperations = [
        { taskId: 'task-1', targetListId: 'list-2' },
        { taskId: 'task-2', targetListId: 'list-3' },
      ];

      dragOperations.forEach(({ taskId, targetListId }) => {
        const dragStartEvent: DragStartEvent = {
          active: { id: taskId, data: { current: {} }, rect: { current: {} } },
          over: null,
        };

        act(() => {
          result.current.handleDragStart(dragStartEvent);
        });

        const dragEndEvent: DragEndEvent = {
          active: { id: taskId, data: { current: {} }, rect: { current: {} } },
          over: { id: targetListId, data: { current: {} }, rect: { current: {} } },
          delta: { x: 100, y: 0 },
          collisions: [],
        };

        act(() => {
          result.current.handleDragEnd(dragEndEvent);
        });
      });

      expect(mockPendingOperations.current).toHaveLength(2);
      expect(mockProcessQueue).toHaveBeenCalledTimes(2);
    });
  });

  describe('Performance Tests', () => {
    it('should handle large number of columns efficiently', () => {
      const largeMockColumns = Array.from({ length: 50 }, (_, i) => ({
        taskList: { id: `list-${i}`, title: `List ${i}` },
        tasks: Array.from({ length: 10 }, (_, j) => ({
          id: `task-${i}-${j}`,
          title: `Task ${i}-${j}`,
          status: 'needsAction',
        })),
      }));

      // Update taskIdToListId for large dataset
      largeMockColumns.forEach(column => {
        column.tasks.forEach(task => {
          mockStore.taskIdToListId.set(task.id, column.taskList.id);
        });
      });

      const startTime = Date.now();

      const { result } = renderHook(() => 
        useKanbanDrag(largeMockColumns, mockPendingOperations, mockProcessQueue)
      );

      const initTime = Date.now() - startTime;

      // Should initialize quickly even with large dataset
      expect(initTime).toBeLessThan(100); // 100ms max

      // Test drag operations
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-0-0', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      const dragStartTime = Date.now();

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      const dragOperationTime = Date.now() - dragStartTime;

      // Should handle drag operations quickly
      expect(dragOperationTime).toBeLessThan(50); // 50ms max
    });

    it('should handle large number of tasks efficiently', () => {
      const largeMockColumns = [
        {
          taskList: { id: 'list-1', title: 'Large List' },
          tasks: Array.from({ length: 1000 }, (_, i) => ({
            id: `task-${i}`,
            title: `Task ${i}`,
            status: 'needsAction',
          })),
        },
      ];

      // Update taskIdToListId for large dataset
      largeMockColumns[0].tasks.forEach(task => {
        mockStore.taskIdToListId.set(task.id, 'list-1');
      });

      const { result } = renderHook(() => 
        useKanbanDrag(largeMockColumns, mockPendingOperations, mockProcessQueue)
      );

      // Test drag operations performance
      const dragStartEvent: DragStartEvent = {
        active: { id: 'task-500', data: { current: {} }, rect: { current: {} } },
        over: null,
      };

      const startTime = Date.now();

      act(() => {
        result.current.handleDragStart(dragStartEvent);
      });

      const operationTime = Date.now() - startTime;

      // Should handle large lists efficiently
      expect(operationTime).toBeLessThan(100); // 100ms max
    });
  });
}); 

END OF FILE: src/features/tasks/tests/drag-drop.test.ts


====================================================================================================
FILE: src/features/tasks/tests/error-handling.test.ts
DESCRIPTION: Error handling tests
====================================================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { act, renderHook, waitFor } from '@testing-library/react';
import { useGoogleStore } from '../../../stores/googleStore';
import { useTaskMetadataStore } from '../../../stores/taskMetadataStore';
import { prepareTaskForAPI, setTaskMetadata, getTaskMetadata } from '../utils/taskHelpers';
import { useTaskSyncQueue } from '../hooks/useTaskSyncQueue';
import { invoke } from '@tauri-apps/api/core';

// Mock console methods
const mockConsole = {
  log: vi.fn(),
  error: vi.fn(),
  warn: vi.fn(),
};

beforeEach(() => {
  vi.spyOn(console, 'log').mockImplementation(mockConsole.log);
  vi.spyOn(console, 'error').mockImplementation(mockConsole.error);
  vi.spyOn(console, 'warn').mockImplementation(mockConsole.warn);
});

afterEach(() => {
  vi.restoreAllMocks();
  mockConsole.log.mockClear();
  mockConsole.error.mockClear();
  mockConsole.warn.mockClear();
});

describe('Error Handling Tests', () => {
  let googleStore: any;
  let metadataStore: any;

  beforeEach(() => {
    // Reset stores
    googleStore = useGoogleStore.getState();
    metadataStore = useTaskMetadataStore.getState();
    
    // Clear stores
    googleStore.reset?.();
    metadataStore.clearAllMetadata();
    
    // Set up mock account
    googleStore.setActiveAccount({
      id: 'test-account',
      email: 'test@example.com',
      name: 'Test User',
      accessToken: 'test-token',
      refreshToken: 'refresh-token',
      expiresAt: Date.now() + 3600000,
    });
    
    // Initialize kanban columns with required task lists using store methods
    const storeState = useGoogleStore.getState();
    const storeMethods = useGoogleStore.setState;
    
    // Use setState to properly initialize the store
    storeMethods({
      taskLists: [
        {
          id: 'list-1',
          title: 'Test List 1',
          updated: new Date().toISOString(),
          selfLink: 'https://example.com/list-1',
          etag: 'etag-1',
        },
        {
          id: 'list-2',
          title: 'Test List 2',
          updated: new Date().toISOString(),
          selfLink: 'https://example.com/list-2',
          etag: 'etag-2',
        },
      ],
      kanbanColumns: [
        {
          taskList: {
            id: 'list-1',
            title: 'Test List 1',
            updated: new Date().toISOString(),
            selfLink: 'https://example.com/list-1',
            etag: 'etag-1',
          },
          tasks: [],
        },
        {
          taskList: {
            id: 'list-2',
            title: 'Test List 2',
            updated: new Date().toISOString(),
            selfLink: 'https://example.com/list-2',
            etag: 'etag-2',
          },
          tasks: [],
        },
      ],
    });
  });

  describe('Network Error Handling', () => {
    it('should handle network timeout errors', async () => {
      // Mock network timeout
      vi.mocked(invoke).mockImplementationOnce(() => 
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Network timeout')), 100)
        )
      );

      const taskData = {
        title: 'Network Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Network timeout');
    });

    it('should handle connection refused errors', async () => {
      // Mock connection refused
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Connection refused'));

      const taskData = {
        title: 'Connection Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Connection refused');
    });

    it('should handle DNS resolution errors', async () => {
      // Mock DNS error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('DNS resolution failed'));

      const taskData = {
        title: 'DNS Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('DNS resolution failed');
    });

    it('should handle SSL certificate errors', async () => {
      // Mock SSL error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('SSL certificate invalid'));

      const taskData = {
        title: 'SSL Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('SSL certificate invalid');
    });

    it('should handle intermittent network failures', async () => {
      let callCount = 0;
      vi.mocked(invoke).mockImplementation(function() {
        callCount++;
        if (callCount === 1) {
          return Promise.reject(new Error('Network error'));
        }
        // Return a successful response for subsequent calls
        return Promise.resolve({
          success: true,
          data: {
            id: 'task-intermittent-' + Date.now(),
            title: 'Intermittent Test Task',
            notes: 'Test notes',
            status: 'needsAction',
            updated: new Date().toISOString(),
          }
        });
      });

      const taskData = {
        title: 'Intermittent Test Task',
        notes: 'Test notes',
      };

      // First call should fail
      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Network error');
      
      // Second call should succeed
      const result = await googleStore.createTask('list-1', taskData);
      expect(result).toBeDefined();
    });
  });

  describe('API Error Handling', () => {
    it('should handle 401 authentication errors', async () => {
      // Mock 401 error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('401: Unauthorized'));

      const taskData = {
        title: 'Auth Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('401: Unauthorized');
    });

    it('should handle 403 permission errors', async () => {
      // Mock 403 error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('403: Forbidden'));

      const taskData = {
        title: 'Permission Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('403: Forbidden');
    });

    it('should handle 404 not found errors', async () => {
      // Mock 404 error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('404: Not Found'));

      await expect(googleStore.updateTask('non-existent-list', 'task-1', {
        title: 'Updated Task',
      })).rejects.toThrow('404: Not Found');
    });

    it('should handle 429 rate limit errors', async () => {
      // Mock 429 error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('429: Too Many Requests'));

      const taskData = {
        title: 'Rate Limit Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('429: Too Many Requests');
    });

    it('should handle 500 internal server errors', async () => {
      // Mock 500 error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('500: Internal Server Error'));

      const taskData = {
        title: 'Server Error Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('500: Internal Server Error');
    });

    it('should handle malformed API responses', async () => {
      // Mock malformed response
      vi.mocked(invoke).mockResolvedValueOnce({
        invalid: 'response',
        missing: 'required fields',
      });

      const taskData = {
        title: 'Malformed Response Test',
        notes: 'Test notes',
      };

      const result = await googleStore.createTask('list-1', taskData);
      
      // Should handle gracefully
      expect(result).toEqual({
        invalid: 'response',
        missing: 'required fields',
      });
    });

    it('should handle null/undefined responses', async () => {
      // Mock null response
      vi.mocked(invoke).mockResolvedValueOnce(null);

      const taskData = {
        title: 'Null Response Test',
        notes: 'Test notes',
      };

      const result = await googleStore.createTask('list-1', taskData);
      expect(result).toBeNull();
    });
  });

  describe('Data Validation Error Handling', () => {
    it('should handle invalid task data', async () => {
      const invalidTaskData = {
        title: '', // Empty title
        notes: null, // Null notes
        due: 'invalid-date', // Invalid date format
      };

      // Mock validation error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Invalid task data'));

      await expect(googleStore.createTask('list-1', invalidTaskData)).rejects.toThrow('Invalid task data');
    });

    it('should handle missing required fields', async () => {
      const incompleteTaskData = {
        // Missing title
        notes: 'Test notes',
      };

      // Mock validation error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Missing required field: title'));

      await expect(googleStore.createTask('list-1', incompleteTaskData)).rejects.toThrow('Missing required field: title');
    });

    it('should handle invalid date formats', async () => {
      const taskDataWithInvalidDate = {
        title: 'Invalid Date Test',
        notes: 'Test notes',
        due: 'not-a-date',
      };

      // Mock date validation error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Invalid date format'));

      await expect(googleStore.createTask('list-1', taskDataWithInvalidDate)).rejects.toThrow('Invalid date format');
    });

    it('should handle oversized data', async () => {
      const oversizedTaskData = {
        title: 'A'.repeat(10000), // Very long title
        notes: 'B'.repeat(100000), // Very long notes
      };

      // Mock size validation error
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Data too large'));

      await expect(googleStore.createTask('list-1', oversizedTaskData)).rejects.toThrow('Data too large');
    });

    it('should handle special characters in data', async () => {
      const taskDataWithSpecialChars = {
        title: 'Test Task 🚀 with émojis and àccénts',
        notes: 'Notes with <script>alert("xss")</script> and other special chars: ♠♣♥♦',
      };

      // Should handle special characters gracefully
      const result = await googleStore.createTask('list-1', taskDataWithSpecialChars);
      expect(result).toBeDefined();
    });
  });

  describe('Store Error Handling', () => {
    it('should handle store corruption', async () => {
      // Corrupt the store state
      googleStore.taskLists = null;
      googleStore.kanbanColumns = undefined;

      // Should handle gracefully
      expect(() => googleStore.fetchTaskLists()).not.toThrow();
    });

    it('should handle metadata store corruption', async () => {
      // Corrupt metadata store
      metadataStore.metadata = null;

      // Should handle gracefully
      expect(() => setTaskMetadata('task-1', { priority: 'high' })).not.toThrow();
    });

    it('should handle store method failures', async () => {
      // Mock store method failure
      const originalCreateTask = googleStore.createTask;
      googleStore.createTask = vi.fn().mockImplementation(async () => {
        throw new Error('Store method failed');
      });

      await expect(googleStore.createTask('list-1', {
        title: 'Test Task',
      })).rejects.toThrow('Store method failed');

      // Restore original method
      googleStore.createTask = originalCreateTask;
    });

    it('should handle concurrent store updates', async () => {
      const taskData = {
        title: 'Concurrent Test Task',
        notes: 'Test notes',
      };

      // Create task first
      const task = await googleStore.createTask('list-1', taskData);

      // Perform concurrent updates
      const updatePromises = [
        googleStore.updateTask('list-1', task.id, { title: 'Update 1' }),
        googleStore.updateTask('list-1', task.id, { title: 'Update 2' }),
        googleStore.updateTask('list-1', task.id, { title: 'Update 3' }),
      ];

      // Some updates may fail, but shouldn't crash the store
      const results = await Promise.allSettled(updatePromises);
      
      // At least one should succeed
      const successCount = results.filter(r => r.status === 'fulfilled').length;
      expect(successCount).toBeGreaterThan(0);
    });

    it('should handle memory exhaustion', async () => {
      // Create many tasks to simulate memory pressure
      const tasks = Array.from({ length: 1000 }, (_, i) => ({
        title: `Task ${i}`,
        notes: `Notes ${i}`,
      }));

      // Should handle large operations gracefully
      const createPromises = tasks.map(task => 
        googleStore.createTask('list-1', task).catch(() => null)
      );

      const results = await Promise.allSettled(createPromises);
      
      // Should not crash completely
      expect(results.length).toBe(1000);
    });
  });

  describe('Worker Error Handling', () => {
    it('should handle worker initialization failure', async () => {
      // Mock worker creation failure
      const originalWorker = global.Worker;
      global.Worker = class MockFailingWorker {
        constructor() {
          throw new Error('Worker failed to initialize');
        }
      } as any;

      const mockAddToast = vi.fn();
      
      // Should handle worker failure gracefully
      expect(() => {
        const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
        return result.current;
      }).not.toThrow();

      // Restore original Worker
      global.Worker = originalWorker;
    });

    it('should handle worker message errors', async () => {
      const mockAddToast = vi.fn();
      
      // Mock worker that sends error messages
      const mockWorker = {
        postMessage: vi.fn(),
        addEventListener: vi.fn(),
        terminate: vi.fn(),
      };

      global.Worker = vi.fn().mockImplementation(() => mockWorker);

      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Simulate worker error message
      const errorHandler = vi.mocked(mockWorker.addEventListener).mock.calls
        .find(call => call[0] === 'error')?.[1];
      
      if (errorHandler) {
        errorHandler(new ErrorEvent('error', { message: 'Worker error' }));
      }

      // Should handle gracefully
      expect(result.current.isSyncing).toBe(false);
    });

    it('should handle worker termination', async () => {
      const mockAddToast = vi.fn();
      
      const mockWorker = {
        postMessage: vi.fn(),
        addEventListener: vi.fn(),
        terminate: vi.fn(),
      };

      global.Worker = vi.fn().mockImplementation(() => mockWorker);

      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Terminate worker
      mockWorker.terminate();

      // Should handle gracefully
      expect(result.current.isSyncing).toBe(false);
    });

    it('should handle worker timeout', async () => {
      const mockAddToast = vi.fn();
      
      const mockWorker = {
        postMessage: vi.fn(),
        addEventListener: vi.fn(),
        terminate: vi.fn(),
      };

      global.Worker = vi.fn().mockImplementation(() => mockWorker);

      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Add operation to queue
      act(() => {
        result.current.pendingOperations.current.push({
          taskId: 'task-1',
          sourceListId: 'list-1',
          targetListId: 'list-2',
          operationId: 'op-1',
        });
        result.current.processQueue();
      });

      // Worker doesn't respond (timeout scenario)
      await new Promise(resolve => setTimeout(resolve, 100));

      // Should handle timeout gracefully
      expect(result.current.isSyncing).toBe(true); // Still syncing as no response
    });
  });

  describe('Optimistic Update Error Handling', () => {
    it('should handle optimistic update failure', async () => {
      // Create task
      const taskData = {
        title: 'Optimistic Test Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);
      
      // Check if task is in store after creation
      const taskAfterCreation = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === task.id);
      console.log('2. Task in store after creation:', taskAfterCreation);

      // Apply optimistic update
      const updatedData = {
        title: 'Optimistically Updated Task',
        notes: 'Updated notes',
      };

      // DEBUGGING: Check store state before optimistic update
      const beforeUpdate = {
        columns: googleStore.kanbanColumns.map(c => ({ 
          id: c.taskList.id, 
          taskCount: c.tasks.length,
          taskIds: c.tasks.map(t => t.id),
          taskTitles: c.tasks.map(t => t.title)
        })),
        targetTask: googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks.find(t => t.id === task.id),
        taskIdExists: !!task.id,
        list1Exists: !!googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
      };
      
      googleStore.optimisticUpdateTask('list-1', task.id, updatedData);
      
      // DEBUGGING: Check store state after optimistic update
      const afterUpdate = {
        columns: googleStore.kanbanColumns.map(c => ({ 
          id: c.taskList.id, 
          taskCount: c.tasks.length,
          taskIds: c.tasks.map(t => t.id),
          taskTitles: c.tasks.map(t => t.title)
        })),
        targetTask: googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks.find(t => t.id === task.id)
      };
      
      // If task disappeared, throw detailed error
      if (!afterUpdate.targetTask) {
        throw new Error(`Task disappeared after optimistic update!
Before: ${JSON.stringify(beforeUpdate, null, 2)}
After: ${JSON.stringify(afterUpdate, null, 2)}
Task ID: ${task.id}
Updates: ${JSON.stringify(updatedData, null, 2)}`);
      }
      
      // ASSERTION 1: Check if task is in store after optimistic update
      const taskAfterOptimistic = afterUpdate.targetTask;
      
      // This should pass - optimistic update should work
      expect(taskAfterOptimistic).toBeDefined();
      expect(taskAfterOptimistic?.title).toBe('Optimistically Updated Task');
      
      // ASSERTION 2: Verify task count and structure before API call
      const list1BeforeAPI = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1');
      expect(list1BeforeAPI?.tasks.length).toBeGreaterThan(0);
      expect(list1BeforeAPI?.tasks.some(t => t.id === task.id)).toBe(true);

      // Mock update failure
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Update failed'));

      // Attempt actual update
      await expect(googleStore.updateTask('list-1', task.id, updatedData))
        .rejects.toThrow('Update failed');

      // ASSERTION 3: Verify state immediately after API failure
      const list1AfterAPI = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1');
      const taskAfterFailure = list1AfterAPI?.tasks.find(t => t.id === task.id);
      
      // DEBUGGING: Show what's actually in the store
      if (!taskAfterFailure) {
        // Task disappeared - let's see what's in the store
        const allTasks = googleStore.kanbanColumns.map(c => ({
          listId: c.taskList.id,
          taskCount: c.tasks.length,
          taskIds: c.tasks.map(t => t.id)
        }));
        
        const mapEntries = Array.from(googleStore.taskIdToListId.entries());
        
        throw new Error(`Task disappeared! Store state: ${JSON.stringify({ allTasks, mapEntries, targetTaskId: task.id }, null, 2)}`);
      }

      // Optimistic update should remain (rollback logic would need implementation)
      const updatedTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === task.id);
      
      expect(updatedTask?.title).toBe('Optimistically Updated Task');
    });

    it('should handle optimistic move failure', async () => {
      // Create task
      const taskData = {
        title: 'Move Test Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Apply optimistic move
      googleStore.optimisticMoveTask(task.id, 'list-1', 'list-2');

      // Mock move failure
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Move failed'));

      // Attempt actual move
      await expect(googleStore.moveTask(task.id, 'list-1', 'list-2', {}))
        .rejects.toThrow('Move failed');

      // Task should remain in target list (rollback logic would need implementation)
      const targetListTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-2')?.tasks;
      expect(targetListTasks?.find(t => t.id === task.id)).toBeDefined();
    });

    it('should handle optimistic reorder failure', async () => {
      // Create tasks
      const task1 = await googleStore.createTask('list-1', { title: 'Task 1' });
      const task2 = await googleStore.createTask('list-1', { title: 'Task 2' });

      // Apply optimistic reorder
      googleStore.optimisticReorderTask('list-1', task1.id, task2.id);

      // Mock reorder failure (if such operation exists)
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Reorder failed'));

      // Verify tasks still exist
      const listTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      expect(listTasks?.find(t => t.id === task1.id)).toBeDefined();
      expect(listTasks?.find(t => t.id === task2.id)).toBeDefined();
    });
  });

  describe('Metadata Error Handling', () => {
    it('should handle metadata serialization errors', async () => {
      const taskData = {
        title: 'Metadata Test Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Create circular reference that would cause serialization error
      const circularObject: any = { priority: 'high' };
      circularObject.self = circularObject;

      // Should handle gracefully
      expect(() => setTaskMetadata(task.id, circularObject)).not.toThrow();
    });

    it('should handle metadata deserialization errors', async () => {
      // Set corrupted metadata in localStorage
      localStorage.setItem('task-metadata-store', 'invalid json');

      // Should handle gracefully
      expect(() => getTaskMetadata('task-1')).not.toThrow();
    });

    it('should handle metadata store unavailability', async () => {
      // Mock localStorage unavailable
      const originalLocalStorage = global.localStorage;
      delete (global as any).localStorage;

      // Should handle gracefully
      expect(() => setTaskMetadata('task-1', { priority: 'high' })).not.toThrow();

      // Restore localStorage
      global.localStorage = originalLocalStorage;
    });

    it('should handle metadata quota exceeded', async () => {
      // Mock quota exceeded error
      const originalSetItem = localStorage.setItem;
      localStorage.setItem = vi.fn().mockImplementation(() => {
        throw new Error('QuotaExceededError');
      });

      // Should handle gracefully
      expect(() => setTaskMetadata('task-1', { priority: 'high' })).not.toThrow();

      // Restore original method
      localStorage.setItem = originalSetItem;
    });
  });

  describe('Recovery Mechanisms', () => {
    it('should retry failed operations', async () => {
      let attemptCount = 0;
      vi.mocked(invoke).mockImplementation(() => {
        attemptCount++;
        if (attemptCount < 3) {
          return Promise.reject(new Error('Temporary failure'));
        }
        return Promise.resolve({
          id: 'task-1',
          title: 'Recovered Task',
          status: 'needsAction',
        });
      });

      const taskData = {
        title: 'Retry Test Task',
        notes: 'Test notes',
      };

      // First two attempts should fail, third should succeed
      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Temporary failure');
      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Temporary failure');
      const result = await googleStore.createTask('list-1', taskData);
      
      expect(result.title).toBe('Recovered Task');
    });

    it('should handle graceful degradation', async () => {
      // Mock all operations failing
      vi.mocked(invoke).mockRejectedValue(new Error('All operations failing'));

      // Store should still be usable for read operations
      expect(googleStore.kanbanColumns).toBeDefined();
      expect(googleStore.taskLists).toBeDefined();
    });

    it('should handle data consistency after errors', async () => {
      const taskData = {
        title: 'Consistency Test Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Set metadata
      setTaskMetadata(task.id, { priority: 'high' });

      // Simulate error that might cause inconsistency
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Consistency error'));

      // Attempt operation that fails
      await expect(googleStore.updateTask('list-1', task.id, { title: 'Updated' }))
        .rejects.toThrow('Consistency error');

      // Data should remain consistent
      const metadata = getTaskMetadata(task.id);
      expect(metadata?.priority).toBe('high');
    });

    it('should handle error propagation', async () => {
      const taskData = {
        title: 'Error Propagation Test',
        notes: 'Test notes',
      };

      // Mock cascading errors
      vi.mocked(invoke).mockImplementation((command) => {
        if (command === 'create_task') {
          return Promise.reject(new Error('Create failed'));
        }
        if (command === 'update_task') {
          return Promise.reject(new Error('Update failed'));
        }
        return Promise.resolve({});
      });

      // All operations should fail with appropriate errors
      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Create failed');
      await expect(googleStore.updateTask('list-1', 'task-1', taskData)).rejects.toThrow('Update failed');
    });

    it('should handle error logging', async () => {
      const taskData = {
        title: 'Error Logging Test',
        notes: 'Test notes',
      };

      // Mock error that should be logged
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Logged error'));

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Logged error');

      // Error should be logged
      expect(mockConsole.error).toHaveBeenCalled();
    });
  });

  describe('Edge Case Error Handling', () => {
    it('should handle null/undefined task IDs', async () => {
      // Should handle gracefully
      expect(() => googleStore.updateTask('list-1', null, { title: 'Test' }))
        .not.toThrow();
      expect(() => googleStore.updateTask('list-1', undefined, { title: 'Test' }))
        .not.toThrow();
    });

    it('should handle empty string task IDs', async () => {
      // Should handle gracefully
      expect(() => googleStore.updateTask('list-1', '', { title: 'Test' }))
        .not.toThrow();
    });

    it('should handle very long task IDs', async () => {
      const longTaskId = 'a'.repeat(1000);
      
      // Should handle gracefully
      expect(() => googleStore.updateTask('list-1', longTaskId, { title: 'Test' }))
        .not.toThrow();
    });

    it('should handle special characters in task IDs', async () => {
      const specialTaskId = 'task-!@#$%^&*()_+-=[]{}|;:,.<>?';
      
      // Should handle gracefully
      expect(() => googleStore.updateTask('list-1', specialTaskId, { title: 'Test' }))
        .not.toThrow();
    });

    it('should handle unicode characters in task data', async () => {
      const unicodeTaskData = {
        title: '🚀 Unicode Task 中文 العربية',
        notes: 'Notes with unicode: ♠♣♥♦ αβγδ',
      };

      const result = await googleStore.createTask('list-1', unicodeTaskData);
      expect(result).toBeDefined();
    });

    it('should handle extreme date values', async () => {
      const extremeTaskData = {
        title: 'Extreme Date Test',
        notes: 'Test notes',
        due: '9999-12-31T23:59:59.999Z', // Far future date
      };

      const result = await googleStore.createTask('list-1', extremeTaskData);
      expect(result).toBeDefined();
    });

    it('should handle negative date values', async () => {
      const negativeTaskData = {
        title: 'Negative Date Test',
        notes: 'Test notes',
        due: '1900-01-01T00:00:00.000Z', // Far past date
      };

      const result = await googleStore.createTask('list-1', negativeTaskData);
      expect(result).toBeDefined();
    });
  });
}); 


END OF FILE: src/features/tasks/tests/error-handling.test.ts


====================================================================================================
FILE: src/features/tasks/tests/metadata-store.test.ts
DESCRIPTION: Metadata store tests
====================================================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { useTaskMetadataStore } from '../../../stores/taskMetadataStore';
import { encodeEnhancedTaskData, parseEnhancedTaskData, cleanTaskNotes } from '../utils/taskHelpers';

// Mock localStorage for testing
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value;
    },
    removeItem: (key: string) => {
      delete store[key];
    },
    clear: () => {
      store = {};
    },
  };
})();

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
});

describe('Task Metadata Store Tests', () => {
  let metadataStore: any;

  beforeEach(() => {
    // Clear localStorage before each test
    localStorageMock.clear();
    
    // Reset the store
    metadataStore = useTaskMetadataStore.getState();
    metadataStore.clearAllMetadata();
  });

  afterEach(() => {
    // Clean up after each test
    metadataStore.clearAllMetadata();
  });

  describe('Basic Metadata Operations', () => {
    it('should set and get task metadata', () => {
      const taskId = 'test-task-1';
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [],
        recurring: {
          enabled: false,
          frequency: 'weekly',
          interval: 1,
          endDate: '',
        },
      };

      metadataStore.setTaskMetadata(taskId, metadata);
      const retrieved = metadataStore.getTaskMetadata(taskId);

      expect(retrieved).toBeDefined();
      expect(retrieved.priority).toBe('high');
      expect(retrieved.labels).toEqual(['urgent', 'work']);
      expect(retrieved.subtasks).toEqual([]);
      expect(retrieved.recurring.enabled).toBe(false);
    });

    it('should return null for non-existent task metadata', () => {
      const result = metadataStore.getTaskMetadata('non-existent-task');
      expect(result).toBeNull();
    });

    it('should update existing metadata', () => {
      const taskId = 'test-task-2';
      
      // Set initial metadata
      metadataStore.setTaskMetadata(taskId, {
        priority: 'normal',
        labels: ['task'],
      });

      // Update with new values
      metadataStore.setTaskMetadata(taskId, {
        priority: 'high',
        labels: ['urgent', 'important'],
        subtasks: [{ id: '1', title: 'Subtask', completed: false, due: '' }],
      });

      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.priority).toBe('high');
      expect(retrieved.labels).toEqual(['urgent', 'important']);
      expect(retrieved.subtasks).toHaveLength(1);
    });

    it('should delete task metadata', () => {
      const taskId = 'test-task-3';
      
      // Set metadata
      metadataStore.setTaskMetadata(taskId, {
        priority: 'high',
        labels: ['test'],
      });

      // Verify it exists
      expect(metadataStore.getTaskMetadata(taskId)).toBeDefined();

      // Delete it
      metadataStore.deleteTaskMetadata(taskId);

      // Verify it's gone
      expect(metadataStore.getTaskMetadata(taskId)).toBeNull();
    });

    it('should clear all metadata', () => {
      const taskIds = ['task-1', 'task-2', 'task-3'];
      
      // Set metadata for multiple tasks
      taskIds.forEach(taskId => {
        metadataStore.setTaskMetadata(taskId, {
          priority: 'normal',
          labels: ['test'],
        });
      });

      // Verify all exist
      taskIds.forEach(taskId => {
        expect(metadataStore.getTaskMetadata(taskId)).toBeDefined();
      });

      // Clear all
      metadataStore.clearAllMetadata();

      // Verify all are gone
      taskIds.forEach(taskId => {
        expect(metadataStore.getTaskMetadata(taskId)).toBeNull();
      });
    });
  });

  describe('Priority Management', () => {
    it('should handle all priority levels', () => {
      const priorities = ['low', 'normal', 'high'];
      
      priorities.forEach((priority, index) => {
        const taskId = `priority-task-${index}`;
        metadataStore.setTaskMetadata(taskId, { priority });
        
        const retrieved = metadataStore.getTaskMetadata(taskId);
        expect(retrieved.priority).toBe(priority);
      });
    });

    it('should default to normal priority', () => {
      const taskId = 'default-priority-task';
      metadataStore.setTaskMetadata(taskId, { labels: ['test'] });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.priority).toBe('normal');
    });

    it('should update priority independently', () => {
      const taskId = 'priority-update-task';
      
      // Set initial data
      metadataStore.setTaskMetadata(taskId, {
        priority: 'low',
        labels: ['initial'],
      });

      // Update only priority
      metadataStore.setTaskMetadata(taskId, { priority: 'high' });

      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.priority).toBe('high');
      expect(retrieved.labels).toEqual(['initial']); // Should preserve other fields
    });
  });

  describe('Label Management', () => {
    it('should handle empty labels array', () => {
      const taskId = 'empty-labels-task';
      metadataStore.setTaskMetadata(taskId, { labels: [] });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.labels).toEqual([]);
    });

    it('should handle single label', () => {
      const taskId = 'single-label-task';
      metadataStore.setTaskMetadata(taskId, { labels: ['work'] });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.labels).toEqual(['work']);
    });

    it('should handle multiple labels', () => {
      const taskId = 'multiple-labels-task';
      const labels = ['urgent', 'work', 'important', 'meeting'];
      
      metadataStore.setTaskMetadata(taskId, { labels });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.labels).toEqual(labels);
    });

    it('should handle label updates', () => {
      const taskId = 'label-update-task';
      
      // Set initial labels
      metadataStore.setTaskMetadata(taskId, { labels: ['initial'] });

      // Update labels
      metadataStore.setTaskMetadata(taskId, { labels: ['updated', 'new'] });

      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.labels).toEqual(['updated', 'new']);
    });

    it('should handle duplicate labels', () => {
      const taskId = 'duplicate-labels-task';
      const labels = ['work', 'work', 'urgent', 'work'];
      
      metadataStore.setTaskMetadata(taskId, { labels });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.labels).toEqual(labels); // Store should preserve duplicates
    });
  });

  describe('Subtask Management', () => {
    it('should handle empty subtasks array', () => {
      const taskId = 'empty-subtasks-task';
      metadataStore.setTaskMetadata(taskId, { subtasks: [] });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.subtasks).toEqual([]);
    });

    it('should handle single subtask', () => {
      const taskId = 'single-subtask-task';
      const subtask = { id: '1', title: 'Subtask 1', completed: false, due: '' };
      
      metadataStore.setTaskMetadata(taskId, { subtasks: [subtask] });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.subtasks).toHaveLength(1);
      expect(retrieved.subtasks[0]).toEqual(subtask);
    });

    it('should handle multiple subtasks', () => {
      const taskId = 'multiple-subtasks-task';
      const subtasks = [
        { id: '1', title: 'Subtask 1', completed: false, due: '' },
        { id: '2', title: 'Subtask 2', completed: true, due: '2024-12-31' },
        { id: '3', title: 'Subtask 3', completed: false, due: '2025-01-15' },
      ];
      
      metadataStore.setTaskMetadata(taskId, { subtasks });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.subtasks).toHaveLength(3);
      expect(retrieved.subtasks).toEqual(subtasks);
    });

    it('should handle subtask updates', () => {
      const taskId = 'subtask-update-task';
      
      // Set initial subtasks
      const initialSubtasks = [
        { id: '1', title: 'Initial Subtask', completed: false, due: '' },
      ];
      metadataStore.setTaskMetadata(taskId, { subtasks: initialSubtasks });

      // Update subtasks
      const updatedSubtasks = [
        { id: '1', title: 'Updated Subtask', completed: true, due: '2024-12-31' },
        { id: '2', title: 'New Subtask', completed: false, due: '' },
      ];
      metadataStore.setTaskMetadata(taskId, { subtasks: updatedSubtasks });

      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.subtasks).toEqual(updatedSubtasks);
    });

    it('should handle subtask completion status', () => {
      const taskId = 'subtask-completion-task';
      const subtasks = [
        { id: '1', title: 'Completed Subtask', completed: true, due: '' },
        { id: '2', title: 'Incomplete Subtask', completed: false, due: '' },
      ];
      
      metadataStore.setTaskMetadata(taskId, { subtasks });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.subtasks[0].completed).toBe(true);
      expect(retrieved.subtasks[1].completed).toBe(false);
    });

    it('should handle subtask due dates', () => {
      const taskId = 'subtask-due-task';
      const subtasks = [
        { id: '1', title: 'Subtask with due date', completed: false, due: '2024-12-31' },
        { id: '2', title: 'Subtask without due date', completed: false, due: '' },
      ];
      
      metadataStore.setTaskMetadata(taskId, { subtasks });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.subtasks[0].due).toBe('2024-12-31');
      expect(retrieved.subtasks[1].due).toBe('');
    });
  });

  describe('Recurring Task Management', () => {
    it('should handle disabled recurring tasks', () => {
      const taskId = 'non-recurring-task';
      const recurring = {
        enabled: false,
        frequency: 'weekly',
        interval: 1,
        endDate: '',
      };
      
      metadataStore.setTaskMetadata(taskId, { recurring });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.recurring.enabled).toBe(false);
    });

    it('should handle enabled recurring tasks', () => {
      const taskId = 'recurring-task';
      const recurring = {
        enabled: true,
        frequency: 'weekly',
        interval: 2,
        endDate: '2024-12-31',
      };
      
      metadataStore.setTaskMetadata(taskId, { recurring });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.recurring.enabled).toBe(true);
      expect(retrieved.recurring.frequency).toBe('weekly');
      expect(retrieved.recurring.interval).toBe(2);
      expect(retrieved.recurring.endDate).toBe('2024-12-31');
    });

    it('should handle different recurrence frequencies', () => {
      const frequencies = ['daily', 'weekly', 'monthly'];
      
      frequencies.forEach((frequency, index) => {
        const taskId = `recurring-${frequency}-task`;
        const recurring = {
          enabled: true,
          frequency,
          interval: 1,
          endDate: '',
        };
        
        metadataStore.setTaskMetadata(taskId, { recurring });
        
        const retrieved = metadataStore.getTaskMetadata(taskId);
        expect(retrieved.recurring.frequency).toBe(frequency);
      });
    });

    it('should handle recurrence intervals', () => {
      const taskId = 'recurrence-interval-task';
      const intervals = [1, 2, 3, 5, 10];
      
      intervals.forEach(interval => {
        const recurring = {
          enabled: true,
          frequency: 'weekly',
          interval,
          endDate: '',
        };
        
        metadataStore.setTaskMetadata(taskId, { recurring });
        
        const retrieved = metadataStore.getTaskMetadata(taskId);
        expect(retrieved.recurring.interval).toBe(interval);
      });
    });

    it('should handle recurrence end dates', () => {
      const taskId = 'recurrence-end-task';
      const endDate = '2024-12-31';
      
      const recurring = {
        enabled: true,
        frequency: 'weekly',
        interval: 1,
        endDate,
      };
      
      metadataStore.setTaskMetadata(taskId, { recurring });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.recurring.endDate).toBe(endDate);
    });
  });

  describe('Notes Field Integration', () => {
    it('should import metadata from notes field', () => {
      const taskId = 'import-notes-task';
      const notesWithMetadata = 'Task notes [LibreOllama:{"priority":"high","labels":["urgent","work"],"subtasks":[{"id":"1","title":"Subtask","completed":false,"due":""}]}]';
      
      metadataStore.importFromNotesField(taskId, notesWithMetadata);
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.priority).toBe('high');
      expect(retrieved.labels).toEqual(['urgent', 'work']);
      expect(retrieved.subtasks).toHaveLength(1);
    });

    it('should handle notes without metadata', () => {
      const taskId = 'no-metadata-task';
      const notesWithoutMetadata = 'Just plain task notes';
      
      metadataStore.importFromNotesField(taskId, notesWithoutMetadata);
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved).toBeNull(); // No metadata should be created
    });

    it('should handle malformed metadata in notes', () => {
      const taskId = 'malformed-metadata-task';
      const notesWithMalformedMetadata = 'Task notes [LibreOllama:invalid json}]';
      
      metadataStore.importFromNotesField(taskId, notesWithMalformedMetadata);
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved).toBeNull(); // Should handle gracefully
    });

    it('should export metadata to notes field', () => {
      const taskId = 'export-notes-task';
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [{ id: '1', title: 'Subtask', completed: false, due: '' }],
        recurring: {
          enabled: true,
          frequency: 'weekly',
          interval: 1,
          endDate: '',
        },
      };
      
      metadataStore.setTaskMetadata(taskId, metadata);
      const exported = metadataStore.exportToNotesField(taskId);
      
      expect(exported).toContain('[LibreOllama:');
      expect(exported).toContain('"priority":"high"');
      expect(exported).toContain('"labels":["urgent","work"]');
      expect(exported).toContain('"subtasks":[');
      expect(exported).toContain('"recurring":{');
    });

    it('should return empty string for non-existent task export', () => {
      const exported = metadataStore.exportToNotesField('non-existent-task');
      expect(exported).toBe('');
    });

    it('should handle import/export roundtrip', () => {
      const taskId = 'roundtrip-task';
      const originalMetadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [{ id: '1', title: 'Subtask', completed: false, due: '' }],
        recurring: {
          enabled: true,
          frequency: 'weekly',
          interval: 2,
          endDate: '2024-12-31',
        },
      };
      
      // Set original metadata
      metadataStore.setTaskMetadata(taskId, originalMetadata);
      
      // Export to notes field
      const exported = metadataStore.exportToNotesField(taskId);
      
      // Clear metadata
      metadataStore.deleteTaskMetadata(taskId);
      
      // Import from notes field
      metadataStore.importFromNotesField(taskId, `Task notes ${exported}`);
      
      // Verify metadata was preserved
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.priority).toBe('high');
      expect(retrieved.labels).toEqual(['urgent', 'work']);
      expect(retrieved.subtasks).toHaveLength(1);
      expect(retrieved.recurring.enabled).toBe(true);
      expect(retrieved.recurring.frequency).toBe('weekly');
      expect(retrieved.recurring.interval).toBe(2);
      expect(retrieved.recurring.endDate).toBe('2024-12-31');
    });
  });

  describe('Persistence Tests', () => {
    it('should persist metadata to localStorage', () => {
      const taskId = 'persist-task';
      const metadata = {
        priority: 'high',
        labels: ['urgent'],
        subtasks: [],
        recurring: {
          enabled: false,
          frequency: 'weekly',
          interval: 1,
          endDate: '',
        },
      };
      
      metadataStore.setTaskMetadata(taskId, metadata);
      
      // Check that data was persisted
      const stored = localStorageMock.getItem('task-metadata-store');
      expect(stored).toBeDefined();
      expect(stored).toContain(taskId);
      expect(stored).toContain('"priority":"high"');
      expect(stored).toContain('"labels":["urgent"]');
    });

    it('should restore metadata from localStorage', () => {
      const taskId = 'restore-task';
      const metadata = {
        priority: 'high',
        labels: ['urgent'],
        subtasks: [],
        recurring: {
          enabled: false,
          frequency: 'weekly',
          interval: 1,
          endDate: '',
        },
      };
      
      // Set metadata
      metadataStore.setTaskMetadata(taskId, metadata);
      
      // Create a new store instance (simulating app restart)
      const newStore = useTaskMetadataStore.getState();
      
      // Verify data was restored
      const retrieved = newStore.getTaskMetadata(taskId);
      expect(retrieved.priority).toBe('high');
      expect(retrieved.labels).toEqual(['urgent']);
    });

    it('should handle corrupted localStorage data', () => {
      // Set corrupted data in localStorage
      localStorageMock.setItem('task-metadata-store', 'corrupted json data');
      
      // This should not crash the store
      expect(() => {
        useTaskMetadataStore.getState();
      }).not.toThrow();
    });
  });

  describe('Concurrent Access', () => {
    it('should handle concurrent metadata updates', () => {
      const taskId = 'concurrent-task';
      const updates = [
        { priority: 'high', labels: ['urgent'] },
        { priority: 'normal', labels: ['work'] },
        { priority: 'low', labels: ['personal'] },
      ];
      
      // Apply updates concurrently
      updates.forEach(update => {
        metadataStore.setTaskMetadata(taskId, update);
      });
      
      // Verify final state
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved).toBeDefined();
      expect(updates.map(u => u.priority)).toContain(retrieved.priority);
      expect(updates.map(u => u.labels)).toContainEqual(retrieved.labels);
    });

    it('should handle concurrent reads and writes', () => {
      const taskId = 'concurrent-rw-task';
      const initialMetadata = {
        priority: 'normal',
        labels: ['initial'],
      };
      
      metadataStore.setTaskMetadata(taskId, initialMetadata);
      
      // Concurrent reads
      const reads = Array.from({ length: 5 }, () => metadataStore.getTaskMetadata(taskId));
      
      // Concurrent writes
      const writes = Array.from({ length: 3 }, (_, i) => {
        metadataStore.setTaskMetadata(taskId, { priority: 'high', labels: [`update-${i}`] });
      });
      
      // All reads should return valid data
      reads.forEach(result => {
        expect(result).toBeDefined();
        expect(['normal', 'high']).toContain(result.priority);
      });
      
      // Final state should be from one of the writes
      const finalResult = metadataStore.getTaskMetadata(taskId);
      expect(finalResult.priority).toBe('high');
      expect(finalResult.labels[0]).toMatch(/update-\d/);
    });
  });

  describe('Memory Management', () => {
    it('should handle large numbers of tasks', () => {
      const taskCount = 1000;
      const taskIds = Array.from({ length: taskCount }, (_, i) => `task-${i}`);
      
      // Set metadata for all tasks
      taskIds.forEach(taskId => {
        metadataStore.setTaskMetadata(taskId, {
          priority: 'normal',
          labels: ['test'],
          subtasks: [],
        });
      });
      
      // Verify all tasks have metadata
      taskIds.forEach(taskId => {
        const retrieved = metadataStore.getTaskMetadata(taskId);
        expect(retrieved).toBeDefined();
        expect(retrieved.priority).toBe('normal');
      });
      
      // Clean up
      metadataStore.clearAllMetadata();
      
      // Verify all tasks were cleared
      taskIds.forEach(taskId => {
        expect(metadataStore.getTaskMetadata(taskId)).toBeNull();
      });
    });

    it('should handle task metadata with large data', () => {
      const taskId = 'large-data-task';
      const largeSubtasks = Array.from({ length: 100 }, (_, i) => ({
        id: `subtask-${i}`,
        title: `Subtask ${i} with a very long description that tests memory usage`,
        completed: i % 2 === 0,
        due: i % 3 === 0 ? '2024-12-31' : '',
      }));
      
      const largeLabels = Array.from({ length: 50 }, (_, i) => `label-${i}`);
      
      metadataStore.setTaskMetadata(taskId, {
        priority: 'high',
        labels: largeLabels,
        subtasks: largeSubtasks,
      });
      
      const retrieved = metadataStore.getTaskMetadata(taskId);
      expect(retrieved.subtasks).toHaveLength(100);
      expect(retrieved.labels).toHaveLength(50);
    });
  });

  describe('Timestamp Tracking', () => {
    it('should track lastUpdated timestamp', () => {
      const taskId = 'timestamp-task';
      const before = Date.now();
      
      metadataStore.setTaskMetadata(taskId, {
        priority: 'high',
        labels: ['test'],
      });
      
      const after = Date.now();
      const retrieved = metadataStore.getTaskMetadata(taskId);
      
      expect(retrieved.lastUpdated).toBeGreaterThanOrEqual(before);
      expect(retrieved.lastUpdated).toBeLessThanOrEqual(after);
    });

    it('should update timestamp on metadata changes', async () => {
      const taskId = 'timestamp-update-task';
      
      // Set initial metadata
      metadataStore.setTaskMetadata(taskId, { priority: 'normal' });
      const initialTimestamp = metadataStore.getTaskMetadata(taskId).lastUpdated;
      
      // Wait a bit to ensure timestamp difference
      await new Promise(resolve => setTimeout(resolve, 10));
      
      // Update metadata
      metadataStore.setTaskMetadata(taskId, { priority: 'high' });
      const updatedTimestamp = metadataStore.getTaskMetadata(taskId).lastUpdated;
      
      expect(updatedTimestamp).toBeGreaterThan(initialTimestamp);
    });
  });
}); 

END OF FILE: src/features/tasks/tests/metadata-store.test.ts


====================================================================================================
FILE: src/features/tasks/tests/race-conditions.test.ts
DESCRIPTION: Race condition tests
====================================================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { act, renderHook, waitFor } from '@testing-library/react';
import { useGoogleStore } from '../../../stores/googleStore';
import { useTaskMetadataStore } from '../../../stores/taskMetadataStore';
import { setTaskMetadata, getTaskMetadata } from '../utils/taskHelpers';
import { useTaskSyncQueue } from '../hooks/useTaskSyncQueue';
import { invoke } from '@tauri-apps/api/core';

// Mock console methods
const mockConsole = {
  log: vi.fn(),
  error: vi.fn(),
  warn: vi.fn(),
};

beforeEach(() => {
  vi.spyOn(console, 'log').mockImplementation(mockConsole.log);
  vi.spyOn(console, 'error').mockImplementation(mockConsole.error);
  vi.spyOn(console, 'warn').mockImplementation(mockConsole.warn);
});

afterEach(() => {
  vi.restoreAllMocks();
  mockConsole.log.mockClear();
  mockConsole.error.mockClear();
  mockConsole.warn.mockClear();
});

describe('Race Conditions and Timing Tests', () => {
  let googleStore: any;
  let metadataStore: any;

  beforeEach(() => {
    // Reset stores
    googleStore = useGoogleStore.getState();
    metadataStore = useTaskMetadataStore.getState();
    
    // Clear stores
    googleStore.reset?.();
    metadataStore.clearAllMetadata();
    
    // Set up mock account
    googleStore.setActiveAccount({
      id: 'test-account',
      email: 'test@example.com',
      name: 'Test User',
      accessToken: 'test-token',
      refreshToken: 'refresh-token',
      expiresAt: Date.now() + 3600000,
    });
  });

  describe('Concurrent Task Operations', () => {
    it('should handle concurrent task creation', async () => {
      const taskData = [
        { title: 'Concurrent Task 1', notes: 'Notes 1' },
        { title: 'Concurrent Task 2', notes: 'Notes 2' },
        { title: 'Concurrent Task 3', notes: 'Notes 3' },
      ];

      // Create tasks concurrently
      const createPromises = taskData.map(data => 
        googleStore.createTask('list-1', data)
      );

      const results = await Promise.all(createPromises);
      
      // All tasks should be created successfully
      expect(results).toHaveLength(3);
      results.forEach((result, index) => {
        expect(result).toBeDefined();
        expect(result.title).toBe(taskData[index].title);
      });
    });

    it('should handle concurrent task updates', async () => {
      // Create a task first
      const taskData = {
        title: 'Original Task',
        notes: 'Original notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Perform concurrent updates
      const updateData = [
        { title: 'Update 1', notes: 'Notes 1' },
        { title: 'Update 2', notes: 'Notes 2' },
        { title: 'Update 3', notes: 'Notes 3' },
      ];

      const updatePromises = updateData.map(data => 
        googleStore.updateTask('list-1', task.id, data)
      );

      const results = await Promise.all(updatePromises);
      
      // All updates should succeed
      expect(results).toHaveLength(3);
      results.forEach((result, index) => {
        expect(result).toBeDefined();
        expect(result.title).toBe(updateData[index].title);
      });
    });

    it('should handle concurrent task deletions', async () => {
      // Create multiple tasks
      const taskData = [
        { title: 'Task to Delete 1', notes: 'Notes 1' },
        { title: 'Task to Delete 2', notes: 'Notes 2' },
        { title: 'Task to Delete 3', notes: 'Notes 3' },
      ];

      const tasks = await Promise.all(
        taskData.map(data => googleStore.createTask('list-1', data))
      );

      // Delete tasks concurrently
      const deletePromises = tasks.map(task => 
        googleStore.deleteTask('list-1', task.id)
      );

      await Promise.all(deletePromises);
      
      // All tasks should be deleted
      const remainingTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks || [];
      tasks.forEach(task => {
        expect(remainingTasks.find(t => t.id === task.id)).toBeUndefined();
      });
    });

    it('should handle concurrent task moves', async () => {
      // Create tasks in different lists
      const tasks = await Promise.all([
        googleStore.createTask('list-1', { title: 'Task 1' }),
        googleStore.createTask('list-1', { title: 'Task 2' }),
        googleStore.createTask('list-2', { title: 'Task 3' }),
      ]);

      // Move tasks concurrently
      const movePromises = [
        googleStore.moveTask(tasks[0].id, 'list-1', 'list-2', {}),
        googleStore.moveTask(tasks[1].id, 'list-1', 'list-3', {}),
        googleStore.moveTask(tasks[2].id, 'list-2', 'list-1', {}),
      ];

      const results = await Promise.all(movePromises);
      
      // All moves should succeed
      expect(results).toHaveLength(3);
      results.forEach(result => {
        expect(result).toBeDefined();
      });
    });

    it('should handle concurrent completion toggles', async () => {
      // Create tasks
      const tasks = await Promise.all([
        googleStore.createTask('list-1', { title: 'Task 1' }),
        googleStore.createTask('list-1', { title: 'Task 2' }),
        googleStore.createTask('list-1', { title: 'Task 3' }),
      ]);

      // Toggle completion concurrently
      const togglePromises = tasks.map(task => 
        googleStore.toggleTaskCompletion('list-1', task.id, true)
      );

      const results = await Promise.all(togglePromises);
      
      // All toggles should succeed
      expect(results).toHaveLength(3);
      results.forEach(result => {
        expect(result).toBeDefined();
        expect(result.status).toBe('completed');
      });
    });
  });

  describe('Metadata Store Race Conditions', () => {
    it('should handle concurrent metadata updates', async () => {
      const taskId = 'race-test-task';
      
      // Set metadata concurrently
      const metadataUpdates = [
        { priority: 'high', labels: ['urgent'] },
        { priority: 'normal', labels: ['work'] },
        { priority: 'low', labels: ['personal'] },
      ];

      const updatePromises = metadataUpdates.map(metadata => 
        Promise.resolve(setTaskMetadata(taskId, metadata))
      );

      await Promise.all(updatePromises);
      
      // Final metadata should be one of the updates
      const finalMetadata = getTaskMetadata(taskId);
      expect(finalMetadata).toBeDefined();
      expect(metadataUpdates.map(m => m.priority)).toContain(finalMetadata.priority);
    });

    it('should handle concurrent metadata read/write', async () => {
      const taskId = 'concurrent-rw-task';
      
      // Set initial metadata
      setTaskMetadata(taskId, { priority: 'normal', labels: ['initial'] });

      // Perform concurrent reads and writes
      const operations = [
        Promise.resolve(getTaskMetadata(taskId)),
        Promise.resolve(setTaskMetadata(taskId, { priority: 'high' })),
        Promise.resolve(getTaskMetadata(taskId)),
        Promise.resolve(setTaskMetadata(taskId, { labels: ['updated'] })),
        Promise.resolve(getTaskMetadata(taskId)),
      ];

      const results = await Promise.all(operations);
      
      // Reads should return valid metadata
      const readResults = results.filter((_, index) => index % 2 === 0);
      readResults.forEach(result => {
        expect(result).toBeDefined();
      });
    });

    it('should handle concurrent metadata import/export', async () => {
      const taskId = 'import-export-task';
      
      // Set initial metadata
      setTaskMetadata(taskId, {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [{ id: '1', title: 'Subtask', completed: false, due: '' }],
      });

      // Perform concurrent import/export operations
      const operations = [
        Promise.resolve(metadataStore.exportToNotesField(taskId)),
        Promise.resolve(metadataStore.importFromNotesField(taskId, 'Test notes [LibreOllama:{"priority":"low","labels":["imported"]}]')),
        Promise.resolve(metadataStore.exportToNotesField(taskId)),
        Promise.resolve(metadataStore.importFromNotesField(taskId, 'Test notes [LibreOllama:{"priority":"urgent","labels":["concurrent"]}]')),
      ];

      const results = await Promise.all(operations);
      
      // Should handle without crashing
      expect(results).toHaveLength(4);
      
      // Final metadata should be valid
      const finalMetadata = getTaskMetadata(taskId);
      expect(finalMetadata).toBeDefined();
    });
  });

  describe('Optimistic Update Race Conditions', () => {
    it('should handle optimistic update followed by API call', async () => {
      // Create task
      const taskData = {
        title: 'Optimistic Race Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Apply optimistic update immediately followed by API call
      const updatedData = {
        title: 'Optimistically Updated Task',
        notes: 'Updated notes',
      };

      googleStore.optimisticUpdateTask('list-1', task.id, updatedData);
      
      // Immediately try to update via API
      const apiUpdatePromise = googleStore.updateTask('list-1', task.id, updatedData);

      await apiUpdatePromise;
      
      // Task should have the updated data
      const finalTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === task.id);
      
      expect(finalTask?.title).toBe('Optimistically Updated Task');
    });

    it('should handle multiple optimistic updates', async () => {
      // Create task
      const taskData = {
        title: 'Multiple Optimistic Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Apply multiple optimistic updates rapidly
      const updates = [
        { title: 'Update 1', notes: 'Notes 1' },
        { title: 'Update 2', notes: 'Notes 2' },
        { title: 'Update 3', notes: 'Notes 3' },
      ];

      updates.forEach(update => {
        googleStore.optimisticUpdateTask('list-1', task.id, update);
      });

      // Final state should be the last update
      const finalTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === task.id);
      
      expect(finalTask?.title).toBe('Update 3');
    });

    it('should handle optimistic move race conditions', async () => {
      // Create task
      const taskData = {
        title: 'Move Race Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Apply multiple optimistic moves rapidly
      googleStore.optimisticMoveTask(task.id, 'list-1', 'list-2');
      googleStore.optimisticMoveTask(task.id, 'list-2', 'list-3');
      googleStore.optimisticMoveTask(task.id, 'list-3', 'list-1');

      // Task should be in the final location
      const finalLocation = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === task.id);
      
      expect(finalLocation).toBeDefined();
    });

    it('should handle optimistic reorder race conditions', async () => {
      // Create multiple tasks
      const tasks = await Promise.all([
        googleStore.createTask('list-1', { title: 'Task 1' }),
        googleStore.createTask('list-1', { title: 'Task 2' }),
        googleStore.createTask('list-1', { title: 'Task 3' }),
      ]);

      // Apply multiple optimistic reorders rapidly
      googleStore.optimisticReorderTask('list-1', tasks[0].id, tasks[1].id);
      googleStore.optimisticReorderTask('list-1', tasks[1].id, tasks[2].id);
      googleStore.optimisticReorderTask('list-1', tasks[2].id, tasks[0].id);

      // All tasks should still exist
      const listTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      tasks.forEach(task => {
        expect(listTasks?.find(t => t.id === task.id)).toBeDefined();
      });
    });
  });

  describe('Worker Queue Race Conditions', () => {
    it('should handle concurrent queue operations', async () => {
      const mockAddToast = vi.fn();
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));

      // Add multiple operations concurrently
      const operations = [
        {
          taskId: 'task-1',
          sourceListId: 'list-1',
          targetListId: 'list-2',
          operationId: 'op-1',
          originalTask: { title: 'Task 1' },
        },
        {
          taskId: 'task-2',
          sourceListId: 'list-1',
          targetListId: 'list-3',
          operationId: 'op-2',
          originalTask: { title: 'Task 2' },
        },
        {
          taskId: 'task-3',
          sourceListId: 'list-2',
          targetListId: 'list-1',
          operationId: 'op-3',
          originalTask: { title: 'Task 3' },
        },
      ];

      act(() => {
        operations.forEach(op => {
          result.current.pendingOperations.current.push(op);
        });
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);
      expect(result.current.pendingOperations.current).toHaveLength(3);
    });

    it('should handle rapid queue processing calls', async () => {
      const mockAddToast = vi.fn();
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));

      const operation = {
        taskId: 'task-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Task 1' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        // Call processQueue multiple times rapidly
        result.current.processQueue();
        result.current.processQueue();
        result.current.processQueue();
      });

      // Should only start processing once
      expect(result.current.isSyncing).toBe(true);
    });

    it('should handle queue operations while syncing', async () => {
      const mockAddToast = vi.fn();
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));

      const operation1 = {
        taskId: 'task-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Task 1' },
      };

      const operation2 = {
        taskId: 'task-2',
        sourceListId: 'list-1',
        targetListId: 'list-3',
        operationId: 'op-2',
        originalTask: { title: 'Task 2' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation1);
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);

      // Add another operation while syncing
      act(() => {
        result.current.pendingOperations.current.push(operation2);
      });

      expect(result.current.pendingOperations.current).toHaveLength(2);
    });

    it('should handle worker message race conditions', async () => {
      const mockAddToast = vi.fn();
      
      const mockWorker = {
        postMessage: vi.fn(),
        addEventListener: vi.fn(),
        terminate: vi.fn(),
      };

      global.Worker = vi.fn().mockImplementation(() => mockWorker);

      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));

      // Simulate rapid worker messages
      const messageHandler = vi.mocked(mockWorker.addEventListener).mock.calls
        .find(call => call[0] === 'message')?.[1];

      if (messageHandler) {
        // Send multiple messages rapidly
        messageHandler({ data: { type: 'sync-started' } } as MessageEvent);
        messageHandler({ data: { type: 'operation-success', payload: { taskId: 'task-1' } } } as MessageEvent);
        messageHandler({ data: { type: 'operation-success', payload: { taskId: 'task-2' } } } as MessageEvent);
        messageHandler({ data: { type: 'sync-finished' } } as MessageEvent);
      }

      // Should handle all messages gracefully
      expect(result.current.isSyncing).toBe(false);
    });
  });

  describe('Store Integration Race Conditions', () => {
    it('should handle concurrent Google Store and metadata operations', async () => {
      // Create task
      const taskData = {
        title: 'Integration Race Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Perform concurrent operations
      const operations = [
        googleStore.updateTask('list-1', task.id, { title: 'Updated Task' }),
        Promise.resolve(setTaskMetadata(task.id, { priority: 'high' })),
        googleStore.toggleTaskCompletion('list-1', task.id, true),
        Promise.resolve(setTaskMetadata(task.id, { labels: ['concurrent'] })),
      ];

      const results = await Promise.all(operations);
      
      // All operations should succeed
      expect(results).toHaveLength(4);
      
      // Final state should be consistent
      const finalTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === task.id);
      const finalMetadata = getTaskMetadata(task.id);
      
      expect(finalTask).toBeDefined();
      expect(finalMetadata).toBeDefined();
    });

    it('should handle concurrent task creation and metadata setting', async () => {
      const taskData = {
        title: 'Create Race Task',
        notes: 'Test notes',
      };

      // Create task and set metadata concurrently
      const createPromise = googleStore.createTask('list-1', taskData);
      
      const task = await createPromise;
      
      // Set metadata immediately after creation
      const metadataPromise = Promise.resolve(setTaskMetadata(task.id, {
        priority: 'high',
        labels: ['urgent'],
      }));

      await metadataPromise;
      
      // Both operations should succeed
      expect(task).toBeDefined();
      
      const metadata = getTaskMetadata(task.id);
      expect(metadata?.priority).toBe('high');
    });

    it('should handle concurrent task deletion and metadata cleanup', async () => {
      // Create task
      const taskData = {
        title: 'Delete Race Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);
      
      // Set metadata
      setTaskMetadata(task.id, { priority: 'high' });

      // Delete task and metadata concurrently
      const operations = [
        googleStore.deleteTask('list-1', task.id),
        Promise.resolve(metadataStore.deleteTaskMetadata(task.id)),
      ];

      await Promise.all(operations);
      
      // Both should be cleaned up
      const remainingTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === task.id);
      const remainingMetadata = getTaskMetadata(task.id);
      
      expect(remainingTask).toBeUndefined();
      expect(remainingMetadata).toBeNull();
    });
  });

  describe('Timing-Dependent Operations', () => {
    it('should handle operations with timing dependencies', async () => {
      // Create task
      const taskData = {
        title: 'Timing Test Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Set up timing-dependent operations
      const operations = [];
      
      // First operation: update task
      operations.push(
        googleStore.updateTask('list-1', task.id, { title: 'Updated Task' })
      );
      
      // Second operation: move task (depends on first)
      operations.push(
        googleStore.updateTask('list-1', task.id, { title: 'Updated Task' })
          .then(() => googleStore.moveTask(task.id, 'list-1', 'list-2', {}))
      );
      
      // Third operation: update again (depends on second)
      operations.push(
        googleStore.moveTask(task.id, 'list-1', 'list-2', {})
          .then(() => googleStore.updateTask('list-2', task.id, { title: 'Final Update' }))
      );

      const results = await Promise.all(operations);
      
      // All operations should succeed
      expect(results).toHaveLength(3);
      
      // Final state should reflect all operations
      const finalTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-2')
        ?.tasks.find(t => t.id === task.id);
      
      expect(finalTask?.title).toBe('Final Update');
    });

    it('should handle rapid successive operations', async () => {
      // Create task
      const taskData = {
        title: 'Rapid Operations Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Perform rapid successive operations
      const updates = [];
      for (let i = 0; i < 10; i++) {
        updates.push(
          googleStore.updateTask('list-1', task.id, { title: `Rapid Update ${i}` })
        );
      }

      const results = await Promise.all(updates);
      
      // All updates should succeed
      expect(results).toHaveLength(10);
      
      // Final state should be one of the updates
      const finalTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === task.id);
      
      expect(finalTask?.title).toMatch(/Rapid Update \d/);
    });

    it('should handle operations with different timing patterns', async () => {
      // Create tasks
      const tasks = await Promise.all([
        googleStore.createTask('list-1', { title: 'Slow Task' }),
        googleStore.createTask('list-1', { title: 'Fast Task' }),
        googleStore.createTask('list-1', { title: 'Medium Task' }),
      ]);

      // Mock different response times
      let callCount = 0;
      vi.mocked(invoke).mockImplementation((command, args) => {
        callCount++;
        const delay = callCount % 3 === 0 ? 100 : callCount % 2 === 0 ? 50 : 10;
        
        return new Promise(resolve => 
          setTimeout(() => resolve(mockInvoke(command, args)), delay)
        );
      });

      // Perform operations with different timing
      const operations = tasks.map((task, index) => 
        googleStore.updateTask('list-1', task.id, { title: `Updated ${index}` })
      );

      const results = await Promise.all(operations);
      
      // All operations should succeed despite different timing
      expect(results).toHaveLength(3);
      results.forEach((result, index) => {
        expect(result.title).toBe(`Updated ${index}`);
      });
    });
  });

  describe('Memory and Performance Race Conditions', () => {
    it('should handle high-frequency operations', async () => {
      // Create base task
      const taskData = {
        title: 'High Frequency Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Perform high-frequency operations
      const operations = [];
      for (let i = 0; i < 100; i++) {
        operations.push(
          googleStore.updateTask('list-1', task.id, { title: `Update ${i}` })
        );
      }

      const results = await Promise.allSettled(operations);
      
      // Most operations should succeed
      const successCount = results.filter(r => r.status === 'fulfilled').length;
      expect(successCount).toBeGreaterThan(80); // At least 80% success rate
    });

    it('should handle memory pressure scenarios', async () => {
      // Create many tasks rapidly
      const taskCreations = [];
      for (let i = 0; i < 200; i++) {
        taskCreations.push(
          googleStore.createTask('list-1', { title: `Memory Task ${i}` })
        );
      }

      const tasks = await Promise.allSettled(taskCreations);
      
      // Should handle memory pressure gracefully
      const successCount = tasks.filter(r => r.status === 'fulfilled').length;
      expect(successCount).toBeGreaterThan(100); // At least 50% success rate
    });

    it('should handle garbage collection during operations', async () => {
      // Create task
      const taskData = {
        title: 'GC Test Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Perform operations that might trigger garbage collection
      const operations = [];
      for (let i = 0; i < 50; i++) {
        operations.push(
          googleStore.updateTask('list-1', task.id, { 
            title: `GC Update ${i}`,
            notes: 'Large notes '.repeat(1000) // Create large objects
          })
        );
      }

      const results = await Promise.allSettled(operations);
      
      // Should handle GC gracefully
      const successCount = results.filter(r => r.status === 'fulfilled').length;
      expect(successCount).toBeGreaterThan(25); // At least 50% success rate
    });
  });

  describe('Error Recovery Race Conditions', () => {
    it('should handle concurrent error recovery', async () => {
      // Create task
      const taskData = {
        title: 'Error Recovery Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Mock alternating success/failure
      let callCount = 0;
      vi.mocked(invoke).mockImplementation((command, args) => {
        callCount++;
        if (callCount % 2 === 0) {
          return Promise.reject(new Error('Simulated failure'));
        }
        return mockInvoke(command, args);
      });

      // Perform operations that will trigger errors
      const operations = [
        googleStore.updateTask('list-1', task.id, { title: 'Update 1' }),
        googleStore.updateTask('list-1', task.id, { title: 'Update 2' }),
        googleStore.updateTask('list-1', task.id, { title: 'Update 3' }),
        googleStore.updateTask('list-1', task.id, { title: 'Update 4' }),
      ];

      const results = await Promise.allSettled(operations);
      
      // Some should succeed, some should fail
      const successCount = results.filter(r => r.status === 'fulfilled').length;
      const failureCount = results.filter(r => r.status === 'rejected').length;
      
      expect(successCount).toBeGreaterThan(0);
      expect(failureCount).toBeGreaterThan(0);
    });

    it('should handle retry scenarios', async () => {
      // Create task
      const taskData = {
        title: 'Retry Test Task',
        notes: 'Test notes',
      };

      const task = await googleStore.createTask('list-1', taskData);

      // Mock failures followed by success
      let attempt = 0;
      vi.mocked(invoke).mockImplementation((command, args) => {
        attempt++;
        if (attempt <= 2) {
          return Promise.reject(new Error('Retry failure'));
        }
        return mockInvoke(command, args);
      });

      // First attempts should fail
      await expect(googleStore.updateTask('list-1', task.id, { title: 'Retry 1' }))
        .rejects.toThrow('Retry failure');
      
      await expect(googleStore.updateTask('list-1', task.id, { title: 'Retry 2' }))
        .rejects.toThrow('Retry failure');
      
      // Third attempt should succeed
      const result = await googleStore.updateTask('list-1', task.id, { title: 'Retry 3' });
      expect(result.title).toBe('Retry 3');
    });
  });
}); 


END OF FILE: src/features/tasks/tests/race-conditions.test.ts


====================================================================================================
FILE: src/features/tasks/tests/store-integration.test.ts
DESCRIPTION: Store integration tests
====================================================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { act, renderHook, waitFor } from '@testing-library/react';
import { useGoogleStore } from '../../../stores/googleStore';
import { useTaskMetadataStore } from '../../../stores/taskMetadataStore';
import { setTaskMetadata, getTaskMetadata, prepareTaskForAPI, syncTaskMetadata } from '../utils/taskHelpers';
import { GoogleTask, GoogleTaskList, TaskCreateData } from '../../../types/google';
import { invoke } from '@tauri-apps/api/core';

// Mock localStorage for persistence tests
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value;
    },
    removeItem: (key: string) => {
      delete store[key];
    },
    clear: () => {
      store = {};
    },
  };
})();

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
});

describe('Store Integration Tests', () => {
  let googleStore: any;
  let metadataStore: any;

  beforeEach(() => {
    // Clear localStorage
    localStorageMock.clear();
    
    // Reset stores
    googleStore = useGoogleStore.getState();
    metadataStore = useTaskMetadataStore.getState();
    
    // Clear stores
    googleStore.reset?.();
    metadataStore.clearAllMetadata();
    
    // Set up mock account
    googleStore.setActiveAccount({
      id: 'test-account',
      email: 'test@example.com',
      name: 'Test User',
      accessToken: 'test-token',
      refreshToken: 'refresh-token',
      expiresAt: Date.now() + 3600000,
    });
  });

  afterEach(() => {
    // Clean up after each test
    googleStore.reset?.();
    metadataStore.clearAllMetadata();
  });

  describe('Basic Store Integration', () => {
    it('should maintain consistency between stores', async () => {
      // Create a task in Google Store
      const taskData: TaskCreateData = {
        title: 'Integration Test Task',
        notes: 'Test notes',
        due: '2024-12-31',
      };

      let googleTask: GoogleTask;
      await act(async () => {
        googleTask = await googleStore.createTask('list-1', taskData);
      });
      
      // Set metadata in metadata store
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [{ id: '1', title: 'Subtask', completed: false, due: '' }],
      };

      await act(async () => {
        setTaskMetadata(googleTask.id, metadata);
      });

      // Verify both stores have the data
      expect(googleTask).toBeDefined();
      expect(googleTask.title).toBe('Integration Test Task');
      
      await waitFor(() => {
        const retrievedMetadata = getTaskMetadata(googleTask.id);
        expect(retrievedMetadata).toBeDefined();
        expect(retrievedMetadata.priority).toBe('high');
        expect(retrievedMetadata.labels).toEqual(['urgent', 'work']);
      });
    });

    it('should sync metadata from notes field on task creation', async () => {
      const enhancedTaskData = {
        title: 'Enhanced Task',
        notes: 'Task notes [LibreOllama:{"priority":"high","labels":["urgent","work"],"subtasks":[{"id":"1","title":"Subtask","completed":false,"due":""}]}]',
        due: '2024-12-31',
      };

      const googleTask = await googleStore.createTask('list-1', enhancedTaskData);
      
      // Sync metadata from notes field
      const metadata = syncTaskMetadata(googleTask);
      
      expect(metadata).toBeDefined();
      expect(metadata.priority).toBe('high');
      expect(metadata.labels).toEqual(['urgent', 'work']);
      expect(metadata.subtasks).toHaveLength(1);
    });

    it('should prepare task for API with metadata', async () => {
      const taskData = {
        title: 'Test Task',
        notes: 'Base notes',
        due: '2024-12-31',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set metadata
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
      };
      setTaskMetadata(googleTask.id, metadata);

      // Prepare for API
      const preparedData = prepareTaskForAPI(googleTask.id, {
        title: 'Updated Title',
        notes: 'Updated notes',
        due: '2025-01-01',
      });

      expect(preparedData.title).toBe('Updated Title');
      expect(preparedData.notes).toContain('Updated notes');
      expect(preparedData.notes).toContain('[LibreOllama:');
      expect(preparedData.due).toBe('2025-01-01');
    });
  });

  describe('Task Lifecycle Integration', () => {
    it('should handle task creation with metadata', async () => {
      const taskData = {
        title: 'Task with Metadata',
        notes: 'Base notes',
        due: '2024-12-31',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set metadata after creation
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [{ id: '1', title: 'Subtask', completed: false, due: '' }],
      };
      setTaskMetadata(googleTask.id, metadata);

      // Verify integration
      const retrievedMetadata = getTaskMetadata(googleTask.id);
      expect(retrievedMetadata).toBeDefined();
      expect(retrievedMetadata.priority).toBe('high');
      expect(retrievedMetadata.labels).toEqual(['urgent', 'work']);
      expect(retrievedMetadata.subtasks).toHaveLength(1);
    });

    it('should handle task updates with metadata preservation', async () => {
      // Create task
      const taskData = {
        title: 'Original Task',
        notes: 'Original notes',
        due: '2024-12-31',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set metadata
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
      };
      setTaskMetadata(googleTask.id, metadata);

      // Update task with metadata preserved
      const updatedData = prepareTaskForAPI(googleTask.id, {
        title: 'Updated Task',
        notes: 'Updated notes',
        due: '2025-01-01',
      });

      const updatedTask = await googleStore.updateTask('list-1', googleTask.id, updatedData);
      
      // Verify task was updated
      expect(updatedTask.title).toBe('Updated Task');
      expect(updatedTask.notes).toContain('Updated notes');
      expect(updatedTask.notes).toContain('[LibreOllama:');
      
      // Verify metadata was preserved
      const retrievedMetadata = getTaskMetadata(googleTask.id);
      expect(retrievedMetadata.priority).toBe('high');
      expect(retrievedMetadata.labels).toEqual(['urgent', 'work']);
    });

    it('should handle task deletion with metadata cleanup', async () => {
      // Create task
      const taskData = {
        title: 'Task to Delete',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set metadata
      const metadata = {
        priority: 'high',
        labels: ['urgent'],
      };
      setTaskMetadata(googleTask.id, metadata);

      // Verify metadata exists
      expect(getTaskMetadata(googleTask.id)).toBeDefined();

      // Delete task
      await googleStore.deleteTask('list-1', googleTask.id);
      
      // Verify metadata was cleaned up
      expect(getTaskMetadata(googleTask.id)).toBeNull();
    });

    it('should handle task movement with metadata preservation', async () => {
      // Create task
      const taskData = {
        title: 'Task to Move',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set metadata
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [{ id: '1', title: 'Subtask', completed: false, due: '' }],
      };
      setTaskMetadata(googleTask.id, metadata);

      // Move task
      const movedTask = await googleStore.moveTask(googleTask.id, 'list-1', 'list-2', {});
      
      // Verify task was moved
      expect(movedTask.id).toBe(googleTask.id);
      
      // Verify metadata was preserved
      const retrievedMetadata = getTaskMetadata(googleTask.id);
      expect(retrievedMetadata).toBeDefined();
      expect(retrievedMetadata.priority).toBe('high');
      expect(retrievedMetadata.labels).toEqual(['urgent', 'work']);
      expect(retrievedMetadata.subtasks).toHaveLength(1);
    });
  });

  describe('Optimistic Updates Integration', () => {
    it('should handle optimistic updates with metadata', async () => {
      // Create task
      const taskData = {
        title: 'Optimistic Task',
        notes: 'Test notes',
      };

      let googleTask: GoogleTask;
      await act(async () => {
        googleTask = await googleStore.createTask('list-1', taskData);
      });
      
      // Set metadata
      const metadata = {
        priority: 'normal',
        labels: ['task'],
      };
      await act(async () => {
        setTaskMetadata(googleTask.id, metadata);
      });

      // Apply optimistic update
      const updatedData = {
        title: 'Optimistically Updated Task',
        notes: 'Updated notes',
      };

      await act(async () => {
        googleStore.optimisticUpdateTask('list-1', googleTask.id, updatedData);
      });

      // Update metadata
      const updatedMetadata = {
        priority: 'high',
        labels: ['urgent', 'important'],
      };
      await act(async () => {
        setTaskMetadata(googleTask.id, updatedMetadata);
      });

      // Verify optimistic update
      await waitFor(() => {
        const optimisticTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
          ?.tasks.find(t => t.id === googleTask.id);
        
        expect(optimisticTask?.title).toBe('Optimistically Updated Task');
      });
      
      // Verify metadata update
      await waitFor(() => {
        const retrievedMetadata = getTaskMetadata(googleTask.id);
        expect(retrievedMetadata.priority).toBe('high');
        expect(retrievedMetadata.labels).toEqual(['urgent', 'important']);
      });
    });

    it('should handle optimistic move with metadata', async () => {
      // Create task
      const taskData = {
        title: 'Task to Move',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set metadata
      const metadata = {
        priority: 'high',
        labels: ['urgent'],
      };
      setTaskMetadata(googleTask.id, metadata);

      // Apply optimistic move
      googleStore.optimisticMoveTask(googleTask.id, 'list-1', 'list-2');

      // Verify task was moved optimistically
      const sourceListTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      const targetListTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-2')?.tasks;
      
      expect(sourceListTasks?.find(t => t.id === googleTask.id)).toBeUndefined();
      expect(targetListTasks?.find(t => t.id === googleTask.id)).toBeDefined();
      
      // Verify metadata was preserved
      const retrievedMetadata = getTaskMetadata(googleTask.id);
      expect(retrievedMetadata).toBeDefined();
      expect(retrievedMetadata.priority).toBe('high');
      expect(retrievedMetadata.labels).toEqual(['urgent']);
    });

    it('should handle optimistic reorder with metadata', async () => {
      // Create multiple tasks
      const task1 = await googleStore.createTask('list-1', { title: 'Task 1' });
      const task2 = await googleStore.createTask('list-1', { title: 'Task 2' });
      
      // Set metadata for both
      setTaskMetadata(task1.id, { priority: 'high', labels: ['urgent'] });
      setTaskMetadata(task2.id, { priority: 'normal', labels: ['task'] });

      // Apply optimistic reorder
      googleStore.optimisticReorderTask('list-1', task1.id, task2.id);

      // Verify tasks still exist
      const listTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      expect(listTasks?.find(t => t.id === task1.id)).toBeDefined();
      expect(listTasks?.find(t => t.id === task2.id)).toBeDefined();
      
      // Verify metadata was preserved
      const metadata1 = getTaskMetadata(task1.id);
      const metadata2 = getTaskMetadata(task2.id);
      
      expect(metadata1.priority).toBe('high');
      expect(metadata2.priority).toBe('normal');
    });
  });

  describe('Error Handling Integration', () => {
    it('should handle Google Store failures with metadata rollback', async () => {
      // Create task
      const taskData = {
        title: 'Test Task',
        notes: 'Test notes',
      };

      let googleTask: GoogleTask;
      await act(async () => {
        googleTask = await googleStore.createTask('list-1', taskData);
      });
      
      // Set initial metadata
      const initialMetadata = {
        priority: 'normal',
        labels: ['task'],
      };
      await act(async () => {
        setTaskMetadata(googleTask.id, initialMetadata);
      });

      // Update metadata
      const updatedMetadata = {
        priority: 'high',
        labels: ['urgent', 'important'],
      };
      await act(async () => {
        setTaskMetadata(googleTask.id, updatedMetadata);
      });

      // Mock update failure
      vi.mocked(invoke).mockRejectedValueOnce(new Error('Update failed'));

      // Prepare task for API
      const preparedData = prepareTaskForAPI(googleTask.id, {
        title: 'Updated Task',
        notes: 'Updated notes',
      });

      // Attempt update (should fail)
      await act(async () => {
        await expect(googleStore.updateTask('list-1', googleTask.id, preparedData)).rejects.toThrow('Update failed');
      });
      
      // Verify metadata remains (rollback logic would need to be implemented)
      await waitFor(() => {
        const retrievedMetadata = getTaskMetadata(googleTask.id);
        expect(retrievedMetadata).toBeDefined();
        expect(retrievedMetadata.priority).toBe('high'); // Current implementation keeps metadata
      });
    });

    it('should handle metadata store failures gracefully', async () => {
      // Create task
      const taskData = {
        title: 'Test Task',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Mock metadata store failure
      const originalSetMetadata = metadataStore.setTaskMetadata;
      metadataStore.setTaskMetadata = vi.fn().mockImplementation(() => {
        throw new Error('Metadata store failure');
      });

      // Attempt to set metadata (should fail gracefully)
      expect(() => {
        setTaskMetadata(googleTask.id, { priority: 'high' });
      }).toThrow('Metadata store failure');

      // Restore original function
      metadataStore.setTaskMetadata = originalSetMetadata;
      
      // Verify Google Store task still exists
      const listTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      expect(listTasks?.find(t => t.id === googleTask.id)).toBeDefined();
    });

    it('should handle corrupted metadata gracefully', async () => {
      // Create task
      const taskData = {
        title: 'Test Task',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set corrupted metadata directly in localStorage
      localStorageMock.setItem('task-metadata-store', JSON.stringify({
        state: {
          metadata: [
            [googleTask.id, { corrupted: 'data', invalid: 'structure' }]
          ]
        }
      }));

      // Attempt to get metadata (should handle gracefully)
      const retrievedMetadata = getTaskMetadata(googleTask.id);
      
      // Should either return null or valid default metadata
      expect(retrievedMetadata).toBeNull();
    });
  });

  describe('Concurrency Integration', () => {
    it('should handle concurrent Google Store and metadata operations', async () => {
      // Create task
      const taskData = {
        title: 'Concurrent Test Task',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Perform concurrent operations
      const operations = [
        // Google Store operations
        googleStore.updateTask('list-1', googleTask.id, { title: 'Updated 1' }),
        googleStore.updateTask('list-1', googleTask.id, { title: 'Updated 2' }),
        
        // Metadata operations
        Promise.resolve(setTaskMetadata(googleTask.id, { priority: 'high' })),
        Promise.resolve(setTaskMetadata(googleTask.id, { priority: 'urgent' })),
        Promise.resolve(setTaskMetadata(googleTask.id, { labels: ['concurrent'] })),
      ];

      // Wait for all operations
      await Promise.all(operations);

      // Verify final state
      const finalTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === googleTask.id);
      
      expect(finalTask).toBeDefined();
      expect(['Updated 1', 'Updated 2']).toContain(finalTask.title);
      
      const finalMetadata = getTaskMetadata(googleTask.id);
      expect(finalMetadata).toBeDefined();
      expect(['high', 'urgent']).toContain(finalMetadata.priority);
    });

    it('should handle concurrent task movements with metadata', async () => {
      // Create multiple tasks
      const tasks = await Promise.all([
        googleStore.createTask('list-1', { title: 'Task 1' }),
        googleStore.createTask('list-1', { title: 'Task 2' }),
        googleStore.createTask('list-1', { title: 'Task 3' }),
      ]);

      // Set metadata for all tasks
      tasks.forEach((task, index) => {
        setTaskMetadata(task.id, {
          priority: 'high',
          labels: [`task-${index}`],
        });
      });

      // Perform concurrent moves
      const moveOperations = tasks.map(task => 
        googleStore.moveTask(task.id, 'list-1', 'list-2', {})
      );

      await Promise.all(moveOperations);

      // Verify all tasks were moved
      const targetListTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-2')?.tasks;
      tasks.forEach(task => {
        expect(targetListTasks?.find(t => t.id === task.id)).toBeDefined();
      });

      // Verify metadata was preserved
      tasks.forEach((task, index) => {
        const metadata = getTaskMetadata(task.id);
        expect(metadata).toBeDefined();
        expect(metadata.priority).toBe('high');
        expect(metadata.labels).toEqual([`task-${index}`]);
      });
    });
  });

  describe('Performance Integration', () => {
    it('should handle large numbers of tasks with metadata efficiently', async () => {
      const taskCount = 100;
      const startTime = Date.now();

      // Create tasks in batches
      const tasks = [];
      for (let i = 0; i < taskCount; i++) {
        const task = await googleStore.createTask('list-1', {
          title: `Task ${i}`,
          notes: `Notes ${i}`,
        });
        tasks.push(task);
      }

      // Set metadata for all tasks
      tasks.forEach((task, index) => {
        setTaskMetadata(task.id, {
          priority: index % 2 === 0 ? 'high' : 'normal',
          labels: [`batch-${Math.floor(index / 10)}`],
        });
      });

      const endTime = Date.now();
      const duration = endTime - startTime;

      // Should complete within reasonable time
      expect(duration).toBeLessThan(5000); // 5 seconds max

      // Verify all tasks and metadata exist
      const listTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      expect(listTasks).toHaveLength(taskCount);

      tasks.forEach((task, index) => {
        const metadata = getTaskMetadata(task.id);
        expect(metadata).toBeDefined();
        expect(metadata.priority).toBe(index % 2 === 0 ? 'high' : 'normal');
      });
    });

    it('should handle rapid metadata updates efficiently', async () => {
      // Create task
      const taskData = {
        title: 'Performance Test Task',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      const updateCount = 100;
      const startTime = Date.now();

      // Perform rapid metadata updates
      for (let i = 0; i < updateCount; i++) {
        setTaskMetadata(googleTask.id, {
          priority: i % 2 === 0 ? 'high' : 'normal',
          labels: [`update-${i}`],
        });
      }

      const endTime = Date.now();
      const duration = endTime - startTime;

      // Should complete quickly
      expect(duration).toBeLessThan(1000); // 1 second max

      // Verify final state
      const finalMetadata = getTaskMetadata(googleTask.id);
      expect(finalMetadata).toBeDefined();
      expect(finalMetadata.labels).toEqual([`update-${updateCount - 1}`]);
    });
  });

  describe('Persistence Integration', () => {
    it('should persist metadata across store resets', async () => {
      // Create task
      const taskData = {
        title: 'Persistence Test Task',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set metadata
      const metadata = {
        priority: 'high',
        labels: ['persistent', 'test'],
        subtasks: [{ id: '1', title: 'Persistent subtask', completed: false, due: '' }],
      };
      setTaskMetadata(googleTask.id, metadata);

      // Reset Google Store (simulating app restart)
      googleStore.reset?.();

      // Verify metadata persists
      const retrievedMetadata = getTaskMetadata(googleTask.id);
      expect(retrievedMetadata).toBeDefined();
      expect(retrievedMetadata.priority).toBe('high');
      expect(retrievedMetadata.labels).toEqual(['persistent', 'test']);
      expect(retrievedMetadata.subtasks).toHaveLength(1);
    });

    it('should handle metadata persistence failures gracefully', async () => {
      // Create task
      const taskData = {
        title: 'Persistence Failure Test',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Mock localStorage failure
      const originalSetItem = localStorageMock.setItem;
      localStorageMock.setItem = vi.fn().mockImplementation(() => {
        throw new Error('Storage quota exceeded');
      });

      // Attempt to set metadata (should handle gracefully)
      expect(() => {
        setTaskMetadata(googleTask.id, { priority: 'high' });
      }).not.toThrow();

      // Restore original function
      localStorageMock.setItem = originalSetItem;
    });
  });

  describe('Data Consistency', () => {
    it('should maintain data consistency after multiple operations', async () => {
      // Create task
      const taskData = {
        title: 'Consistency Test Task',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Perform multiple operations
      const operations = [
        // Update task
        googleStore.updateTask('list-1', googleTask.id, { title: 'Updated Task' }),
        
        // Set metadata
        Promise.resolve(setTaskMetadata(googleTask.id, { priority: 'high' })),
        
        // Move task
        googleStore.moveTask(googleTask.id, 'list-1', 'list-2', {}),
        
        // Update metadata
        Promise.resolve(setTaskMetadata(googleTask.id, { labels: ['moved'] })),
      ];

      await Promise.all(operations);

      // Verify consistency
      const finalTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-2')
        ?.tasks.find(t => t.id === googleTask.id);
      
      expect(finalTask).toBeDefined();
      expect(finalTask.title).toBe('Updated Task');
      
      const finalMetadata = getTaskMetadata(googleTask.id);
      expect(finalMetadata).toBeDefined();
      expect(finalMetadata.priority).toBe('high');
      expect(finalMetadata.labels).toEqual(['moved']);
    });

    it('should handle inconsistent state recovery', async () => {
      // Create task
      const taskData = {
        title: 'Inconsistent State Test',
        notes: 'Test notes',
      };

      const googleTask = await googleStore.createTask('list-1', taskData);
      
      // Set metadata
      setTaskMetadata(googleTask.id, { priority: 'high' });

      // Simulate inconsistent state by removing task from Google Store
      googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.splice(0, 1);

      // Verify metadata still exists
      const metadata = getTaskMetadata(googleTask.id);
      expect(metadata).toBeDefined();
      expect(metadata.priority).toBe('high');

      // Cleanup should handle orphaned metadata
      metadataStore.deleteTaskMetadata(googleTask.id);
      expect(getTaskMetadata(googleTask.id)).toBeNull();
    });
  });
}); 

END OF FILE: src/features/tasks/tests/store-integration.test.ts


====================================================================================================
FILE: src/features/tasks/tests/task-operations.test.ts
DESCRIPTION: Task operations tests
====================================================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { act, renderHook, waitFor } from '@testing-library/react';
import { useGoogleStore } from '../../../stores/googleStore';
import { useTaskMetadataStore } from '../../../stores/taskMetadataStore';
import { GoogleTask, GoogleTaskList, TaskCreateData } from '../../../types/google';
import { prepareTaskForAPI, setTaskMetadata, getTaskMetadata, encodeEnhancedTaskData } from '../utils/taskHelpers';
import { invoke } from '@tauri-apps/api/core';
import { GoogleAccount } from '../../../types/google';
import { produce } from 'immer';

// Mock the mockGoogleService module so we can override its mockInvoke function
const mockInvoke = vi.hoisted(() => vi.fn());
vi.mock('../../../services/google/mockGoogleService', () => ({
  mockInvoke: mockInvoke,
  getMockAccount: () => ({
    id: 'mock-account-1',
    email: 'test@example.com',
    name: 'Test User',
    picture: 'https://via.placeholder.com/150',
    accessToken: 'mock-access-token',
    refreshToken: 'mock-refresh-token',
    expiresAt: Date.now() + 3600000,
  }),
}));

// Mock console methods to avoid noise in tests
const mockConsole = {
  log: vi.fn(),
  error: vi.fn(),
  warn: vi.fn(),
};

beforeEach(() => {
  vi.spyOn(console, 'log').mockImplementation(mockConsole.log);
  vi.spyOn(console, 'error').mockImplementation(mockConsole.error);
  vi.spyOn(console, 'warn').mockImplementation(mockConsole.warn);
});

afterEach(() => {
  vi.restoreAllMocks();
  mockConsole.log.mockClear();
  mockConsole.error.mockClear();
  mockConsole.warn.mockClear();
});

describe('Task Operations Tests', () => {
  const mockTaskLists = [
    {
      id: 'list-1',
      title: 'My Tasks',
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/list-1',
      etag: 'etag-1',
    },
    {
      id: 'list-2',
      title: 'Work Projects',  
      updated: new Date().toISOString(),
      selfLink: 'https://example.com/list-2',
      etag: 'etag-2',
    },
  ];

  const mockKanbanColumns = [
    {
      taskList: mockTaskLists[0],
      tasks: [],
      isLoading: false,
    },
    {
      taskList: mockTaskLists[1],
      tasks: [],
      isLoading: false,
    },
  ];

  // Store references updated in beforeEach
  let googleStore: any;
  let metadataStore: any;
  
  // Shared variables
  let testTaskId: string;
  
  beforeEach(async () => {
    // Proper mock cleanup as per research findings
    vi.clearAllMocks();
    vi.resetAllMocks();
    
    // Reset mock function with default implementation
    mockInvoke.mockReset();
    
    // Create a persistent task registry to track created tasks
    const taskRegistry = new Map<string, any>();
    
    // Mock implementation that returns raw data (service layer will wrap it)
    mockInvoke.mockImplementation(async (command: string, args: any): Promise<any> => {
      console.log(`[Mock] Invoking command: ${command}`, args);

      switch (command) {
        case 'create_task':
          const newTask = {
            id: `task-${Date.now()}`,
            title: args.taskData.title,
            notes: args.taskData.notes || '',
            status: 'needsAction',
            due: args.taskData.due,
            parent: args.taskData.parent,
            position: args.taskData.position || '1',
            updated: new Date().toISOString(),
            links: [],
            selfLink: `https://www.googleapis.com/tasks/v1/lists/${args.taskListId}/tasks/task-${Date.now()}`,
            etag: 'etag-123',
            kind: 'tasks#task',
            unsynced: false,
            labels: [],
            priority: 'normal',
            subtasks: [],
            recurring: undefined,
            children: [],
          };
          taskRegistry.set(newTask.id, newTask);
          return newTask; // Return raw task data

        case 'update_task':
          const existingTask = taskRegistry.get(args.taskId);
          if (!existingTask) {
            throw new Error('Task not found');
          }
          
          const updatedTask = {
            ...existingTask,
            ...args.taskData,
            updated: new Date().toISOString(),
          };
          taskRegistry.set(args.taskId, updatedTask);
          return updatedTask; // Return raw task data

        case 'move_task':
          const taskToMove = taskRegistry.get(args.taskId);
          if (!taskToMove) {
            throw new Error('Task not found');
          }
          
          const movedTask = {
            ...taskToMove,
            position: args.options?.previous || '1',
            updated: new Date().toISOString(),
          };
          taskRegistry.set(args.taskId, movedTask);
          return movedTask; // Return raw task data

        case 'delete_task':
          const taskToDelete = taskRegistry.get(args.taskId);
          if (!taskToDelete) {
            throw new Error('Task not found');
          }
          
          taskRegistry.delete(args.taskId);
          return; // Return void for delete

        case 'get_task_lists':
          return { items: mockTaskLists }; // Return raw task lists data

        case 'get_tasks':
          const tasks = Array.from(taskRegistry.values()).filter(task => 
            task.listId === args.taskListId || !task.listId
          );
          return { items: tasks }; // Return raw tasks data

        default:
          throw new Error(`Unknown command: ${command}`);
      }
    });

    // Store the task registry on the mock for tests to access and preserve across test scenarios
    (mockInvoke as any).taskRegistry = taskRegistry;
    // Make registry globally accessible for error tests that need to ensure task persistence
    (global as any).testTaskRegistry = taskRegistry;

    // Set up store with mock data
    googleStore = useGoogleStore.getState();
    metadataStore = useTaskMetadataStore.getState();
    
    // Clear stores
    googleStore.clearData();
    metadataStore.clearAllMetadata();
    
    // Add mock account
    const mockAccount: GoogleAccount = {
      id: 'mock-account-1',
      email: 'test@example.com',
      name: 'Test User',
      picture: 'https://via.placeholder.com/150',
      accessToken: 'mock-access-token',
      refreshToken: 'mock-refresh-token',
      expiresAt: Date.now() + 3600000,
    };
    
    googleStore.addAccount(mockAccount);
    googleStore.setActiveAccount(mockAccount);
    
    // Add mock kanban columns
    useGoogleStore.setState({
      taskLists: mockTaskLists,
      kanbanColumns: mockKanbanColumns,
    });

    // Create test task and wait for completion
    const testTask = await googleStore.createTask('list-1', { title: 'Test Task for Operations' });
    testTaskId = testTask!.id;
    
    // Ensure test task is registered in mock registry for error scenarios
    taskRegistry.set(testTaskId, {
      id: testTaskId,
      title: 'Test Task for Operations',
      status: 'needsAction',
      notes: 'Test notes',
    });
  });

  describe('Task Creation', () => {
    it('should create a basic task successfully', async () => {
      const taskData: TaskCreateData = {
        title: 'Test Task',
        notes: 'Test notes',
        due: '2024-12-31',
      };

      const result = await googleStore.createTask('list-1', taskData);
      
      expect(result).toBeDefined();
      expect(result.title).toBe('Test Task');
      expect(result.notes).toBe('Test notes');
      expect(result.status).toBe('needsAction');
    });

    it('should create a task with enhanced metadata', async () => {
      const taskData: TaskCreateData = {
        title: 'Enhanced Task',
        notes: 'Base notes',
        due: '2024-12-31',
      };

      const enhancedData = {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [{ id: '1', title: 'Subtask 1', completed: false, due: '' }],
      };

      // Prepare the task data with enhanced metadata
      const enhancedTaskData = {
        ...taskData,
        notes: `${taskData.notes} ${encodeEnhancedTaskData(enhancedData)}`,
      };

      const result = await googleStore.createTask('list-1', enhancedTaskData);
      
      expect(result).toBeDefined();
      expect(result.title).toBe('Enhanced Task');
      expect(result.notes).toContain('Base notes');
      expect(result.notes).toContain('[LibreOllama:');
    });

    it('should handle task creation failures gracefully', async () => {
      // Mock a failure scenario
      mockInvoke.mockRejectedValueOnce(new Error('Network error'));

      const taskData: TaskCreateData = {
        title: 'Failing Task',
        notes: 'Test notes',
      };

      await act(async () => {
        await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Network error');
      });
    });

    it('should create tasks with parent-child relationships', async () => {
      const parentTask: TaskCreateData = {
        title: 'Parent Task',
        notes: 'Parent notes',
      };

      const childTask: TaskCreateData = {
        title: 'Child Task',
        notes: 'Child notes',
        parent: 'parent-task-id',
      };

      const parent = await googleStore.createTask('list-1', parentTask);
      const child = await googleStore.createTask('list-1', { ...childTask, parent: parent.id });
      
      expect(parent.title).toBe('Parent Task');
      expect(child.title).toBe('Child Task');
      expect(child.parent).toBe(parent.id);
    });
  });

  describe('Task Updates', () => {
    let testTask: GoogleTask;
    let testTaskId: string;

    beforeEach(async () => {
      // Create a test task for update operations
      testTask = await googleStore.createTask('list-1', {
        title: 'Test Task for Updates',
        notes: 'Initial notes',
        due: '2024-12-31',
      });
      testTaskId = testTask.id;
    });

    it('should update task title successfully', async () => {
      const updatedData = {
        title: 'Updated Task Title',
        notes: testTask.notes,
        due: testTask.due,
      };

      const result = await googleStore.updateTask('list-1', testTaskId, updatedData);
      
      expect(result.title).toBe('Updated Task Title');
      expect(result.notes).toBe(testTask.notes);
      expect(result.due).toBe(testTask.due);
    });

    it('should update task due date successfully', async () => {
      const newDueDate = '2025-01-15';
      const updatedData = {
        title: testTask.title,
        notes: testTask.notes,
        due: newDueDate,
      };

      const result = await googleStore.updateTask('list-1', testTaskId, updatedData);
      
      expect(result.due).toBe(newDueDate);
      expect(result.title).toBe(testTask.title);
    });

    it('should update task notes and preserve metadata', async () => {
      // First, set some metadata
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
      };
      setTaskMetadata(testTaskId, metadata);

      // Update notes while preserving metadata
      const updatedData = prepareTaskForAPI(testTaskId, {
        title: testTask.title,
        notes: 'Updated notes content',
        due: testTask.due,
      });

      const result = await googleStore.updateTask('list-1', testTaskId, updatedData);
      
      expect(result.notes).toContain('Updated notes content');
      expect(result.notes).toContain('[LibreOllama:');
      
      // Verify metadata is preserved
      const retrievedMetadata = getTaskMetadata(testTaskId);
      expect(retrievedMetadata?.priority).toBe('high');
      expect(retrievedMetadata?.labels).toEqual(['urgent', 'work']);
    });

    it('should handle concurrent updates correctly', async () => {
      const updates = [
        { title: 'Update 1', notes: 'Notes 1', due: '2025-01-01' },
        { title: 'Update 2', notes: 'Notes 2', due: '2025-01-02' },
        { title: 'Update 3', notes: 'Notes 3', due: '2025-01-03' },
      ];

      // Execute updates concurrently
      const promises = updates.map(update => 
        googleStore.updateTask('list-1', testTaskId, update)
      );

      const results = await Promise.all(promises);
      
      // All updates should succeed
      expect(results).toHaveLength(3);
      results.forEach(result => {
        expect(result).toBeDefined();
        expect(result.id).toBe(testTaskId);
      });

      // The final result should be one of the updates
      const finalTask = results[results.length - 1];
      expect(updates.map(u => u.title)).toContain(finalTask.title);
    });

    it('should handle optimistic updates and rollback on failure', async () => {
      const originalTitle = testTask.title;
      const updatedData = {
        title: 'Failed Update',
        notes: testTask.notes,
        due: testTask.due,
      };

      // Mock a failure
      mockInvoke.mockRejectedValueOnce(new Error('Update failed'));

      // Apply optimistic update
      await act(async () => {
        googleStore.optimisticUpdateTask('list-1', testTaskId, updatedData);
      });

      // Verify optimistic update was applied
      await waitFor(() => {
        const optimisticState = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
          ?.tasks.find(t => t.id === testTaskId);
        
        expect(optimisticState?.title).toBe('Failed Update');
      });

      // Attempt the actual update (should fail)
      await act(async () => {
        await expect(googleStore.updateTask('list-1', testTaskId, updatedData)).rejects.toThrow('Update failed');
      });

      // Verify state was rolled back
      await waitFor(() => {
        const finalState = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
          ?.tasks.find(t => t.id === testTaskId);
        
        expect(finalState?.title).toBe(originalTitle);
      });
    });

    it('should handle task updates with metadata changes', async () => {
      // Set initial metadata
      const initialMetadata = {
        priority: 'normal',
        labels: ['task'],
        subtasks: [],
      };
      setTaskMetadata(testTaskId, initialMetadata);

      // Update with new metadata
      const newMetadata = {
        priority: 'high',
        labels: ['urgent', 'important'],
        subtasks: [{ id: '1', title: 'New subtask', completed: false, due: '' }],
      };
      setTaskMetadata(testTaskId, newMetadata);

      // Update the task
      const updatedData = prepareTaskForAPI(testTaskId, {
        title: 'Updated with metadata',
        notes: 'Updated notes',
        due: testTask.due,
      });

      const result = await googleStore.updateTask('list-1', testTaskId, updatedData);
      
      expect(result.title).toBe('Updated with metadata');
      expect(result.notes).toContain('Updated notes');
      expect(result.notes).toContain('[LibreOllama:');
      
      // Verify metadata was updated
      const retrievedMetadata = getTaskMetadata(testTaskId);
      expect(retrievedMetadata?.priority).toBe('high');
      expect(retrievedMetadata?.labels).toEqual(['urgent', 'important']);
      expect(retrievedMetadata?.subtasks).toHaveLength(1);
    });
  });

  describe('Task Movement', () => {
    let testTask: GoogleTask;
    let testTaskId: string;

    beforeEach(async () => {
      // Create a test task for movement operations
      testTask = await googleStore.createTask('list-1', {
        title: 'Task to Move',
        notes: 'Test notes',
        due: '2024-12-31',
      });
      testTaskId = testTask.id;
    });

    it('should move task between lists successfully', async () => {
      // Move task from list-1 to list-2
      const result = await googleStore.moveTask(testTaskId, 'list-1', 'list-2', {});
      
      expect(result).toBeDefined();
      expect(result.id).toBe(testTaskId);
      expect(result.title).toBe('Task to Move');
      
      // Get current store state
      const currentStore = useGoogleStore.getState();
      
      // Verify task is no longer in source list
      const sourceListTasks = currentStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      expect(sourceListTasks?.find(t => t.id === testTaskId)).toBeUndefined();
      
      // Verify task is in target list
      const targetListTasks = currentStore.kanbanColumns.find(c => c.taskList.id === 'list-2')?.tasks;
      expect(targetListTasks?.find(t => t.id === testTaskId)).toBeDefined();
    });

    it('should handle optimistic move and rollback on failure', async () => {
      // Apply optimistic move
      googleStore.optimisticMoveTask(testTaskId, 'list-1', 'list-2');
      
      // Get current store state after optimistic move
      const afterOptimisticMove = useGoogleStore.getState();
      
      // Verify optimistic move was applied
      const sourceListTasks = afterOptimisticMove.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      const targetListTasks = afterOptimisticMove.kanbanColumns.find(c => c.taskList.id === 'list-2')?.tasks;
      
      expect(sourceListTasks?.find(t => t.id === testTaskId)).toBeUndefined();
      expect(targetListTasks?.find(t => t.id === testTaskId)).toBeDefined();

      // Use mockImplementationOnce with proper Error instance (research finding)
      mockInvoke.mockImplementationOnce(async (command: string): Promise<any> => {
        if (command === 'move_task') {
          throw new Error('Move failed');
        }
        throw new Error('Unexpected command in test');
      });

      // Attempt the actual move (should fail)
      await expect(googleStore.moveTask(testTaskId, 'list-1', 'list-2', undefined)).rejects.toThrow('Move failed');
      
      // Get final store state after rollback
      const finalState = useGoogleStore.getState();
      
      // Verify state was rolled back
      const finalSourceTasks = finalState.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      const finalTargetTasks = finalState.kanbanColumns.find(c => c.taskList.id === 'list-2')?.tasks;
      
      expect(finalSourceTasks?.find(t => t.id === testTaskId)).toBeDefined();
      expect(finalTargetTasks?.find(t => t.id === testTaskId)).toBeUndefined();
    });

    it('should handle concurrent move operations', async () => {
      // Create multiple tasks for concurrent moves
      const tasks = await Promise.all([
        googleStore.createTask('list-1', { title: 'Task 1' }),
        googleStore.createTask('list-1', { title: 'Task 2' }),
        googleStore.createTask('list-1', { title: 'Task 3' }),
      ]);

      // Move all tasks concurrently to different lists
      const movePromises = tasks.map((task, index) => 
        googleStore.moveTask(task.id, 'list-1', `list-${index + 2}`, {})
      );

      const results = await Promise.all(movePromises);
      
      // All moves should succeed
      expect(results).toHaveLength(3);
      results.forEach((result, index) => {
        expect(result).toBeDefined();
        expect(result.id).toBe(tasks[index].id);
      });
    });

    it('should preserve task metadata during moves', async () => {
      // Set metadata before moving
      const metadata = {
        priority: 'high',
        labels: ['urgent', 'work'],
        subtasks: [{ id: '1', title: 'Subtask', completed: false, due: '' }],
      };
      setTaskMetadata(testTaskId, metadata);

      // Move the task
      const result = await googleStore.moveTask(testTaskId, 'list-1', 'list-2', {});
      
      expect(result).toBeDefined();
      expect(result.id).toBe(testTaskId);
      
      // Verify metadata was preserved
      const retrievedMetadata = getTaskMetadata(testTaskId);
      expect(retrievedMetadata?.priority).toBe('high');
      expect(retrievedMetadata?.labels).toEqual(['urgent', 'work']);
      expect(retrievedMetadata?.subtasks).toHaveLength(1);
    });

    it('should handle move operations with position options', async () => {
      // Create a reference task in the target list
      const referenceTask = await googleStore.createTask('list-2', {
        title: 'Reference Task',
        notes: 'Reference',
      });

      // Move task with position relative to reference task (position is a string)
      const result = await googleStore.moveTask(testTaskId, 'list-1', 'list-2', referenceTask.id);
      
      expect(result).toBeDefined();
      expect(result.id).toBe(testTaskId);
      expect(result.position).toBe(referenceTask.id);
    });

    it('should handle move operations with parent options', async () => {
      // Create a parent task in the target list
      const parentTask = await googleStore.createTask('list-2', {
        title: 'Parent Task',
        notes: 'Parent',
      });

      // Move task to list-2 (parent functionality not implemented in current API)
      const result = await googleStore.moveTask(testTaskId, 'list-1', 'list-2', undefined);
      
      expect(result).toBeDefined();
      expect(result.id).toBe(testTaskId);
      // Note: Parent field is not currently passed to the API in the implementation
      expect(result.parent).toBeUndefined();
    });

    it('should handle task reordering within same list', async () => {
      // Create additional tasks in the same list
      const task2 = await googleStore.createTask('list-1', {
        title: 'Task 2',
        notes: 'Second task',
      });

      const task3 = await googleStore.createTask('list-1', {
        title: 'Task 3',
        notes: 'Third task',
      });

      // Apply optimistic reorder
      googleStore.optimisticReorderTask('list-1', testTaskId, task2.id);
      
      // Get current store state
      const currentStore = useGoogleStore.getState();
      
      // Verify reorder was applied
      const listTasks = currentStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      expect(listTasks?.find(t => t.id === testTaskId)).toBeDefined();
      expect(listTasks?.find(t => t.id === task2.id)).toBeDefined();
      expect(listTasks?.find(t => t.id === task3.id)).toBeDefined();
    });
  });

  describe('Task Deletion', () => {
    let testTask: GoogleTask;
    let testTaskId: string;

    beforeEach(async () => {
      // Create a test task for deletion
      testTask = await googleStore.createTask('list-1', {
        title: 'Task to Delete',
        notes: 'Test notes',
      });
      testTaskId = testTask.id;
    });

    it('should delete task successfully', async () => {
      // Get current store state
      const currentStore = useGoogleStore.getState();
      
      // Verify task exists before deletion
      const beforeDeletion = currentStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === testTaskId);
      expect(beforeDeletion).toBeDefined();

      // Delete the task
      await googleStore.deleteTask('list-1', testTaskId);
      
      // Get updated store state
      const updatedStore = useGoogleStore.getState();
      
      // Verify task was removed
      const afterDeletion = updatedStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === testTaskId);
      expect(afterDeletion).toBeUndefined();
    });

    it('should clean up task metadata on deletion', async () => {
      // Set metadata before deletion
      const metadata = {
        priority: 'high',
        labels: ['urgent'],
        subtasks: [],
      };
      setTaskMetadata(testTaskId, metadata);

      // Verify metadata exists
      expect(getTaskMetadata(testTaskId)).toBeDefined();

      // Delete the task
      await googleStore.deleteTask('list-1', testTaskId);
      
      // Verify metadata was cleaned up
      expect(getTaskMetadata(testTaskId)).toBeNull();
    });

    it('should handle deletion failures gracefully', async () => {
      // Create a test task specifically for this error scenario
      const taskToDeleteData = { title: 'Task to Delete', notes: 'Error test task' };
      const taskToDelete = await googleStore.createTask('list-1', taskToDeleteData);
      expect(taskToDelete).toBeDefined();
      
      const taskToDeleteId = taskToDelete!.id;

      // Use mockImplementationOnce with proper Error instance (research finding)
      mockInvoke.mockImplementationOnce(async (command: string): Promise<any> => {
        if (command === 'delete_task') {
          throw new Error('Delete failed');
        }
        throw new Error('Unexpected command in test');
      });

      // Attempt deletion (should fail)
      await expect(googleStore.deleteTask('list-1', taskToDeleteId)).rejects.toThrow('Delete failed');
      
      // Verify task still exists in store after failed deletion
      const afterFailedDeletion = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === taskToDeleteId);
      expect(afterFailedDeletion).toBeDefined();
    });

    it('should handle concurrent deletion attempts', async () => {
      // Create multiple unique tasks sequentially to avoid registry conflicts
      const tasks = [];
      const taskRegistry = (global as any).testTaskRegistry;
      
      for (let i = 1; i <= 3; i++) {
        const task = await googleStore.createTask('list-1', { title: `Task ${i}` });
        tasks.push(task);
        
        // Ensure each task is properly registered in the mock registry
        if (taskRegistry && task) {
          taskRegistry.set(task.id, {
            id: task.id,
            title: `Task ${i}`,
            status: 'needsAction',
            notes: `Task ${i} notes`,
          });
        }
      }

      // Wait a moment to ensure all tasks are fully registered
      await new Promise(resolve => setTimeout(resolve, 10));

      // Delete all tasks concurrently - each task should be successfully deleted
      const deletePromises = tasks.map(task => 
        googleStore.deleteTask('list-1', task.id)
      );

      // All deletions should succeed since each task exists independently
      await Promise.all(deletePromises);
      
      // Verify all tasks were deleted from the store
      const remainingTasks = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')?.tasks;
      tasks.forEach(task => {
        expect(remainingTasks?.find(t => t.id === task.id)).toBeUndefined();
      });
    });
  });

  describe('Task Completion Toggle', () => {
    let testTask: GoogleTask;
    let testTaskId: string;

    beforeEach(async () => {
      // Create a test task for completion toggle
      testTask = await googleStore.createTask('list-1', {
        title: 'Task to Complete',
        notes: 'Test notes',
      });
      testTaskId = testTask.id;
    });

    it('should toggle task completion from needsAction to completed', async () => {
      // Mark task as completed
      await googleStore.toggleTaskCompletion('list-1', testTaskId, true);
      
      // Get current store state
      const currentStore = useGoogleStore.getState();
      
      // Verify task is marked as completed
      const completedTask = currentStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === testTaskId);
      expect(completedTask?.status).toBe('completed');
      expect(completedTask?.completed).toBeDefined();
    });

    it('should toggle task completion from completed to needsAction', async () => {
      // First mark as completed
      await googleStore.toggleTaskCompletion('list-1', testTaskId, true);
      
      // Then mark as incomplete
      await googleStore.toggleTaskCompletion('list-1', testTaskId, false);
      
      // Get current store state
      const currentStore = useGoogleStore.getState();
      
      // Verify task is marked as needsAction
      const incompletedTask = currentStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === testTaskId);
      expect(incompletedTask?.status).toBe('needsAction');
      expect(incompletedTask?.completed).toBeUndefined();
    });

    it('should handle optimistic completion toggle', async () => {
      // Apply optimistic completion
      act(() => {
        googleStore.optimisticToggleTaskCompletion('list-1', testTaskId, true);
      });
      
      await waitFor(() => {
        const optimisticTask = useGoogleStore.getState().kanbanColumns.find(c => c.taskList.id === 'list-1')
          ?.tasks.find(t => t.id === testTaskId);
        expect(optimisticTask?.status).toBe('completed');
      });

      // Complete the actual toggle
      await act(async () => {
        await googleStore.toggleTaskCompletion('list-1', testTaskId, true);
      });
      
      // Verify final state
      await waitFor(() => {
        const finalTask = useGoogleStore.getState().kanbanColumns.find(c => c.taskList.id === 'list-1')
          ?.tasks.find(t => t.id === testTaskId);
        expect(finalTask?.status).toBe('completed');
      });
    });

    it('should handle completion toggle failures', async () => {
      // Create a test task specifically for this error scenario
      const taskToToggleData = { title: 'Task to Toggle', notes: 'Error test task' };
      const taskToToggle = await googleStore.createTask('list-1', taskToToggleData);
      expect(taskToToggle).toBeDefined();
      
      const taskToToggleId = taskToToggle!.id;

      // Use mockImplementationOnce with proper Error instance (research finding)
      mockInvoke.mockImplementationOnce(async (command: string): Promise<any> => {
        if (command === 'update_task') {
          throw new Error('Toggle failed');
        }
        throw new Error('Unexpected command in test');
      });

      // Attempt completion (should fail)
      await expect(googleStore.toggleTaskCompletion('list-1', taskToToggleId, true)).rejects.toThrow('Toggle failed');
      
      // Verify task status remains unchanged - should still be in store with original status
      const unchangedTask = googleStore.kanbanColumns.find(c => c.taskList.id === 'list-1')
        ?.tasks.find(t => t.id === taskToToggleId);
      expect(unchangedTask?.status).toBe('needsAction');
    });
  });

  describe('Task Hierarchy Operations', () => {
    let parentTask: GoogleTask;
    let childTask: GoogleTask;

    beforeEach(async () => {
      // Create parent task
      parentTask = await googleStore.createTask('list-1', {
        title: 'Parent Task',
        notes: 'Parent notes',
      });

      // Create child task
      childTask = await googleStore.createTask('list-1', {
        title: 'Child Task',
        notes: 'Child notes',
        parent: parentTask.id,
      });
    });

    it('should maintain parent-child relationships', async () => {
      expect(parentTask.id).toBeDefined();
      expect(childTask.parent).toBe(parentTask.id);
    });

    it('should handle moving child tasks independently', async () => {
      // Move child task to another list
      const movedChild = await googleStore.moveTask(childTask.id, 'list-1', 'list-2', undefined);
      
      expect(movedChild.id).toBe(childTask.id);
      // Parent field is preserved during move operations (correct behavior)
      expect(movedChild.parent).toBe(parentTask.id);
    });

    it('should handle moving parent tasks with children', async () => {
      // Move parent task (implementation depends on business logic)
      const movedParent = await googleStore.moveTask(parentTask.id, 'list-1', 'list-2', {});
      
      expect(movedParent.id).toBe(parentTask.id);
      
      // Child task behavior depends on implementation
      // This test documents the expected behavior
    });
  });

  describe('Error Recovery', () => {
    it('should handle network failures gracefully', async () => {
      // Use mockImplementationOnce with proper Error instance (research finding)
      mockInvoke.mockImplementationOnce(async (command: string): Promise<any> => {
        if (command === 'create_task') {
          throw new Error('Network unavailable');
        }
        throw new Error('Unexpected command in test');
      });

      const taskData = {
        title: 'Network Test Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Network unavailable');
    });

    it('should handle malformed API responses', async () => {
      // Mock malformed response
      mockInvoke.mockResolvedValueOnce(null);

      const taskData = {
        title: 'Malformed Response Task',
        notes: 'Test notes',
      };

      // This should handle the null response gracefully
      await expect(googleStore.createTask('list-1', taskData)).resolves.toBeNull();
    });

    it('should handle timeout scenarios', async () => {
      // Use mockImplementationOnce with proper Error instance for timeout (research finding)
      mockInvoke.mockImplementationOnce(async (command: string): Promise<any> => {
        if (command === 'create_task') {
          await new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Request timeout')), 100)
          );
        }
        throw new Error('Unexpected command in test');
      });

      const taskData = {
        title: 'Timeout Task',
        notes: 'Test notes',
      };

      await expect(googleStore.createTask('list-1', taskData)).rejects.toThrow('Request timeout');
    });
  });
}); 


END OF FILE: src/features/tasks/tests/task-operations.test.ts


====================================================================================================
FILE: src/features/tasks/tests/worker-queue.test.ts
DESCRIPTION: Worker queue tests
====================================================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { mockInvoke } from '../../../services/google/mockGoogleService';

// Mock the Tauri invoke function
vi.mock('@tauri-apps/api/core', () => ({
  invoke: vi.fn().mockImplementation(mockInvoke),
}));

// Mock the Web Worker
class MockWorker {
  private messageHandler: ((event: MessageEvent) => void) | null = null;
  private timeouts: NodeJS.Timeout[] = [];
  static forceFailure: boolean = false;
  static forceSuccess: boolean = false;

  constructor(scriptURL: string) {
    // Mock worker initialization
  }

  addEventListener(type: 'message', handler: (event: MessageEvent) => void) {
    if (type === 'message') {
      this.messageHandler = handler;
    }
  }

  set onmessage(handler: ((event: MessageEvent) => void) | null) {
    this.messageHandler = handler;
  }

  get onmessage() {
    return this.messageHandler;
  }

  postMessage(data: any) {
    // Send sync-started immediately (synchronously)
    if (this.messageHandler) {
      this.messageHandler({
        data: { type: 'sync-started' },
      } as MessageEvent);
    }
    
    // Use microtasks instead of setTimeout for better React compatibility
    this.simulateWorkerResponse(data);
  }

  private simulateWorkerResponse(operations: any[]) {
    if (!this.messageHandler) return;

    // Chain microtasks for sequential processing
    let promise = Promise.resolve();

    operations.forEach((op, index) => {
      promise = promise.then(() => {
        return new Promise<void>((resolve) => {
          // Use setTimeout only for the final delay, but shorter
          setTimeout(() => {
            if (!this.messageHandler) {
              resolve();
              return;
            }
            
            let success = Math.random() > 0.1; // 90% success rate by default
            if (MockWorker.forceFailure) success = false;
            if (MockWorker.forceSuccess) success = true;
            
            if (success) {
              this.messageHandler({
                data: {
                  type: 'operation-success',
                  payload: {
                    taskId: op.taskId,
                    operationId: op.operationId,
                    sourceListId: op.sourceListId,
                    targetListId: op.targetListId,
                  },
                },
              } as MessageEvent);
            } else {
              this.messageHandler({
                data: {
                  type: 'operation-failure',
                  payload: {
                    taskId: op.taskId,
                    operationId: op.operationId,
                    originalTaskTitle: op.originalTask?.title || 'Unknown Task',
                    sourceListId: op.sourceListId,
                    targetListId: op.targetListId,
                    error: 'Simulated failure',
                  },
                },
              } as MessageEvent);
            }
            resolve();
          }, 50); // Shorter delay for better test performance
        });
      });
    });

    // Send sync-finished after all operations complete
    promise.then(() => {
      return new Promise<void>((resolve) => {
        setTimeout(() => {
          if (this.messageHandler) {
            this.messageHandler({
              data: { type: 'sync-finished' },
            } as MessageEvent);
          }
          resolve();
        }, 50);
      });
    }).catch(() => {
      // Even if operations fail, we should send sync-finished
      if (this.messageHandler) {
        this.messageHandler({
          data: { type: 'sync-finished' },
        } as MessageEvent);
      }
    });
  }

  terminate() {
    // Clear all timeouts to prevent orphaned callbacks
    this.timeouts.forEach(timeout => clearTimeout(timeout));
    this.timeouts = [];
    this.messageHandler = null;
  }
}

// Mock the Worker constructor
Object.defineProperty(global, 'Worker', {
  value: MockWorker,
  writable: true,
});

// Import the hook that uses the worker
import { useTaskSyncQueue } from '../hooks/useTaskSyncQueue';
import { renderHook, act } from '@testing-library/react';

describe('Worker Queue Tests', () => {
  let mockAddToast: any;
  let originalWorker: any;

  beforeEach(() => {
    // Mock the addToast function
    mockAddToast = vi.fn();
    
    // Store original Worker
    originalWorker = global.Worker;
    
    // Set up mock Worker
    global.Worker = MockWorker as any;
    
    // Reset MockWorker flags
    MockWorker.forceFailure = false;
    MockWorker.forceSuccess = false;
  });

  afterEach(() => {
    // Restore original Worker
    global.Worker = originalWorker;
    
    // Reset MockWorker flags
    MockWorker.forceFailure = false;
    MockWorker.forceSuccess = false;
    
    // Clear mocks
    vi.clearAllMocks();
  });

  describe('Basic Queue Operations', () => {
    it('should initialize worker queue correctly', () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      expect(result.current.pendingOperations).toBeDefined();
      expect(result.current.processQueue).toBeDefined();
      expect(result.current.isSyncing).toBe(false);
    });

    it('should process single operation', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);

      // Wait for processing to complete
      await new Promise(resolve => setTimeout(resolve, 500));

      expect(result.current.isSyncing).toBe(false);
    });

    it('should process multiple operations sequentially', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operations = [
        {
          id: 'op-1',
          taskId: 'task-1',
          accountId: 'account-1',
          sourceListId: 'list-1',
          targetListId: 'list-2',
          operationId: 'op-1',
          originalTask: { title: 'Task 1' },
        },
        {
          id: 'op-2',
          taskId: 'task-2',
          accountId: 'account-1',
          sourceListId: 'list-1',
          targetListId: 'list-3',
          operationId: 'op-2',
          originalTask: { title: 'Task 2' },
        },
        {
          id: 'op-3',
          taskId: 'task-3',
          accountId: 'account-1',
          sourceListId: 'list-2',
          targetListId: 'list-1',
          operationId: 'op-3',
          originalTask: { title: 'Task 3' },
        },
      ];

      act(() => {
        result.current.pendingOperations.current.push(...operations);
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);

      // Wait for all operations to complete
      await new Promise(resolve => setTimeout(resolve, 1000));

      expect(result.current.isSyncing).toBe(false);
    });

    it('should handle empty queue', () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      act(() => {
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(false);
    });

    it('should prevent concurrent queue processing', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        // Start processing
        result.current.processQueue();
        // Try to start processing again (should be ignored)
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);

      // Wait for processing to complete
      await new Promise(resolve => setTimeout(resolve, 500));

      expect(result.current.isSyncing).toBe(false);
    });
  });

  describe('Operation Success Handling', () => {
    it('should handle successful operation', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Mock successful operation
      const mockWorker = new MockWorker('test-worker.js');
      mockWorker.postMessage = vi.fn().mockImplementation((operations) => {
        setTimeout(() => {
          (mockWorker as any).messageHandler({
            data: { type: 'sync-started' },
          });
          
          operations.forEach((op: any) => {
            (mockWorker as any).messageHandler({
              data: {
                type: 'operation-success',
                payload: {
                  taskId: op.taskId,
                  operationId: op.operationId,
                  sourceListId: op.sourceListId,
                  targetListId: op.targetListId,
                },
              },
            });
          });
          
          (mockWorker as any).messageHandler({
            data: { type: 'sync-finished' },
          });
        }, 100);
      });

      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      await new Promise(resolve => setTimeout(resolve, 300));

      expect(result.current.isSyncing).toBe(false);
    });

    it('should remove successful operations from queue', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      expect(result.current.pendingOperations.current).toHaveLength(1);

      await new Promise(resolve => setTimeout(resolve, 500));

      expect(result.current.pendingOperations.current).toHaveLength(0);
    });

    it('should handle mixed success and failure operations', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operations = [
        {
          id: 'op-1',
          taskId: 'task-1',
          accountId: 'account-1',
          sourceListId: 'list-1',
          targetListId: 'list-2',
          operationId: 'op-1',
          originalTask: { title: 'Success Task' },
        },
        {
          id: 'op-2',
          taskId: 'task-2',
          accountId: 'account-1',
          sourceListId: 'list-1',
          targetListId: 'list-3',
          operationId: 'op-2',
          originalTask: { title: 'Failure Task' },
        },
      ];

      // Mock mixed results
      const mockWorker = new MockWorker('test-worker.js');
      mockWorker.postMessage = vi.fn().mockImplementation((operations) => {
        setTimeout(() => {
          (mockWorker as any).messageHandler({
            data: { type: 'sync-started' },
          });
          
          // First operation succeeds
          (mockWorker as any).messageHandler({
            data: {
              type: 'operation-success',
              payload: {
                taskId: operations[0].taskId,
                operationId: operations[0].operationId,
                sourceListId: operations[0].sourceListId,
                targetListId: operations[0].targetListId,
              },
            },
          });
          
          // Second operation fails
          (mockWorker as any).messageHandler({
            data: {
              type: 'operation-failure',
              payload: {
                taskId: operations[1].taskId,
                operationId: operations[1].operationId,
                originalTaskTitle: operations[1].originalTask.title,
                sourceListId: operations[1].sourceListId,
                targetListId: operations[1].targetListId,
                error: 'Simulated failure',
              },
            },
          });
          
          (mockWorker as any).messageHandler({
            data: { type: 'sync-finished' },
          });
        }, 100);
      });

      act(() => {
        result.current.pendingOperations.current.push(...operations);
        result.current.processQueue();
      });

      await new Promise(resolve => setTimeout(resolve, 300));

      expect(result.current.isSyncing).toBe(false);
      expect(mockAddToast).toHaveBeenCalledWith(
        'error',
        'Sync Failed',
        expect.stringContaining('Failure Task')
      );
    });
  });

  describe('Operation Failure Handling', () => {
    it('should handle operation failure', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Force all operations to fail
      MockWorker.forceFailure = true;

      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Failed Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      await new Promise(resolve => setTimeout(resolve, 500));

      expect(result.current.isSyncing).toBe(false);
      expect(mockAddToast).toHaveBeenCalledWith(
        'error',
        'Sync Failed',
        expect.stringContaining('Failed Task')
      );
    });

    it('should retain failed operations in queue for retry', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Force all operations to fail
      MockWorker.forceFailure = true;
      
      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Failed Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      await new Promise(resolve => setTimeout(resolve, 500));

      // Failed operation should remain in queue
      expect(result.current.pendingOperations.current).toHaveLength(1);
    });

    it('should handle multiple consecutive failures', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Force all operations to fail
      MockWorker.forceFailure = true;
      
      const operations = [
        {
          id: 'op-1',
          taskId: 'task-1',
          accountId: 'account-1',
          sourceListId: 'list-1',
          targetListId: 'list-2',
          operationId: 'op-1',
          originalTask: { title: 'Failed Task 1' },
        },
        {
          id: 'op-2',
          taskId: 'task-2',
          accountId: 'account-1',
          sourceListId: 'list-1',
          targetListId: 'list-3',
          operationId: 'op-2',
          originalTask: { title: 'Failed Task 2' },
        },
      ];

      act(() => {
        result.current.pendingOperations.current.push(...operations);
        result.current.processQueue();
      });

      await new Promise(resolve => setTimeout(resolve, 500));

      expect(result.current.isSyncing).toBe(false);
      expect(mockAddToast).toHaveBeenCalledTimes(2);
    });
  });

  describe('Race Condition Prevention', () => {
    it('should prevent duplicate operations for same task', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operation1 = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      const operation2 = {
        id: 'op-2',
        taskId: 'task-1', // Same task ID
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-3',
        operationId: 'op-2',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation1);
        result.current.pendingOperations.current.push(operation2);
        result.current.processQueue();
      });

      expect(result.current.pendingOperations.current).toHaveLength(2);

      await new Promise(resolve => setTimeout(resolve, 500));

      // Both operations should be processed sequentially
      expect(result.current.isSyncing).toBe(false);
    });

    it('should handle rapid queue additions', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operations = Array.from({ length: 10 }, (_, i) => ({
        id: `op-${i}`,
        taskId: `task-${i}`,
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: `op-${i}`,
        originalTask: { title: `Task ${i}` },
      }));

      act(() => {
        operations.forEach(op => {
          result.current.pendingOperations.current.push(op);
        });
        result.current.processQueue();
      });

      expect(result.current.pendingOperations.current).toHaveLength(10);
      expect(result.current.isSyncing).toBe(true);

      await new Promise(resolve => setTimeout(resolve, 2000));

      expect(result.current.isSyncing).toBe(false);
    });

    it('should handle concurrent processQueue calls', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        // Call processQueue multiple times rapidly
        result.current.processQueue();
        result.current.processQueue();
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);

      await new Promise(resolve => setTimeout(resolve, 500));

      expect(result.current.isSyncing).toBe(false);
    });
  });

  describe('Worker Message Handling', () => {
    it('should handle sync-started message', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);
    });

    it('should handle sync-finished message', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);

      await new Promise(resolve => setTimeout(resolve, 500));

      expect(result.current.isSyncing).toBe(false);
    });

    it('should handle unknown message types gracefully', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Mock worker with unknown message type but still proper flow
      const mockWorker = new MockWorker('test-worker.js');
      mockWorker.postMessage = vi.fn().mockImplementation(() => {
        setTimeout(() => {
          // Send sync-started first
          (mockWorker as any).messageHandler({
            data: { type: 'sync-started' },
          });
          
          // Then unknown message type
          (mockWorker as any).messageHandler({
            data: { type: 'unknown-message-type' },
          });
          
          // Then sync-finished to complete the flow
          (mockWorker as any).messageHandler({
            data: { type: 'sync-finished' },
          });
        }, 50);
      });

      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      // First check that sync started
      expect(result.current.isSyncing).toBe(true);

      await new Promise(resolve => setTimeout(resolve, 200));

      // Should not crash or throw errors and should finish sync properly
      expect(result.current.isSyncing).toBe(false);
    });
  });

  describe('Edge Cases', () => {
    it('should handle worker termination', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operation = {
        id: 'op-1',
        taskId: 'task-1',
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: 'op-1',
        originalTask: { title: 'Test Task' },
      };

      act(() => {
        result.current.pendingOperations.current.push(operation);
        result.current.processQueue();
      });

      expect(result.current.isSyncing).toBe(true);

      // This should not crash the system
      await new Promise(resolve => setTimeout(resolve, 500));
    });

    it('should handle operations with missing data', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const incompleteOperation = {
        id: 'op-1',
        taskId: 'task-1',
        // Missing required fields
        operationId: 'op-1',
      };

      act(() => {
        result.current.pendingOperations.current.push(incompleteOperation as any);
        result.current.processQueue();
      });

      // Should handle gracefully without crashing
      expect(result.current.isSyncing).toBe(true);

      await new Promise(resolve => setTimeout(resolve, 500));
    });

    it('should handle very large queues', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const largeQueue = Array.from({ length: 100 }, (_, i) => ({
        id: `op-${i}`,
        taskId: `task-${i}`,
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: `op-${i}`,
        originalTask: { title: `Task ${i}` },
      }));

      act(() => {
        result.current.pendingOperations.current.push(...largeQueue);
        result.current.processQueue();
      });

      expect(result.current.pendingOperations.current).toHaveLength(100);
      expect(result.current.isSyncing).toBe(true);

      // Should not crash or hang
      await new Promise(resolve => setTimeout(resolve, 1000));
    });
  });

  describe('Memory Management', () => {
    it('should clean up completed operations', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operations = Array.from({ length: 5 }, (_, i) => ({
        id: `op-${i}`,
        taskId: `task-${i}`,
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: `op-${i}`,
        originalTask: { title: `Task ${i}` },
      }));

      act(() => {
        result.current.pendingOperations.current.push(...operations);
        result.current.processQueue();
      });

      expect(result.current.pendingOperations.current).toHaveLength(5);

      await new Promise(resolve => setTimeout(resolve, 1000));

      // Most operations should be cleaned up (assuming some succeed)
      expect(result.current.pendingOperations.current.length).toBeLessThan(5);
    });

    it('should handle queue overflow gracefully', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      // Add operations beyond reasonable limit
      const overflowOperations = Array.from({ length: 1000 }, (_, i) => ({
        id: `op-${i}`,
        taskId: `task-${i}`,
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: `op-${i}`,
        originalTask: { title: `Task ${i}` },
      }));

      act(() => {
        result.current.pendingOperations.current.push(...overflowOperations);
        result.current.processQueue();
      });

      // Should handle without crashing
      expect(result.current.isSyncing).toBe(true);
    });
  });

  describe('Performance Tests', () => {
    it('should process operations within reasonable time', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const operations = Array.from({ length: 10 }, (_, i) => ({
        id: `op-${i}`,
        taskId: `task-${i}`,
        accountId: 'account-1',
        sourceListId: 'list-1',
        targetListId: 'list-2',
        operationId: `op-${i}`,
        originalTask: { title: `Task ${i}` },
      }));

      const startTime = Date.now();

      act(() => {
        result.current.pendingOperations.current.push(...operations);
        result.current.processQueue();
      });

      await new Promise(resolve => setTimeout(resolve, 2000));

      const endTime = Date.now();
      const duration = endTime - startTime;

      // Should complete within reasonable time (allowing for test environment)
      expect(duration).toBeLessThan(5000); // 5 seconds max
    });

    it('should handle rapid queue additions efficiently', async () => {
      const { result } = renderHook(() => useTaskSyncQueue(mockAddToast));
      
      const startTime = Date.now();

      act(() => {
        for (let i = 0; i < 50; i++) {
          result.current.pendingOperations.current.push({
            id: `op-${i}`,
            taskId: `task-${i}`,
            accountId: 'account-1',
            sourceListId: 'list-1',
            targetListId: 'list-2',
            operationId: `op-${i}`,
            originalTask: { title: `Task ${i}` },
          });
        }
        result.current.processQueue();
      });

      const additionTime = Date.now() - startTime;

      // Queue addition should be very fast
      expect(additionTime).toBeLessThan(100); // 100ms max
    });
  });
}); 

END OF FILE: src/features/tasks/tests/worker-queue.test.ts


====================================================================================================
EXPORT COMPLETE
Total files exported: 30
Export completed at: 07/09/2025 12:30:57
====================================================================================================

SOLUTION: Task Creation JSON Parse Error Fix

=================================================================================
ROOT CAUSE IDENTIFIED
=================================================================================
The "Failed to parse JSON string: expected value at line 1 column 1" error is coming from Tauri's IPC serialization layer. When Tauri can't serialize the Rust response, it returns an empty string, causing the JSON parse error.

=================================================================================
CRITICAL ISSUES FOUND
=================================================================================

1. MISSING SERDE ATTRIBUTES ON NESTED TYPES
   - TaskMetadata and TaskLink structs may not have proper Serialize/Deserialize derives
   - If ANY nested type lacks Serialize, the entire response fails silently

2. FIELD NAME MISMATCH (snake_case vs camelCase)
   - Rust returns: "self_link", "web_view_link" 
   - TypeScript expects: "selfLink", "webViewLink"
   - This mismatch causes serialization/deserialization failures

3. METADATA NOT LOADED ON FETCH
   - get_tasks command doesn't JOIN the task_metadata table
   - Metadata is saved but never retrieved

=================================================================================
IMMEDIATE FIXES REQUIRED
=================================================================================

STEP 1: Add serde rename to match TypeScript expectations
----------------------------------------
File: src-tauri/src/commands/tasks/api.rs

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]  // <-- ADD THIS
pub struct GoogleTask {
    pub id: String,
    pub title: String,
    pub notes: Option<String>,
    pub status: String,
    pub due: Option<String>,
    pub completed: Option<String>,
    pub updated: Option<String>,
    pub parent: Option<String>,
    pub position: Option<String>,
    pub kind: Option<String>,
    pub etag: Option<String>,
    #[serde(rename = "selfLink")]  // This can be removed with rename_all
    pub self_link: Option<String>,
    pub links: Option<Vec<TaskLink>>,
    pub hidden: Option<bool>,
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TaskMetadata>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]  // <-- ADD THIS
pub struct TaskMetadata {
    pub priority: Option<String>,
    pub labels: Option<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]  // <-- ADD THIS
pub struct TaskLink {
    #[serde(rename = "type")]
    pub link_type: String,
    pub description: String,
    pub link: String,
}
```

STEP 2: Fix get_tasks to load metadata
----------------------------------------
File: src-tauri/src/commands/tasks/api.rs

In the get_tasks function, after loading tasks from Google, add:

```rust
// After getting tasks from Google API...
let items = tasks_data["items"].as_array()
    .ok_or("Invalid response format: missing items")?;

// Load task metadata from local database
let db_manager = db.lock().unwrap();
let conn = db_manager.get_connection()
    .map_err(|e| format!("Failed to get database connection: {}", e))?;

let mut stmt = conn.prepare(
    "SELECT google_task_id, priority, labels FROM task_metadata WHERE google_list_id = ?1"
).map_err(|e| format!("Failed to prepare statement: {}", e))?;

let metadata_map: HashMap<String, TaskMetadata> = stmt.query_map([&task_list_id], |row| {
    let google_task_id: String = row.get(0)?;
    let priority: Option<String> = row.get(1)?;
    let labels_json: Option<String> = row.get(2)?;
    let labels = labels_json.and_then(|json| serde_json::from_str(&json).ok());
    
    Ok((google_task_id, TaskMetadata { priority, labels }))
}).map_err(|e| format!("Failed to query metadata: {}", e))?
    .filter_map(Result::ok)
    .collect();

// Now build GoogleTask objects with metadata
let tasks: Vec<GoogleTask> = items.iter()
    .map(|item| {
        let task_id = item["id"].as_str().unwrap_or("").to_string();
        let metadata = metadata_map.get(&task_id).cloned();
        
        GoogleTask {
            id: task_id,
            title: item["title"].as_str().unwrap_or("").to_string(),
            // ... other fields ...
            metadata,
        }
    })
    .collect();
```

STEP 3: Debug test command
----------------------------------------
Add this temporary command to verify serialization:

```rust
#[tauri::command]
pub async fn test_task_serialization() -> Result<String, String> {
    let test_task = GoogleTask {
        id: "test123".to_string(),
        title: "Test Task".to_string(),
        notes: Some("Test notes".to_string()),
        status: "needsAction".to_string(),
        due: None,
        completed: None,
        updated: Some("2025-07-25T22:26:55.677Z".to_string()),
        parent: None,
        position: Some("00000000000000000000".to_string()),
        kind: Some("tasks#task".to_string()),
        etag: Some("\"test-etag\"".to_string()),
        self_link: Some("https://test.com".to_string()),
        links: Some(vec![]),
        hidden: Some(false),
        deleted: Some(false),
        metadata: Some(TaskMetadata {
            priority: Some("high".to_string()),
            labels: Some(vec!["work".to_string(), "urgent".to_string()]),
        }),
    };
    
    match serde_json::to_string(&test_task) {
        Ok(json) => {
            println!("✅ Serialization successful: {}", json);
            Ok(json)
        }
        Err(e) => {
            println!("❌ Serialization failed: {}", e);
            Err(format!("Serialization error: {}", e))
        }
    }
}
```

STEP 4: Frontend type alignment
----------------------------------------
File: src/types/google.ts

Ensure TypeScript types match exactly:

```typescript
export interface GoogleTask {
  id: string;
  title: string;
  notes?: string;
  status: string;
  due?: string;
  completed?: string;
  updated?: string;
  parent?: string;
  position?: string;
  kind?: string;
  etag?: string;
  selfLink?: string;  // Should match Rust's serde rename
  links?: TaskLink[];
  hidden?: boolean;
  deleted?: boolean;
  metadata?: TaskMetadata;
}

export interface TaskMetadata {
  priority?: string;
  labels?: string[];
}

export interface TaskLink {
  type: string;
  description: string;
  link: string;
}
```

=================================================================================
TESTING PLAN
=================================================================================

1. Add the test command to lib.rs invocation list
2. Call test_task_serialization from frontend console:
   ```javascript
   await window.__TAURI__.invoke('test_task_serialization')
   ```
3. If it returns valid JSON, the serde attributes are working
4. If it returns empty/error, check Rust console for serialization errors

=================================================================================
VERIFICATION STEPS
=================================================================================

1. Rebuild backend: `cd src-tauri && cargo build`
2. Check for any serde-related compilation errors
3. Run the app and create a task
4. Check both frontend and backend console logs
5. Verify task appears with metadata after refresh

=================================================================================
EXPECTED OUTCOME
=================================================================================

After these fixes:
1. No more "Failed to parse JSON string" errors
2. Tasks create successfully without errors
3. Metadata (priority/labels) persists across refreshes
4. Frontend receives properly formatted camelCase JSON

The core issue is Tauri's silent serialization failure when field names don't match or types aren't serializable.
/**
 * ROBUST SECTION UI INTEGRATION TEST
 * 
 * This test verifies that section functionality works correctly in REAL integration scenarios.
 * Uses the REAL store implementation and tests actual UI interactions to catch real bugs.
 * 
 * Key improvements:
 * - Uses real store implementation (no mocking of core logic)
 * - Tests actual UI interactions and DOM events 
 * - Validates both store state AND rendered output
 * - Tests error scenarios that occur in production
 * - Tests cross-store synchronization (section store + elements store)
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import React, { createContext, useContext } from 'react';
import { createStore, useStore } from 'zustand';
import { render, act, waitFor, screen, RenderOptions } from '@testing-library/react';
import { createUnifiedTestStore } from '../../../tests/helpers/createUnifiedTestStore';
import { ElementId, SectionId } from '@/features/canvas/types/enhanced.types';
import '@testing-library/jest-dom';

vi.mock('@/features/canvas/hooks/useViewportCulling', () => ({
  useViewportCulling: () => ({
    cullElements: (elements) => elements,
    visibleElements: new Map(),
  }),
}));

// 1. Define the store type and create a context
type UnifiedTestStore = ReturnType<typeof createUnifiedTestStore>;
const StoreContext = createContext<UnifiedTestStore | undefined>(undefined);

// 2. Create a custom hook to access the store, as per Zustand docs
function useTestStore<T>(selector: (state: any) => T): T {
  const store = useContext(StoreContext);
  if (!store) {
    throw new Error('useTestStore must be used within a StoreProvider');
  }
  return useStore(store, selector);
}

// 3. Create a simple component that uses the hook
const TestDisplayComponent: React.FC = () => {
  const sections = useTestStore((s) => s.sections);
  const elements = useTestStore((s) => s.elements);

  return (
    <div>
      <h1 data-testid="sections-count">Sections: {sections.size}</h1>
      <h2 data-testid="elements-count">Elements: {elements.size}</h2>
      {[...sections.values()].map((section) => (
        <div key={section.id} data-testid={`section-${section.id}`}>
          <p>Section {section.id}</p>
          <p>Children: {[...section.childElementIds].join(', ')}</p>
        </div>
      ))}
    </div>
  );
};

// 4. Create a custom render function that provides the store
const renderWithStore = (
  ui: React.ReactElement,
  store: UnifiedTestStore
) => {
  return render(
    <StoreContext.Provider value={store}>{ui}</StoreContext.Provider>
  );
};

describe('Robust UI Integration with Zustand Store', () => {
  let store: UnifiedTestStore;

  beforeEach(() => {
    store = createUnifiedTestStore();
  });

  it('should render initial state correctly', () => {
    renderWithStore(<TestDisplayComponent />, store);
    expect(screen.getByTestId('sections-count')).toHaveTextContent('Sections: 0');
    expect(screen.getByTestId('elements-count')).toHaveTextContent('Elements: 0');
  });

  it('should re-render when a section is created', async () => {
    renderWithStore(<TestDisplayComponent />, store);
    let newSectionId: SectionId;

    // Wait for the component to subscribe to the store
    await waitFor(() => {});

    act(() => {
      newSectionId = store.getState().createSection(0, 0, 100, 100);
    });
    
    await waitFor(() => {
      expect(screen.getByTestId('sections-count')).toHaveTextContent('Sections: 1');
    });
    expect(screen.getByTestId(`section-${newSectionId}`)).toBeInTheDocument();
  });

  it('should re-render when an element is added to a section', async () => {
    renderWithStore(<TestDisplayComponent />, store);
    let newSectionId: SectionId;
    
    // Wait for the component to subscribe to the store
    await waitFor(() => {});

    act(() => {
      newSectionId = store.getState().createSection(0, 0, 200, 200);
      store.getState().createElement({
        id: 'el1',
        x: 50,
        y: 50,
        width: 10,
        height: 10,
        type: 'shape',
        shapeType: 'rectangle',
      });
    });

    await waitFor(() => {
      expect(screen.getByTestId('sections-count')).toHaveTextContent('Sections: 1');
      expect(screen.getByTestId('elements-count')).toHaveTextContent('Elements: 1');
      expect(screen.getByTestId(`section-${newSectionId}`)).toHaveTextContent('Children: el1');
    });
  });
});

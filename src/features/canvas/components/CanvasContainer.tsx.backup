// src/components/canvas/CanvasContainer.tsx
import React, { useRef, useCallback, useState } from 'react';
import { Stage } from 'react-konva';
import Konva from 'konva';
import { CanvasLayerManager } from '../layers/CanvasLayerManager';
import { CanvasEventHandler } from './CanvasEventHandler';
import { useViewportControls } from '../hooks/useViewportControls';
import { useSelectionManager } from '../hooks/useSelectionManager';
import { useCanvasHistory } from '../hooks/useCanvasHistory';
import { useCanvasStore } from '../stores';
import type { CanvasElement, ElementId, SectionId } from '../types/enhanced.types';
import { toElementId } from '../types/compatibility';
import { designSystem } from '../../../design-system';

interface CanvasContainerProps {
  width: number;
  height: number;
  onElementSelect?: (element: CanvasElement) => void;
  onStartTextEdit?: (elementId: string) => void;
  className?: string;
}

/**
 * CanvasContainer - Main canvas container component
 * - App state coordination and layout shell
 * - Integration point for all stores and hooks
 * - Maintains backward compatibility with existing components
 * - Performance monitoring integration
 */
export const CanvasContainer: React.FC<CanvasContainerProps> = ({
  width,
  height,
  onElementSelect,
  onStartTextEdit,
  className = ''
}) => {  // Stage reference
  const stageRef = useRef<Konva.Stage | null>(null);

  // Custom hooks
  const { zoom, pan } = useViewportControls();
  const { selectedElementIds } = useSelectionManager();
  const { addToHistory } = useCanvasHistory();  // Store hooks - FIXED: Use the new modular store consistently
  const elementsMap = useCanvasStore((state) => state.elements);
  const updateElement = useCanvasStore((state) => state.updateElement);
  const updateSection = useCanvasStore((state) => state.updateSection);
  const setEditingTextId = useCanvasStore((state) => state.setEditingTextId);
  const selectedTool = useCanvasStore((state) => state.selectedTool) as any; // Temporary type assertion

  // Drawing state for CanvasEventHandler
  const [isDrawingConnector, setIsDrawingConnector] = useState(false);
  const [connectorStart, setConnectorStart] = useState<{ x: number; y: number; elementId?: ElementId; anchor?: string } | null>(null);
  const [connectorEnd, setConnectorEnd] = useState<{ x: number; y: number; elementId?: ElementId; anchor?: string } | null>(null);
  const [isDrawingSection, setIsDrawingSection] = useState(false);
  const [previewSection, setPreviewSection] = useState<{ x: number; y: number; width: number; height: number } | null>(null);  
  // Combined update function for elements and sections
  const handleElementOrSectionUpdate = useCallback((id: ElementId | SectionId, updates: Partial<CanvasElement>) => {
    // Check if this is a section ID (sections have their own update function)
    if (typeof id === 'string' && id.includes('section')) {
      // This is a simplified check - you might need a more robust type check
      updateSection(id as SectionId, updates as any);
    } else {
      updateElement(id as ElementId, updates);
    }
  }, [updateElement, updateSection]);

  // Handle element drag end
  const handleElementDragEnd = useCallback((e: Konva.KonvaEventObject<DragEvent>, elementId: string) => {
    const node = e.target;
    updateElement(toElementId(elementId), {
      x: node.x(),
      y: node.y()
    });
    
    addToHistory(`Move ${elementId}`, [], [], {
      elementIds: [elementId],
      operationType: 'move',
      affectedCount: 1
    });
  }, [updateElement, addToHistory]);

  // Handle text editing start
  const handleStartTextEdit = useCallback((elementId: string) => {
    setEditingTextId(elementId);
    onStartTextEdit?.(elementId);
  }, [setEditingTextId, onStartTextEdit]);

  // Handle element selection (called by CanvasEventHandler)
  const handleElementClick = useCallback((e: Konva.KonvaEventObject<MouseEvent>, element: CanvasElement) => {
    e.cancelBubble = true;
    onElementSelect?.(element);
  }, [onElementSelect]);
  // Performance monitoring
  // const performance = useCanvasPerformance(elements.length);

  // Handle element selection
  const handleElementClick = useCallback((e: Konva.KonvaEventObject<MouseEvent>, element: CanvasElement) => {
    e.cancelBubble = true;
    selectSingle(element.id);
    onElementSelect?.(element);
  }, [selectSingle, onElementSelect]);
  // Handle element drag end
  const handleElementDragEnd = useCallback((e: Konva.KonvaEventObject<DragEvent>, elementId: string) => {
    const node = e.target;
    updateElement(toElementId(elementId), {
      x: node.x(),
      y: node.y()
    });
    
    addToHistory(`Move ${elementId}`, [], [], {
      elementIds: [elementId],
      operationType: 'move',
      affectedCount: 1
    });
  }, [updateElement, addToHistory]);

  // Handle text editing start
  const handleStartTextEdit = useCallback((elementId: string) => {
    setEditingTextId(elementId);
    onStartTextEdit?.(elementId);
  }, [setEditingTextId, onStartTextEdit]);
  // Handle stage click (deselection)
  const handleStageClick = useCallback((e: Konva.KonvaEventObject<MouseEvent>) => {
    // Only deselect if clicking on empty space (stage itself or background layer)
    const targetName = e.target.name?.() || '';
    const targetId = e.target.id?.() || '';
    
    // Deselect if clicking on:
    // 1. The stage itself
    // 2. Background layer
    // 3. Any layer that's not an interactive element
    if (e.target === stageRef.current || 
        targetName === 'background-layer' ||
        targetName === 'background-rect' ||
        (!targetId || targetId === '') ||
        e.target.getType() === 'Stage') {
      clearSelection();
    }
  }, [clearSelection]);

  // Handle wheel events for zoom
  const handleWheel = useCallback((e: Konva.KonvaEventObject<WheelEvent>) => {
    e.evt.preventDefault();
    
    const stage = stageRef.current;
    if (!stage) return;

    const scaleBy = 1.1;
    const pointer = stage.getPointerPosition();
    if (!pointer) return;

    if (e.evt.deltaY < 0) {
      zoomIn(scaleBy);
    } else {
      zoomOut(scaleBy);
    }
  }, [zoomIn, zoomOut]);

  // Keyboard event handling
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {      // Handle delete key
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElementIds.size > 0) {
        selectedElementIds.forEach((id: string) => {
          updateElement(toElementId(id), { deleted: true } as any); // Mark as deleted
        });
        addToHistory(`Delete ${selectedElementIds.size} elements`, [], [], {
          elementIds: Array.from(selectedElementIds),
          operationType: 'delete',
          affectedCount: selectedElementIds.size
        });
        
        clearSelection();
      }
      
      // Handle escape key
      if (e.key === 'Escape') {
        clearSelection();
        setIsDrawing(false);
        setIsDrawingConnector(false);
        setIsDrawingSection(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedElementIds, updateElement, addToHistory, clearSelection]);

  return (
    <div className={`canvas-container ${className}`}>
      <Stage
        ref={stageRef}
        width={width}
        height={height}
        onClick={handleStageClick}
        onWheel={handleWheel}
        draggable={selectedTool === 'pan'}
        x={pan.x}
        y={pan.y}
        scaleX={zoom}
        scaleY={zoom}        style={{
          display: 'block',
          backgroundColor: designSystem.canvasStyles.background,
          cursor: selectedTool === 'pan' ? 'grab' : 
                  selectedTool.startsWith('connector-') ? 'crosshair' : 'default',
          userSelect: 'none',
          WebkitUserSelect: 'none',
        }}
      >        <CanvasLayerManager
          stageWidth={width}
          stageHeight={height}
          stageRef={stageRef}
          elements={elementsMap as Map<ElementId | SectionId, CanvasElement>}
          selectedElementIds={selectedElementIds}
          onElementUpdate={handleElementOrSectionUpdate}
          onElementDragEnd={handleElementDragEnd}
          onElementClick={handleElementClick}
          onStartTextEdit={handleStartTextEdit}
          isDrawing={isDrawing}
          currentPath={currentPath}
          isDrawingConnector={isDrawingConnector}
          connectorStart={connectorStart}
          connectorEnd={connectorEnd}
          isDrawingSection={isDrawingSection}
          previewSection={previewSection}
        />
      </Stage>
    </div>
  );
};

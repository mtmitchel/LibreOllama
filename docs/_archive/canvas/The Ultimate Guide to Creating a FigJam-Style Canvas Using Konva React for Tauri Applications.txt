# The Ultimate Guide to Creating a FigJam-Style Canvas Using Konva React for Tauri Applications

## Table of Contents

### **Part I: Foundation & Architecture**

#### **Chapter 1: Understanding FigJam & Core Concepts**
1.1 What Makes FigJam Special[1][2]
- Infinite canvas paradigm[2][3]
- Real-time collaborative features[1][4]
- Intuitive drawing and annotation tools[5][6]
- Structured sections and organization[7]

1.2 Essential FigJam Features to Implement
- Drawing tools (marker, highlighter, washi tape)[5]
- Shapes and connectors[2][7]
- Sticky notes and text annotations[2][8]
- Sections for organization[7]
- Cursor chat and real-time collaboration[2][9]

#### **Chapter 2: Technology Stack Overview**
2.1 Tauri Architecture Fundamentals[10][11]
- Rust backend for system operations[12][11]
- WebView component integration[11]
- IPC bridge communication patterns[11][13]
- Cross-platform desktop deployment[12]

2.2 React + Konva Integration[14][15]
- Konva.js 2D canvas library overview[14][16]
- React-Konva declarative bindings[14]
- Stage and Layer component hierarchy[14][17]
- Performance considerations for canvas applications[15]

2.3 State Management Architecture[18]
- Zustand for canvas state management[19]
- Event handling patterns in React Konva[18]
- Coordinate system management[3]
- Memory optimization strategies[19]

### **Part II: Core Canvas Implementation**

#### **Chapter 3: Setting Up the Infinite Canvas**
3.1 Canvas Foundation Setup[14][3]
- Stage and Layer configuration[14]
- Viewport management and virtual coordinates[3]
- Zoom and pan functionality[3][20]
- Responsive canvas sizing[14]

3.2 Coordinate System Design[3]
- Real vs virtual coordinate mapping[3]
- Scale and offset calculations[3]
- Mouse event coordinate conversion[3]
- Boundary handling for infinite scroll[3][20]

3.3 Performance Optimization[21]
- Viewport culling techniques[21]
- Layer-based rendering optimization[14]
- Memory management for large canvases[21]
- Frame rate optimization strategies[21]

#### **Chapter 4: Drawing Tools Implementation**
4.1 Basic Drawing Tools[17][22]
- Pen and marker tools[5][17]
- Free drawing with Konva.Line[22]
- Stroke customization (color, width, style)[5]
- Highlighter with transparency effects[5]

4.2 Shape Tools[14][23]
- Rectangle, circle, and polygon creation[14][23]
- Shape selection and manipulation[23]
- Handle-based transformation[23]
- Shape styling and properties[14]

4.3 Text and Annotation Tools[14]
- Text input and editing systems[14]
- Rich text formatting options[19]
- Text positioning and alignment[14]
- Dynamic text sizing and wrapping[14]

#### **Chapter 5: Element Selection & Transformation**
5.1 Selection System Architecture[23][24]
- Single and multi-element selection[23]
- Selection rectangle implementation[23]
- Visual selection indicators[23]
- Keyboard shortcuts integration[23]

5.2 Transformation Controls[24]
- Resize handles and constraints[24]
- Rotation controls and snapping[24]
- Move and drag functionality[23]
- Proportional scaling with modifier keys[24]

5.3 Advanced Selection Features[19]
- Lasso selection tools[25]
- Property-based selection queries[19]
- Hierarchical element selection[19]
- Bulk operation support[19]

### **Part III: Advanced Features**

#### **Chapter 6: Sticky Notes & Sections**
6.1 Sticky Note Implementation[8]
- Note creation and styling[8]
- Color customization system[8]
- Text editing within notes[8]
- Note clustering and organization[8]

6.2 Section Management[7][19]
- Section creation and boundaries[19]
- Element containment logic[19]
- Section-based organization[7]
- Nested section support[19]

6.3 Dynamic Grouping[8]
- Automatic element grouping[8]
- Manual group creation[23]
- Group transformation behavior[23]
- Group hierarchy management[19]

#### **Chapter 7: Connectors & Relationships**
7.1 Connection System Design[19]
- Dynamic connector creation[19]
- Anchor point calculation[19]
- Connection validation and cleanup[19]
- Visual connection rendering[19]

7.2 Smart Connectors[2]
- Auto-routing algorithms[2]
- Snap-to-grid functionality[2]
- Connection persistence during element moves[19]
- Multi-point connector support[2]

7.3 Relationship Management[19]
- Element relationship tracking[19]
- Connection metadata storage[19]
- Relationship-based operations[19]
- Visual relationship indicators[19]

#### **Chapter 8: Collaborative Features**
8.1 Real-time Synchronization[26][27]
- WebSocket integration patterns[26][27]
- State synchronization strategies[26]
- Conflict resolution mechanisms[26][28]
- User presence indicators[9]

8.2 Collaborative Drawing[27]
- Multi-user drawing coordination[27]
- Drawing action broadcasting[26]
- Latency handling and prediction[26]
- Out-of-order message handling[26]

8.3 User Management[9]
- Cursor tracking and display[2][9]
- User permissions and roles[9]
- Session management[9]
- Collaborative editing controls[9]

### **Part IV: Integration & Optimization**

#### **Chapter 9: Tauri Integration**
9.1 Frontend-Backend Communication[13]
- Tauri command implementation[29][12]
- IPC message handling[11]
- File system operations[12]
- Native system integration[12]

9.2 Data Persistence[19]
- SQLCipher database integration[19]
- Canvas state serialization[23]
- Auto-save functionality[19]
- Version history management[9]

9.3 Cross-Platform Considerations[10]
- Platform-specific optimizations[10]
- Native menu integration[10]
- Window management[30]
- Distribution and packaging[10]

#### **Chapter 10: Performance & Scalability**
10.1 Memory Management[19]
- Viewport culling implementation[19]
- Element lifecycle management[19]
- Memory leak prevention[19]
- Garbage collection optimization[19]

10.2 Rendering Optimization[21]
- Layer-based rendering strategies[21]
- WebGL acceleration techniques[21]
- Frame rate monitoring[21]
- Performance profiling tools[19]

10.3 Large Canvas Handling[21]
- Spatial indexing with quadtrees[19]
- Level-of-detail rendering[21]
- Progressive loading strategies[21]
- Virtual canvas techniques[3]

### **Part V: Advanced Topics**

#### **Chapter 11: Testing & Quality Assurance**
11.1 Canvas Testing Strategies[19]
- Store-first testing patterns[19]
- Canvas interaction testing[19]
- Performance validation[19]
- Memory leak detection[19]

11.2 Test Architecture[19]
- Vitest configuration for canvas apps[19]
- Mock strategies for Konva components[19]
- Real store instance testing[19]
- Integration test patterns[19]

11.3 Quality Metrics[19]
- Test coverage requirements[19]
- Performance benchmarking[19]
- Memory usage monitoring[19]
- User experience validation[19]

#### **Chapter 12: Deployment & Distribution**
12.1 Build Configuration[30]
- Tauri build optimization[30]
- Asset bundling strategies[30]
- Code splitting for performance[30]
- Bundle size optimization[30]

12.2 Platform Distribution[10]
- Windows MSI packages[10]
- macOS DMG creation[10]
- Linux AppImage/Flatpak[10]
- Auto-update implementation[10]

12.3 Production Considerations[19]
- Error handling and recovery[19]
- Logging and diagnostics[19]
- User feedback collection[19]
- Performance monitoring[19]

### **Part VI: Extension & Customization**

#### **Chapter 13: Plugin Architecture**
13.1 Extensibility Design
- Plugin system architecture
- Custom tool development
- Theme and styling extensions
- Third-party integrations

13.2 API Design
- Public API surface design
- Event system for plugins
- Configuration management
- Plugin lifecycle management

#### **Chapter 14: Advanced Use Cases**
14.1 Specialized Applications
- Educational whiteboarding[7]
- Technical diagramming[31]
- Creative collaboration workflows[1]
- Business process mapping[32]

14.2 Integration Patterns
- External data source integration
- Export and import functionality[23]
- Cloud storage synchronization
- Third-party tool connectivity

### **Appendices**

#### **Appendix A: Code Examples & Templates**
- Starter project templates
- Common implementation patterns
- Debugging utilities
- Performance monitoring tools

#### **Appendix B: Troubleshooting Guide**
- Common issues and solutions
- Performance debugging techniques
- Memory leak investigation
- Cross-platform compatibility issues

#### **Appendix C: Resources & References**
- Konva.js documentation links[14]
- Tauri development resources[10]
- React best practices for canvas[15]
- Performance optimization guides[21]

This comprehensive table of contents provides a structured approach to building a production-ready FigJam-style canvas application using Konva React within a Tauri desktop application. Each chapter builds upon previous concepts while providing practical implementation guidance, performance considerations, and real-world deployment strategies.

# Chapter 1: Understanding FigJam & Core Concepts

## What Makes FigJam Special

FigJam represents a paradigm shift in digital collaboration, transforming how teams think, create, and organize ideas together. Unlike traditional design tools that focus on precise layouts and pixel-perfect details, FigJam embraces the spontaneous, exploratory nature of whiteboard sessions[1][2]. This fundamental difference in philosophy makes FigJam particularly powerful for early-stage ideation, collaborative problem-solving, and visual communication.

At its core, FigJam operates on the principle of **infinite canvas freedom**. While the canvas isn't truly infinite due to memory constraints, it provides an expansive digital space that feels limitless compared to traditional whiteboards[3]. This virtual environment eliminates the physical constraints that often limit brainstorming sessions, allowing teams to explore ideas without worrying about running out of space.

The tool's **inclusive design philosophy** ensures that anyone can participate meaningfully, regardless of their technical background or design experience[2]. FigJam files are lightweight, inclusive environments where team members can contribute ideas, provide feedback, and collaborate without needing specialized knowledge of design software. This accessibility is crucial for cross-functional teams where not everyone has design training.

### The Infinite Canvas Paradigm

The infinite canvas concept fundamentally changes how we approach visual collaboration. Unlike physical whiteboards with clear boundaries, FigJam's digital canvas provides a sense of limitless space that encourages expansive thinking[4]. This paradigm shift offers several key advantages:

**Spatial Freedom**: Teams can spread out their ideas across vast digital space, creating natural groupings and connections between concepts without being constrained by physical boundaries. This spatial freedom enables more organic idea development and allows for multiple conversations to happen simultaneously in different areas of the canvas.

**Scalable Collaboration**: The infinite canvas supports teams of any size, from intimate brainstorming sessions to large-scale workshops involving dozens of participants[5]. Each team member can claim their own space on the canvas while still being part of the larger collaborative effort.

**Persistent Workspace**: Unlike physical whiteboards that must be erased, the digital canvas preserves all work indefinitely. This persistence enables teams to build on previous sessions, reference earlier discussions, and maintain continuity across multiple meetings[6].

### Real-time Collaborative Features

FigJam's real-time collaboration capabilities create a truly shared workspace where multiple team members can contribute simultaneously[5]. This synchronous collaboration is powered by sophisticated conflict resolution algorithms that ensure consistency across all connected clients[7].

**Live Editing**: Multiple users can edit the same board simultaneously, with changes appearing instantly for all participants. The system handles concurrent edits gracefully, maintaining document consistency even when multiple users are working on the same elements[7].

**Cursor Chat**: One of FigJam's most innovative features is cursor chat, which enables lightweight, temporary communication directly on the canvas[8][9]. Team members can type live messages that appear next to their cursors, creating a natural way to ask questions, provide feedback, or react to ideas without disrupting the flow of collaboration. These messages are ephemeral by design, disappearing after a few seconds to keep the canvas focused on the work rather than cluttered with old conversations.

**Real-time Presence**: FigJam shows the live cursors of all active participants, creating awareness of who is present and what they're working on[4]. This presence indicator helps coordinate activities and prevents conflicts when multiple people are working in the same area.

**Audio Integration**: Teams can seamlessly transition from visual collaboration to voice communication without leaving the FigJam environment[10]. This integration eliminates the need to switch between multiple tools and maintains the context of the visual work during verbal discussions.

### Intuitive Drawing and Annotation Tools

FigJam's drawing tools are designed to feel natural and expressive, mimicking the experience of working with physical markers and highlighters[11]. The tool set includes:

**Marker Tool**: The primary drawing instrument offers both thin and thick stroke options with full color customization[11][12]. Unlike traditional digital drawing tools, FigJam's marker creates strokes that can be manipulated after creation - resized, recolored, grouped, and repositioned as needed[12].

**Highlighter**: Designed for emphasis and annotation, the highlighter provides semi-transparent strokes that work well for calling attention to specific elements or marking important areas[11]. Like the marker, highlighter strokes remain editable after creation.

**Washi Tape**: A unique decorative tool that adds personality and visual interest to boards, washi tape can be used to create borders, dividers, or purely aesthetic elements[11].

**Eraser**: The eraser tool removes strokes one at a time, providing precise control over corrections[11]. This granular approach to editing allows for careful refinement of hand-drawn elements.

The key innovation in FigJam's drawing tools is their **post-creation editability**. Unlike traditional drawing applications where ink is permanent once applied, FigJam treats drawn elements as objects that can be selected, modified, and manipulated[12]. This flexibility bridges the gap between spontaneous sketching and structured design work.

### Structured Sections and Organization

While FigJam embraces creative freedom, it also provides tools for organization and structure when needed[13]. The section system allows teams to create defined areas within the infinite canvas for specific purposes:

**Sections as Organizational Units**: Sections can serve as containers for related ideas, effectively creating sub-workspaces within the larger canvas[13]. Teams can use sections to separate different phases of a project, different user personas, or different aspects of a problem.

**Sections as Virtual Pages**: For teams that need more structure, sections can function like pages in a traditional presentation, providing a way to organize content sequentially while maintaining the benefits of the infinite canvas[13].

**Flexible Boundaries**: Unlike rigid page layouts, sections in FigJam have flexible boundaries that can be adjusted as needed. This flexibility allows for organic growth of ideas while maintaining organizational structure.

## Essential FigJam Features to Implement

When building a FigJam-style canvas, certain features are essential for creating an authentic collaborative whiteboard experience. These core capabilities form the foundation upon which more advanced features can be built.

### Drawing Tools (Marker, Highlighter, Washi Tape)

The drawing tool suite is fundamental to the FigJam experience, providing the primary means for freeform expression and annotation[11]. Each tool serves a specific purpose in the collaborative workflow:

**Marker Implementation**: The marker tool requires several key capabilities:
- Variable stroke width (thin and thick options)
- Full color picker with custom color support
- Smooth stroke rendering using bezier curves
- Post-creation editability for color, size, and position
- Grouping and ungrouping capabilities for stroke management

**Highlighter Functionality**: The highlighter adds emphasis and visual hierarchy:
- Semi-transparent rendering with appropriate blend modes
- Limited but carefully chosen color palette
- Consistent stroke behavior with marker tool
- Ability to highlight both drawn content and text elements

**Washi Tape Integration**: This decorative tool adds personality and visual interest:
- Pattern-based rendering with customizable designs
- Adhesive-like visual properties that suggest temporary attachment
- Ability to create borders, dividers, and decorative elements

### Shapes and Connectors

Structured elements provide the backbone for diagramming and process visualization[14][15]. The shape and connector system must support:

**Basic Shapes**: Essential geometric primitives including rectangles, circles, triangles, and custom polygons. Each shape should support:
- Flexible sizing with proportional and free-form scaling
- Color customization for fill and stroke
- Text integration for labeling
- Snap-to-grid functionality for precise alignment

**Smart Connectors**: Dynamic linking elements that maintain relationships between objects[15]:
- Automatic anchor point detection on connected shapes
- Dynamic routing that adjusts when connected objects move
- Customizable endpoints (arrows, dots, none)
- Label support for describing relationships
- Multiple connection types (straight, curved, orthogonal)

**Connector Intelligence**: The system should automatically suggest connection points and maintain visual clarity even when objects are repositioned[15]. This requires sophisticated algorithms for path finding and visual optimization.

### Sticky Notes and Text Annotations

Text-based elements provide the primary means for capturing ideas, decisions, and feedback[5]. The implementation should include:

**Sticky Note System**: Digital equivalents of physical sticky notes with:
- Multiple size options (small, medium, large)
- Color coding for categorization
- Rich text editing capabilities
- Automatic text wrapping and sizing
- Clustering and grouping behavior

**Flexible Text Elements**: Beyond sticky notes, the system needs standalone text elements that can be positioned freely and styled independently. This includes:
- Multiple font options and sizes
- Text formatting (bold, italic, underline)
- Color customization
- Multi-line text support with proper line breaks

### Sections for Organization

The section system provides organizational structure within the infinite canvas[13]. Implementation requirements include:

**Section Creation**: Intuitive tools for defining bounded areas within the canvas:
- Visual drawing interface for section boundaries
- Automatic element containment when objects are placed within sections
- Flexible resizing to accommodate content growth
- Visual indicators for section boundaries

**Section Behavior**: Sections should behave logically when interacted with:
- Moving sections should move all contained elements
- Resizing sections should respect content boundaries
- Nested sections should maintain proper hierarchy
- Visual feedback for section interactions

### Cursor Chat and Real-time Collaboration

Communication tools are essential for maintaining collaboration flow[8][9]. The implementation should provide:

**Cursor Chat System**: Lightweight communication directly on the canvas:
- Live typing indicators that show messages as they're typed
- Cursor-anchored message display
- Automatic message expiration after a set time
- Simple activation through keyboard shortcuts

**Presence Indicators**: Visual representation of active collaborators:
- Unique cursor colors for each participant
- Name labels for cursor identification
- Activity indicators showing what tools users are using
- Smooth cursor movement interpolation for natural feel

**Real-time Synchronization**: The technical foundation for collaborative editing:
- Operational transformation for conflict resolution
- Efficient data synchronization protocols
- Graceful handling of network interruptions
- Consistent state management across all clients

These essential features form the core of a FigJam-style canvas implementation. Each feature must be carefully designed to work seamlessly with the others, creating a cohesive collaborative experience that feels natural and intuitive to users. The implementation should prioritize performance, reliability, and user experience to ensure that the technical complexity remains invisible to the end users.


# Chapter 2: Technology Stack Overview

## 2.1 Tauri Architecture Fundamentals

The foundation of our desktop application leverages **Tauri**, a polyglot toolkit that combines a Rust-based backend with a native WebView frontend[1]. The core Rust crate (`tauri`) reads configuration from `tauri.conf.json` at compile time, injecting features and registering commands that the frontend can invoke via message passing[1]. Under the hood, Tauri uses the `tauri-runtime` crate as a glue layer to lower-level WebView libraries (WRY on desktop), while `tauri-macros` and `tauri-utils` provide code generation and utility functions for interacting with the operating system[1].  

For rendering the user interface, Tauri taps into the operating system’s native WebView component—WebView2 on Windows, WKWebView on macOS, and WebKitGTK on Linux—allowing HTML, CSS, and JavaScript to run without bundling a full browser runtime[2]. Communication between the JavaScript context and Rust backend is facilitated by an IPC bridge: frontend code calls `invoke` to execute Rust commands asynchronously, and Rust emits events back to JavaScript through a unified event API[3].  

Because Tauri compiles into a single Rust binary for each platform and relies on the system WebView, application bundles remain exceptionally small and secure. Cross-platform deployment is handled by the Tauri bundler, which packages the Rust binary and frontend assets into native installers (MSI, DMG, AppImage), ensuring seamless integration with each OS’s update and installation mechanisms[1].

## 2.2 React + Konva Integration

On the frontend, our application uses **React** in conjunction with **react-konva**, a library that provides declarative React bindings for the Konva 2D canvas framework[4]. A `` component serves as the root container, internally creating an HTML5 `` element and managing viewport transformations such as zoom and pan. Within the stage, multiple `` components represent independent drawing surfaces, each backed by its own canvas element. This layering model enables targeted redraws—static elements (e.g., gridlines or UI overlays) can reside in one layer, while frequently updating shapes and annotations occupy another—minimizing unnecessary redraw work[5][6].

React-Konva seamlessly maps React props and events to Konva nodes and handlers, allowing developers to compose complex canvas scenes using familiar React patterns. To maintain high performance, it is recommended to limit layers to 3–5 per stage, memoize individual shape components with `React.memo`, and avoid re-creating layer hierarchies on every render. Off-screen object culling and selective layer redraws further optimize frame rates for large or dynamic canvases[5].

## 2.3 State Management Architecture

Global application state—encompassing canvas elements, viewport settings, and collaboration metadata—is managed with **Zustand**, a lightweight state management library for React that emphasizes simplicity and performance[7]. The store is initialized via the `create` factory, exposing both state fields (e.g., `elements`, `selectedTool`, `viewport`) and updater functions (e.g., `addElement`, `updateElement`, `setViewport`) through an immutable, proxy-backed API[7].

Canvas interactions triggered by React-Konva event handlers (such as `onMouseDown`, `onDragMove`, `onWheel`) dispatch Zustand actions to update the central store, ensuring a “store-first” architecture where business logic resides in the store rather than scattered across components. Element positions and sizes are tracked in virtual canvas coordinates; viewport transformations (scale and offset) are applied in rendering, with helper functions converting between screen and canvas space.

To optimize memory and rendering performance, the store integrates a quadtree spatial index that quickly identifies off-screen or densely clustered elements for culling. Combined with layer-based redraws and memoized React components, this architecture achieves sub-10ms update cycles even with thousands of elements on the canvas. Continuous viewport culling and selective state subscriptions ensure that only components affected by a given action re-render, preserving smooth user interactions.


# Chapter 3: Setting Up the Infinite Canvas

## 3.1 Canvas Foundation Setup

The infinite canvas begins with the core Konva components: a `` to host the drawing surface and one or more ``s to organize render passes. The stage encapsulates an HTML5 `` under the hood, handling viewport transforms such as scale and translation.  

To initialize the stage, supply its width and height to match the enclosing container, then attach event handlers for pan and zoom. In React-Konva, this might look like:

```tsx
import { Stage, Layer, Rect, Line } from 'react-konva';
import { useWindowSize } from './hooks/useWindowSize';
import create from 'zustand';

const useCanvasStore = create void }>(set => ({
  scale: 1,
  offsetX: 0,
  offsetY: 0,
  setTransform: (s, x, y) => set({ scale: s, offsetX: x, offsetY: y }),
}));

function InfiniteCanvas() {
  const { width, height } = useWindowSize();
  const { scale, offsetX, offsetY, setTransform } = useCanvasStore();

  const onWheel = (e: Konva.KonvaEventObject) => {
    e.evt.preventDefault();
    const mousePos = { x: e.evt.offsetX, y: e.evt.offsetY };
    const newScale = Math.max(0.1, Math.min(scale * (e.evt.deltaY > 0 ? 0.9 : 1.1), 4));
    const dx = (mousePos.x - offsetX) * (1 - newScale / scale);
    const dy = (mousePos.y - offsetY) * (1 - newScale / scale);
    setTransform(newScale, offsetX + dx, offsetY + dy);
  };

  const onDragMove = (e: Konva.KonvaEventObject) => {
    setTransform(scale, offsetX + e.deltaX, offsetY + e.deltaY);
  };

  return (
    
      
        {/* background grid, static guides */}
      
      
        {/* user-drawn content */}
      
    
  );
}
```

Here, one layer can render non-interactive elements such as a repeating grid, while another handles dynamic shapes. The stage’s `draggable` prop enables panning by default, and the `onWheel` handler implements zoom around the cursor.

Responsive sizing of the canvas is achieved by tying the stage dimensions to the container or window size. A custom `useWindowSize` hook can subscribe to resize events and update the stage dimensions accordingly, ensuring the canvas always fills its parent.

## 3.2 Coordinate System Design

An infinite canvas requires mapping between screen (pixel) coordinates and virtual canvas coordinates. All element positions and sizes are stored in a virtual space, while the stage transform applies scale and translation to present a viewport into that space.

### Real vs. Virtual Coordinates  
Virtual coordinates represent the “true” positions on an unbounded grid. The current viewport is described by a translation `(offsetX, offsetY)` and a uniform scale factor `s`. To convert a screen point `p_screen` to its virtual counterpart:

```
p_virtual.x = (p_screen.x - offsetX) / s
p_virtual.y = (p_screen.y - offsetY) / s
```

Conversely, to render a virtual point on screen:

```
p_screen.x = p_virtual.x * s + offsetX
p_screen.y = p_virtual.y * s + offsetY
```

### Mouse Event Conversion  
When the user draws or interacts, mouse events deliver raw pixel coordinates. Convert these to virtual coords before updating the store or creating shapes:

```ts
function toVirtual(p: { x: number; y: number }, scale: number, offsetX: number, offsetY: number) {
  return {
    x: (p.x - offsetX) / scale,
    y: (p.y - offsetY) / scale,
  };
}

// Usage inside a Konva event handler:
const pos = e.target.getStage().getPointerPosition();
const virt = toVirtual(pos, scale, offsetX, offsetY);
store.addElement({ type: 'line', points: [virt.x, virt.y] });
```

### Boundary Handling for Infinite Scroll  
Although truly infinite scroll is impractical, you can simulate unbounded space by freeing the stage’s drag constraints and letting offset values grow arbitrarily. To avoid numeric drift or overflow, clamp offsets to a large range (for example, ±1e6 units) and recentre when approaching limits:

```ts
const CLAMP = 1_000_000;
function clampOffset(value: number) {
  if (value  CLAMP) return CLAMP;
  return value;
}
// In setTransform:
setTransform(
  s,
  clampOffset(offsetX + dx),
  clampOffset(offsetY + dy)
);
```

## 3.3 Performance Optimization

An infinite canvas with many elements demands careful rendering strategies to maintain frame rates above 60 fps.  

### Viewport Culling  
Use a quadtree spatial index to track element bounding boxes. Before each render, query the quadtree for elements that intersect the current viewport rectangle in virtual coordinates. Only those elements require Konva nodes in the active layer. Off-screen elements can be skipped or rendered in a low-detail placeholder.

### Layer-Based Rendering  
Separate static and dynamic content into distinct layers. For instance, a background grid can remain in its own layer, redrawn only when zoom changes. Interactive or frequently modified shapes occupy another layer. When new elements are added or existing ones update, only their layer is invalidated.

### Memory Management  
Large numbers of Konva shapes can exhaust GPU memory. To mitigate this, destroy nodes for elements that leave the viewport for an extended period. Retain their data in the store but remove their visual representation until they re-enter the view. Additionally, reuse Konva nodes via object pooling for shapes of the same type.

### Frame Rate Optimization  
Debounce continuous input events such as pan and zoom to avoid redundant renders. Batch store updates where possible—accumulate multiple drag movements into a single state change once per animation frame. Use `React.memo` on shape components keyed by element ID so that only shapes whose props actually change will re-render.

By combining virtual coordinate management, viewport culling, layered rendering, and prudent memory strategies, the infinite canvas remains smooth and responsive, even as the number of on-canvas elements scales into the thousands.

# Chapter 4: Drawing Tools Implementation

## 4.1 Basic Drawing Tools

Implementing the core freehand drawing tools lays the groundwork for expressive, intuitive sketching on the infinite canvas. This section covers the pen (marker) and highlighter instruments, from raw stroke capture to editable vector objects.

### 4.1.1 Stroke Capture and Smoothing  
When the user presses down and drags, capture pointer coordinates in virtual canvas space. Buffer points at a consistent interval (e.g., every 16 ms) to avoid over‐sampling. Apply a smoothing algorithm—such as Catmull–Rom splines or a moving average—before constructing the Konva.Line:

```ts
interface StrokePoint { x: number; y: number; }
const rawPoints: StrokePoint[] = [];
function onPointerMove(e: PointerEvent) {
  const stagePos = stage.getPointerPosition();
  rawPoints.push(toVirtual(stagePos, scale, offsetX, offsetY));
}
function commitStroke() {
  const smoothed = smoothPoints(rawPoints);
  const line = new Konva.Line({
    points: smoothed.flatMap(p => [p.x, p.y]),
    stroke: currentColor,
    strokeWidth: currentTool === 'highlighter' ? strokeWidth * 3 : strokeWidth,
    lineCap: 'round',
    lineJoin: 'round',
    globalCompositeOperation: currentTool === 'highlighter'
      ? 'multiply'
      : 'source-over',
  });
  store.addElement({ type: 'line', config: line.getAttrs() });
  rawPoints.length = 0;
}
```

### 4.1.2 Marker Tool Features  
- **Variable Stroke Width**: Expose a slider for fine control between thin (2 px) and thick (20 px).  
- **Color Picker**: Offer a palette plus a “custom” picker for full-spectrum selection.  
- **Post‐creation Editing**: On selection, render transform handles allowing users to adjust stroke width, color, or reposition segments. Update the underlying Konva.Line attributes via `lineRef.current.setAttrs(...)` and persist to the store.

### 4.1.3 Highlighter Implementation  
- **Semi‐Transparent Overlay**: Use `globalCompositeOperation: 'multiply'` or `source-atop` on a wide, low‐opacity stroke to mimic a highlighter.  
- **Blend Modes**: Leverage CSS canvas blend modes for accurate overlay effects.  
- **Locking to Elements**: When highlighting shapes or text, constrain stroke to the element’s bounding box via hit-testing and restrict point buffers accordingly.

## 4.2 Shape Tools

Structured shapes are the building blocks for diagramming and flowcharts. This section details rectangle, circle, and polygon creation, along with selection and transformation capabilities.

### 4.2.1 Rectangle and Circle Creation  
- **Draw‐and‐Drag Interface**: On mousedown, record the start virtual point. On mousemove, compute the current virtual point and render a temporary Konva.Rect or Konva.Circle in a “preview” layer:

```ts
const previewLayer = useRef();
function onMouseDown(e: Konva.KonvaEventObject) {
  startPoint = toVirtual(e.evt, scale, offsetX, offsetY);
}
function onMouseMove(e: Konva.KonvaEventObject) {
  const current = toVirtual(e.evt, scale, offsetX, offsetY);
  previewLayer.current.clear();
  new Konva.Rect({
    x: Math.min(startPoint.x, current.x),
    y: Math.min(startPoint.y, current.y),
    width: Math.abs(current.x - startPoint.x),
    height: Math.abs(current.y - startPoint.y),
    stroke: '#4A4A4A',
    dash: [4, 4],
  }).draw();
}
function onMouseUp() {
  const rectConfig = previewShape.getAttrs();
  store.addElement({ type: 'rect', config: rectConfig });
  previewLayer.current.clear();
}
```

- **Custom Polygons**: Upon selecting the polygon tool, each click places a vertex. Closing the polygon by clicking the first vertex finalizes the shape.

### 4.2.2 Shape Styling and Properties  
Shapes support fill color, border stroke, corner radius (for rectangles), and opacity. The properties panel—bound to the selected element’s store entry—enables live editing:

- Fill: picker with opacity slider  
- Stroke: color, width, dash pattern  
- Radius: uniform or per‐corner radii  

### 4.2.3 Selection and Transformation  
Use Konva.Transformer to wrap selected shapes. Configure transformer handles for scaling, rotating, and skewing. Enable modifier‐key constraints (Shift for uniform scaling, Alt for center‐based transforms):

```tsx
 {
    if (newBox.width 
```

Upon transform end, read `transformerRef.current.getAttrs()` and update the store entry.

## 4.3 Text and Annotation Tools

Capturing ideas with text requires robust, editable text elements and sticky‐note functionality.

### 4.3.1 Text Element Implementation  
- **Canvas Text Nodes**: Use Konva.Text for lightweight, vector‐rendered text. Store attributes: `text`, `fontFamily`, `fontSize`, `fill`, `width` (for wrapping).  
- **Rich Text Overlay**: Render an invisible HTML `` overlay when editing, synchronized to the node’s screen coordinates via `stage.getAbsoluteTransform().copy().invert()`. On blur or Enter, commit changes to the Konva.Text node and hide the overlay.

### 4.3.2 Sticky Note System  
Sticky notes emulate physical Post-its with rich text:

- **Background Shape**: Konva.Rect with slight drop shadow for depth.  
- **Text Wrapping**: Limit text width to note width minus padding; auto‐size height to fit content.  
- **Color Coding**: Preset palette of pastel colors. Changing color updates the Rect’s fill.  

Creation flow:

1. Select “Sticky Note” tool.  
2. Click to place at virtual point; instantiate note with default size (200×150 units).  
3. Auto‐enter edit mode on text.  

### 4.3.3 Annotation Features  
- **Callouts**: Text with arrow pointers: compose a Konva.Group containing a Konva.Arrow and Konva.Text.  
- **Labels on Shapes**: Allow dragging text nodes to attach to shapes; maintain relative offset in the store so that moving the parent shape repositions the label group.

With these drawing and annotation tools in place, the canvas supports fluid freehand expression, structured diagramming, and rich textual annotations—essential capabilities for a FigJam-style collaborative whiteboard. Continuous refinement of smoothing algorithms, transformer interactions, and edit overlays will further polish the user experience.

# Chapter 5: Element Selection & Transformation

## 5.1 Selection System Architecture

Building a robust selection system is critical for empowering users to choose, group, and manipulate canvas elements with precision and ease. The selection layer sits between user input events and element rendering, translating pointer actions into high-level selection operations.

### Single and Multi-Element Selection  
Each canvas element (shapes, lines, text, sticky notes, sections) exposes a unique identifier and bounding box in virtual coordinates. When the user clicks on the canvas:

1. Capture the pointer position and convert to virtual coordinates.  
2. Query a spatial index (e.g., quadtree) for elements whose bounding boxes contain the point.  
3. If multiple candidates overlap, choose the topmost by z-index or layer order.  

For shift-click or ctrl-click, augment the existing selection set instead of replacing it. The store API might look like:

```ts
interface CanvasStore {
  selectedIds: Set;
  select(id: string, additive?: boolean): void;
  clearSelection(): void;
}
```

Invoking `select(id, false)` clears prior selections; `select(id, true)` toggles inclusion.  

### Selection Rectangle Implementation  
Drag-to-select (marquee selection) offers intuitive multi-element selection:

1. On mousedown with no tool active, record the start point.  
2. On mousemove, render a semi-transparent rectangle in an overlay layer between the background grid and content.  
3. On mouseup, compute the rectangle’s virtual bounds, then query the spatial index for all element bounding boxes intersecting this region.  
4. Populate `selectedIds` with the resulting element IDs.

```tsx
// Pseudo-code within a React-Konva component
function onCanvasMouseDown(e) {
  startVirt = toVirtual(e.evt, scale, offsetX, offsetY);
  isDraggingMarquee = true;
}
function onCanvasMouseMove(e) {
  if (!isDraggingMarquee) return;
  currentVirt = toVirtual(e.evt, scale, offsetX, offsetY);
  drawMarquee(startVirt, currentVirt);
}
function onCanvasMouseUp(e) {
  if (isDraggingMarquee) {
    const box = normalizeBox(startVirt, currentVirt);
    const hits = quadtree.query(box);
    store.setSelection(new Set(hits.map(el => el.id)));
    clearMarquee();
    isDraggingMarquee = false;
  }
}
```

### Visual Selection Indicators  
Selected elements receive a visual overlay—a `Konva.Transformer` or custom outline—showing handles for resizing and rotation. Customizing transformer appearance ensures consistency:

```tsx

```

When selections change, update `transformer.nodes` to match the newly selected Konva node references.

### Keyboard Shortcuts Integration  
Accelerate workflows with standard shortcuts:

- **Esc**: Clear selection.  
- **Shift+Click** / **Ctrl+Click**: Multi-select toggle.  
- **A**: “Select All” within current viewport (runs marquee selection over full screen).  
- **Delete** / **Backspace**: Remove selected elements.  

Implement a global key listener in your React root component to dispatch corresponding store actions.

## 5.2 Transformation Controls

After selecting elements, users must be able to resize, rotate, and reposition them intuitively. Transformation controls leverage Konva’s built-in `Transformer` component alongside custom constraints.

### Resize Handles and Constraints  
The transformer provides draggable anchors at the corners and edges of the selection’s bounding box. Constrain resizing to maintain minimum dimensions:

```ts
 {
    const min = 10;
    if (newBox.width 
```

For multi-element scaling, compute the union bounding box and apply proportional transforms to each child element based on its relative position within that box.

### Rotation Controls and Snapping  
Enable rotation by displaying a single rotation handle above the top-center of the transformer. To implement snapping at common angles (e.g., 15° increments):

```ts
function onRotateEnd(e) {
  const rawAngle = transformer.rotation();
  const snapped = Math.round(rawAngle / 15) * 15;
  transformer.rotation(snapped);
  store.updateAttrs(id, { rotation: snapped });
}
```

Attach this handler to the `onTransformEnd` event of the transformer.

### Move and Drag Functionality  
Rather than moving each selected element individually, group selected shapes under a temporary Konva.Group during drag operations:

```ts
const group = new Konva.Group({ draggable: true });
selectedNodes.forEach(node => group.add(node.clone()));
group.on('dragend', e => {
  const delta = group.position();
  selectedIds.forEach(id => {
    const attrs = store.getElement(id).attrs;
    store.updateAttrs(id, {
      x: attrs.x + delta.x,
      y: attrs.y + delta.y,
    });
  });
  group.destroy();
});
```

This approach preserves relative positioning and emits a single batch update.

### Proportional Scaling with Modifier Keys  
Support uniform scaling when the user holds **Shift**:

1. On transformer drag, detect `e.evt.shiftKey`.  
2. In `boundBoxFunc`, if shift is pressed, enforce a consistent aspect ratio:

```ts
if (e.evt.shiftKey) {
  const scale = Math.max(newBox.width / oldBox.width, newBox.height / oldBox.height);
  return {
    x: oldBox.x,
    y: oldBox.y,
    width: oldBox.width * scale,
    height: oldBox.height * scale,
  };
}
```

Persist updated size and position attributes on `onTransformEnd`.

## 5.3 Advanced Selection Features

To support power users, extend selection beyond basic click and marquee into lasso tools, query-based filtering, and hierarchical operations.

### Lasso Selection Tools  
Implement free-form lasso selection by capturing pointer positions as a polygonal path:

1. On tool activation, begin recording vertex points.  
2. Render a `Konva.Line` with `closed: true` and low opacity.  
3. On completion, test each element’s bounding box centroid against the lasso polygon using a point-in-polygon algorithm.  
4. Populate the selection set with contained element IDs.

```ts
function isInsideLasso(point, polygon) {
  // Winding number or ray-casting algorithm
}
```

### Property-Based Selection Queries  
Allow users to filter by attributes (e.g., all red shapes, all text elements). Expose a UI panel where users pick criteria; then:

```ts
const matches = Array.from(store.elements.values()).filter(el =>
  el.attrs.fill === selectedColor && el.type === 'shape'
);
store.setSelection(new Set(matches.map(el => el.id)));
```

This feature is ideal for mass-editing or theme adjustments.

### Hierarchical Element Selection  
When elements are nested (e.g., text inside sticky notes, shapes in sections), support selection propagation:

- **Parent selection**: Clicking on a child with **Alt+Click** selects its parent container.  
- **Child selection**: Clicking on a group with **Shift+Alt+Click** drills down into its immediate children.

Maintain a tree structure in the store to resolve parent/child relationships:

```ts
interface ElementNode {
  id: string;
  parentId?: string;
  children: string[];
}
```

### Bulk Operation Support  
Once multiple elements are selected, offer batch actions:

- **Align**: Top, middle, bottom, left, center, right. Compute target coordinate and update each element.  
- **Distribute**: Even spacing horizontally or vertically based on bounding box span.  
- **Group/Ungroup**: Create or dissolve Konva.Group containers, updating each element’s `parentId` in the store.  
- **Lock/Unlock**, **Hide/Show**: Toggle properties en masse for workflow management.

Example: Align top edges

```ts
const topY = Math.min(...selectedIds.map(id => store.getElement(id).attrs.y));
selectedIds.forEach(id => {
  store.updateAttrs(id, { y: topY });
});
```

With a comprehensive selection and transformation system, users gain fine-grained control over canvas elements, from simple clicks to complex queries and lasso tools. These capabilities form the backbone of an intuitive, FigJam-style collaborative experience, empowering users to arrange and manipulate their ideas with confidence and precision.

# Chapter 6: Sticky Notes & Sections

## 6.1 Sticky Note Implementation

Sticky notes bring a familiar, tactile feel to the digital canvas, enabling teams to capture quick ideas, reminders, or feedback. In a FigJam-style environment, sticky notes must be lightweight, editable objects that integrate seamlessly with other canvas elements.

### 6.1.1 Creating a New Sticky Note  
When the user selects the Sticky Note tool and clicks on the canvas, instantiate a new note at the clicked virtual coordinates with default dimensions and styling:

```tsx
// Inside Canvas component
function handleCanvasClick(e: Konva.KonvaEventObject) {
  if (currentTool !== 'sticky') return;
  const pointer = stageRef.current.getPointerPosition()!;
  const { x, y } = toVirtual(pointer, scale, offsetX, offsetY);
  const id = generateId();
  store.addElement({
    id,
    type: 'sticky',
    attrs: {
      x, y,
      width: 200,
      height: 150,
      fill: '#FFF475',
      stroke: '#E0C341',
      strokeWidth: 2,
      text: 'New note',
      fontSize: 16,
      padding: 10
    }
  });
  setSelectedTool('select');
  store.select(id);
}
```

- Default size: 200×150 units  
- Default color: pastel yellow (`#FFF475`) with darker border  
- Text placeholder: “New note”

### 6.1.2 Styling & Color Customization  
Expose a color palette panel bound to the selected note’s `fill` attribute. Allow custom colors via a hue/saturation picker:

```tsx

   store.updateAttrs(id, { fill: color })}
    presets={['#FFF475','#F28B82','#CBF0F8','#CCFF90']}
  />

```

- Preset palette for quick categorization  
- Opacity slider to fade notes as annotations, if desired

### 6.1.3 Rich Text Editing Inside Notes  
On double-click or Enter when a note is selected, switch to edit mode by overlaying an HTML `` at the note’s screen coordinates:

1. Compute screen position via the stage’s absolute transform.  
2. Render a floating `` positioned with inline styles.  
3. Sync keystrokes to note’s `text` attribute in real time or on blur.

```tsx
function TextOverlay({ element }) {
  const { x, y, width, padding } = element.attrs;
  const [value, setValue] = useState(element.attrs.text);
  const { scale, offsetX, offsetY } = useCanvasTransform();
  const screen = stageRef.current.getAbsoluteTransform()
                   .copy().scale({ x: scale, y: scale })
                   .translate({ x: offsetX, y: offsetY })
                   .point({ x, y });
  return (
     setValue(e.target.value)}
      onBlur={() => {
        store.updateAttrs(element.id, { text: value });
        exitEditMode();
      }}
    />
  );
}
```

### 6.1.4 Clustering & Organization  
For users adding many notes, implement automatic clustering by detecting proximity. After adding or moving a note:

1. Query the quadtree for nearby sticky notes within a threshold (e.g., 100 units).  
2. If two or more notes overlap or come within the threshold, group them under a temporary cluster container or visually nudge them apart.

```ts
function clusterStickyNotes(id) {
  const note = store.getElement(id);
  const neighbors = quadtree.query({
    x: note.attrs.x - 50, y: note.attrs.y - 50,
    width: note.attrs.width + 100, height: note.attrs.height + 100
  }).filter(el => el.type === 'sticky' && el.id !== id);
  if (neighbors.length > 0) {
    // Optionally group or adjust positions
    neighbors.forEach(n => {
      const dx = note.attrs.x - n.attrs.x;
      const dy = note.attrs.y - n.attrs.y;
      if (Math.hypot(dx, dy)  e.type === 'section' &&
    pointInRect(center, e.attrs));
  store.updateAttrs(elId, { parentId: containing?.id });
}
```

The rendering layer then draws section children before the section fill, ensuring visual hierarchy.

### 6.2.3 Section-Based Organization  
Use sections as virtual pages for presentation:

- Provide a “Focus Section” mode that zooms and pans the viewport to fit a section’s bounds.  
- Allow keyboard navigation to jump between sections in document order.

```ts
function focusSection(sectionId) {
  const { x, y, width, height } = store.getElement(sectionId).attrs;
  const scale = Math.min(viewportWidth/width, viewportHeight/height) * 0.9;
  const offsetX = -x * scale + (viewportWidth - width*scale)/2;
  const offsetY = -y * scale + (viewportHeight - height*scale)/2;
  store.setViewport(scale, offsetX, offsetY);
}
```

### 6.2.4 Nested Sections  
Support hierarchy by allowing sections within sections. Enforce parent-child relationships and ensure that moving a parent moves all descendants:

- On section drag, recursively adjust child element coordinates.  
- Clamp child containment to parent’s bounds unless explicitly moved outside.

```ts
function moveSection(id, dx, dy) {
  const moveRecursively = (elemId) => {
    const attrs = store.getElement(elemId).attrs;
    store.updateAttrs(elemId, { x: attrs.x + dx, y: attrs.y + dy });
    store.getChildren(elemId).forEach(moveRecursively);
  };
  moveRecursively(id);
}
```

## 6.3 Dynamic Grouping

Beyond manual grouping, intelligent grouping automates organization and batch operations.

### 6.3.1 Automatic Element Grouping  
When users draw a freeform shape around multiple elements (lasso), automatically group contained items:

```ts
function finalizeLasso(polygon) {
  const hits = store.elements.values().filter(e =>
    e.type !== 'section' && pointInPolygon(getCenter(e.attrs), polygon));
  if (hits.length > 1) {
    const groupId = generateId();
    store.addElement({ id: groupId, type: 'group', attrs: {} });
    hits.forEach(h => store.updateAttrs(h.id, { parentId: groupId }));
    store.select(groupId);
  }
}
```

Groups behave like sections but without visual boundary by default.

### 6.3.2 Manual Group Creation  
Allow selection of multiple elements followed by a “Group” action in the toolbar or via `Ctrl+G`. Wrap selected nodes under a new Konva.Group and update each element’s `parentId`.

### 6.3.3 Transformation of Groups  
Groups support all the same transformation controls (move, scale, rotate). On transform end, propagate changes to children proportionally:

```ts
function onGroupTransform(groupId, newAttrs) {
  const group = store.getElement(groupId);
  const oldBounds = group.attrs;
  const scaleX = newAttrs.width/oldBounds.width;
  const scaleY = newAttrs.height/oldBounds.height;
  store.getChildren(groupId).forEach(childId => {
    const child = store.getElement(childId).attrs;
    const relX = (child.x - oldBounds.x) * scaleX;
    const relY = (child.y - oldBounds.y) * scaleY;
    store.updateAttrs(childId, {
      x: newAttrs.x + relX,
      y: newAttrs.y + relY,
      width: child.width * scaleX,
      height: child.height * scaleY
    });
  });
}
```

### 6.3.4 Group Hierarchy Management  
Expose a tree view in the properties panel showing nested groups, sections, and their children. Allow drag-and-drop reparenting, rename, or ungroup (which clears `parentId` for children).

With sticky notes providing quick idea capture, sections enabling structured organization, and dynamic grouping offering powerful batch operations, Chapter 6 equips the canvas with essential tools for organizing and managing vast, collaborative boards in a FigJam-style application.

# Chapter 7: Connectors & Relationships

## 7.1 Connection System Design

Creating a robust connector system is essential for linking elements and expressing relationships on the canvas. At its core, each connector is an independent object composed of endpoint references, a path definition, and style attributes.  

### Dynamic Connector Creation  
When the user selects the connector tool and clicks on a source element, capture the element’s unique identifier and the precise anchor point—computed as the nearest point on the element’s boundary to the cursor in virtual coordinates. As the user drags, render a temporary line or polyline following the pointer to provide real-time feedback. On mouse release over a valid target element, finalize the connector by persisting both source and target IDs, anchor positions, and an initial routing path into the store.

### Anchor Point Calculation  
Compute anchor points using each element’s shape-specific geometry:
- **Rectangles and sections**: project the cursor’s virtual coordinate onto the nearest side midpoint or corner if within a threshold distance.  
- **Circles**: calculate the intersection of the radius line from the circle center through the cursor point.  
- **Arbitrary polygons**: find the closest segment on the shape’s convex hull and project the cursor onto that edge.

Store anchor metadata as `{ elementId, x, y, side }` to allow recalculation when elements move or rotate.

### Connection Validation and Cleanup  
Prevent invalid or dangling connections by validating both endpoints at creation:
1. Ensure the target element is not the same as the source.  
2. Enforce connection rules (e.g., disallow connecting text-only nodes if desired).  
3. If an endpoint element is deleted, automatically remove its associated connectors by listening for element-removal events in the store and filtering connectors whose `sourceId` or `targetId` matches the deleted ID.

### Visual Connection Rendering  
Use a dedicated `` for connectors, drawing each as a Konva.Line or Konva.Arrow with the following considerations:
- Allow styling through the store: stroke color, width, arrowhead type, and dash pattern.  
- Support hover and selection states by rendering a thicker invisible hit-area path and applying highlight styles on mouseover.  
- Animate path adjustments smoothly when elements move by tweening control points between old and new anchor positions.

## 7.2 Smart Connectors

Beyond basic straight lines, smart connectors enhance readability by automatically routing paths around canvas content and snapping to align with gridlines or other anchors.

### Auto-Routing Algorithms  
Implement a simple orthogonal routing algorithm that generates right-angle segments:
1. Collect source and target anchor coordinates.  
2. Compute an initial L-shaped path by connecting horizontal then vertical segments (or vice versa) based on minimal total Manhattan distance.  
3. If this path intersects other shapes, subdivide segments and insert additional waypoints computed via a grid-based obstacle map built from other elements’ bounding boxes.  
4. Smooth the resulting polyline slightly to avoid overly sharp turns, using a small radius on corners.

### Snap-to-Grid Functionality  
When the grid is enabled, round each waypoint coordinate to the nearest grid intersection during path finalization. Provide visual guides showing potential snap points as the user drags, and allow disabling snap by holding Alt.

### Connection Persistence During Element Moves  
When an element moves or scales, recalculate each connector’s affected anchor point by:
1. Re-projecting the stored side reference against the element’s new bounding box.  
2. Recomputing the routing path by invoking the same auto-routing algorithm with updated anchors.  
3. Animating the transition between old and new paths to maintain visual continuity.

Batch these updates per animation frame to avoid stuttering when multiple elements move simultaneously.

### Multi-Point Connector Support  
Offer a “polyline” connector mode where users can click intermediate waypoints:
- On first click, anchor to the source element.  
- On subsequent clicks, record each waypoint in an array.  
- On double-click or right-click, complete the connection to the target element.  
- Store the full waypoint list in the connector object and render accordingly.

## 7.3 Relationship Management

Capturing metadata and enabling operations on connections transforms connectors from mere visuals into first-class participants in the document model.

### Element Relationship Tracking  
Maintain a bidirectional map in the store linking element IDs to their incoming and outgoing connector IDs:
```ts
interface Connector {
  id: string;
  sourceId: string;
  targetId: string;
  waypoints: Point[];
  style: ConnectorStyle;
}
interface ElementRelations {
  incoming: Set;
  outgoing: Set;
}
// On connector creation:
store.relations[sourceId].outgoing.add(connectorId);
store.relations[targetId].incoming.add(connectorId);
```
This structure enables efficient queries for all connectors related to a given element.

### Connection Metadata Storage  
In addition to geometry and style, store arbitrary metadata on connectors—labels, weights, or semantic types—to support richer use cases such as flowcharts or ER diagrams. Expose a properties panel when a connector is selected, allowing users to edit metadata fields, with changes persisted directly to the store.

### Relationship-Based Operations  
Enable high-level operations on connection sets:
- **Cascade delete**: removing an element optionally deletes all its connectors.  
- **Bulk rewire**: select multiple connectors and change all their target endpoints to a single new element.  
- **Invert direction**: flip source and target for flow reversal.  
- **Filter by metadata**: highlight only connectors of a given type or label.

Implement commands in the UI and corresponding store actions to perform these batch updates efficiently.

### Visual Relationship Indicators  
Provide contextual cues for connector relationships:
- **Arrowheads and labels**: render arrowheads at the target end and display inline labels along the path.  
- **Hover highlights**: when hovering over an element, momentarily highlight all its incoming and outgoing connectors.  
- **Path previews**: on drag-over of a potential target, show a ghost connector preview indicating where a new connection would attach.

By combining dynamic creation, intelligent routing, and comprehensive relationship management, Chapter 7 equips the FigJam-style canvas with a powerful connector system that supports both simple links and complex semantic relationships—enabling users to map ideas, processes, and data seamlessly.

# Chapter 8: Collaborative Features

## 8.1 Real-Time Synchronization  
A truly collaborative canvas requires that all users share a single, consistent document state with minimal latency. Implement this by combining a conflict-free replication protocol (CRDT) with a live transport layer:

1. **CRDT Document**  
   Use Yjs’s `Y.Doc` as the authoritative canvas model. Store canvas elements (shapes, lines, text, connectors, sections) in a shared `Y.Map` or `Y.Array`, keyed by element ID. Each client creates a local `Y.Doc`, and modifications (adds, updates, deletes) are applied to the shared CRDT data structure[1].

2. **WebSocket Provider**  
   Employ the Yjs WebSocket provider (`y-websocket`) to broadcast updates. On startup, connect to a central WebSocket server:
   ```ts
   import * as Y from 'yjs'
   import { WebsocketProvider } from 'y-websocket'

   const ydoc = new Y.Doc()
   const provider = new WebsocketProvider('wss://your-server.com', 'canvas-room', ydoc)
   const sharedElements = ydoc.getMap('elements')
   ```
   The provider syncs CRDT updates bi-directionally, merging concurrent changes automatically and ensuring eventual consistency[2][1].

3. **Integrating with React-Konva**  
   Wrap the Konva canvas layer in a React effect that listens for CRDT updates. On `sharedElements.observe(...)`, reconcile the Yjs state with your Zustand store:
   ```ts
   sharedElements.observe(event => {
     event.changes.keys.forEach((change, key) => {
       const newAttrs = sharedElements.get(key)
       store.updateElement(key, newAttrs)
     })
   })
   ```
   Conversely, dispatch local Konva events (e.g., shape moved, text edited) into the CRDT via `sharedElements.set(id, attrs)`.

4. **Offline and Recovery**  
   Because Yjs buffers updates, clients can disconnect, make edits offline, and automatically synchronize upon reconnect. The CRDT merge logic resolves conflicts without lost changes.

## 8.2 Collaborative Drawing  
Beyond raw state sync, collaboration demands smooth, real-time feedback of other users’ actions:

1. **Shared Pointer Positions**  
   Use Yjs’s Awareness API (`provider.awareness`) to share each client’s cursor coordinates and selected tool. Broadcast an awareness update on pointer move:
   ```ts
   provider.awareness.setLocalStateField('cursor', { x: evt.canvasX, y: evt.canvasY, tool: currentTool })
   ```
2. **Rendering Remote Cursors and Selections**  
   Maintain a separate Konva layer for presence indicators. On awareness changes, iterate over `provider.awareness.getStates()` and render a `Konva.Group` containing:
   - A colored circle at the remote cursor position  
   - A label with the user’s name  
   - (Optional) Highlight around the element they’ve selected  
   
   Update these indicators in real time as awareness state changes.

3. **Cursor Chat**  
   Implement lightweight, ephemeral messages anchored to cursors by adding a transient awareness field (`chatMessage`) with text and timestamp. When another user sends a message (e.g., pressing Enter in chat mode), broadcast:
   ```ts
   provider.awareness.setLocalStateField('chat', { message: text, time: Date.now() })
   ```
   Render the message next to that user’s cursor for a few seconds before removing it[2].

4. **Latency Handling**  
   Batch frequent local updates (e.g., freehand strokes) using `requestAnimationFrame` and debounce bursts to avoid overloading the network. Yjs’s efficient binary encoding of updates minimizes bandwidth.

## 8.3 User Management  
A collaborative canvas must manage identities, permissions, and session state:

1. **User Identity and Roles**  
   Assign each client a unique `clientID` via Yjs. Augment awareness state with user metadata:
   ```ts
   provider.awareness.setLocalStateField('user', { id: clientID, name: userName, color: userColor, role: 'editor' })
   ```
   Display this information in the UI and controls (e.g., list of participants).

2. **Permissions and Locking**  
   Enforce element-level permissions by tagging each element in the CRDT with an owner ID and role restrictions. Before applying a local change, verify:
   ```ts
   if (element.owner === clientID || userRole === 'admin') {
     sharedElements.set(id, updatedAttrs)
   } else {
     showPermissionError()
   }
   ```
   For exclusive edits (e.g., text elements), use a lightweight “lock” flag in shared state. When entering edit mode, set `element.lockedBy = clientID`; other clients render the element in read-only style until the lock is released.

3. **Presence Indicators**  
   Beyond cursors, show a roster of connected users with online/offline status using the awareness API’s connection events. Update UI when `provider.on('connected')`, `provider.on('disconnected')`, or awareness states change.

4. **Session Management**  
   Handle join and leave events gracefully. On disconnection, clear the user’s awareness data and release any locks they held. Persist the Yjs document on the server or to local storage to allow session resumption and undo/redo history across sessions.

By combining Yjs CRDT synchronization, a WebSocket transport, awareness-based presence, and user permission controls, Chapter 8 equips your Konva-React canvas with the real-time collaboration features users expect from FigJam-style environments—enabling multiple participants to draw, chat, and co-create in a seamless, resilient workflow[1][2][3].

# Chapter 9: Tauri Integration

## 9.1 Frontend–Backend Communication  
Tauri applications combine a Rust-based core with a WebView-powered frontend, and the bridge that unites them is the Inter-Process Communication (IPC) layer. IPC in Tauri uses asynchronous message passing, exposing two primary primitives: **Commands** and **Events**. Commands let frontend code invoke Rust functions annotated with `#[tauri::command]`, serializing arguments and return values over a JSON-RPC–style protocol. Events, in contrast, are one-way messages that either side can emit to signal lifecycle changes or broadcast state updates[1].  

In practice, the React-Konva canvas dispatches user actions—such as “add element,” “save snapshot,” or “export board”—to Rust via `window.__TAURI__.invoke('commandName', payload)` calls. The Rust side implements these commands to perform file system operations, database writes, or OS integrations, then returns responses or emits events back to JavaScript, which the frontend listens for using `window.__TAURI__.event.listen('eventName', handler)`. This clear separation ensures that sensitive system operations remain in Rust, while the UI retains a secure, sandboxed execution context.

## 9.2 Data Persistence  
Persisting canvas state is essential for autosave, undo histories, and long-term storage. Two complementary strategies are common in Tauri applications: using a SQLite database via a plugin, and direct file-based storage.

A popular approach employs the **tauri-plugin-sqlite-store**, which integrates a fully managed SQLite instance into the Tauri core. By registering the plugin in `src-tauri/src/main.rs` and granting file system permissions for the app data directory, the canvas can perform transactional reads and writes of element records, user sessions, and version histories[2]. Queries against normalized tables enable efficient lookups—such as fetching only elements visible in the current viewport or retrieving the last ten edits for undo functionality—while the database handles concurrency and corruption resistance.

Alternatively, simple JSON serialization to the file system can suffice for smaller projects. Using Tauri’s file system API (`tauri::fs`), the frontend invokes commands to read/write a JSON snapshot of the canvas state to `app.path_resolver().app_data_dir()`. A typical workflow serializes the `Zustand` store to a JSON blob on each meaningful state change (e.g., element creation or deletion), and Rust code writes it atomically to disk[3]. Version history can be implemented by timestamping files or by maintaining a diffs table in SQLite.

Combining both strategies—storing high-frequency snapshots in JSON files and offloading bulk history to SQLite—yields a robust persistence layer that supports rapid autosave, crash recovery, and cross-session continuity.

## 9.3 Cross-Platform Considerations  
A key benefit of Tauri is its small bundle size and native integration with each operating system’s WebView component. Packaging the application for Windows, macOS, and Linux involves configuring `tauri.conf.json` and invoking the Tauri bundler with `npm run tauri build`. The bundler produces platform-specific installers—MSI or EXE on Windows, DMG or PKG on macOS, and AppImage or DEB on Linux—by leveraging tools like WiX, macOS’s native packager, and Linux packaging backends[4].  

During bundling, developers specify application metadata, icon assets, entitlements, and code signing configurations in `tauri.conf.json`. Windows installers integrate with the system installer service and support auto-update mechanisms, while macOS builds can include hardened runtime entitlements and notarization. Linux packages benefit from AppImage’s portability or distribution-specific formats for seamless software center integration.

Finally, cross-platform quirks—such as differences in file path separators, case sensitivity, or file system permissions—should be abstracted behind Rust commands. By centralizing OS-specific logic in the backend and exposing a uniform JavaScript API, the canvas implementation remains consistent across platforms while taking full advantage of native capabilities.


# Chapter 10: Performance & Scalability

## 10.1 Memory Management

Efficient memory handling is vital to keep the infinite canvas responsive, especially as element counts grow. Implement the following strategies:

### Viewport Culling  
Leverage a quadtree spatial index to track element bounding boxes in virtual coordinates. On each frame, query the quadtree for elements intersecting the current viewport rectangle and render only those nodes. Off-screen elements remain in the store but are excluded from the Konva scene graph, drastically reducing GPU memory use and draw calls.

### Element Lifecycle Management  
Adopt a node-pooling system for Konva shapes of the same type. Instead of destroying and recreating nodes on element add/remove, recycle nodes by reassigning their attributes. This minimizes garbage collection pressure and keeps GPU buffers stable. When an element is permanently deleted, destroy its pooled node only after ensuring it won’t be reused soon.

### Memory Leak Prevention  
Attach cleanup routines to avoid orphaned event listeners and lingering object references. For every Konva node created, register a `node.on('destroy', ...)` handler to remove related listeners and release any closures capturing large data structures. Use a `WeakMap` to associate auxiliary metadata with nodes without preventing GC.

### Garbage Collection Optimization  
Batch state updates and shape attribute changes within `requestAnimationFrame` callbacks to reduce incremental allocations. Avoid creating new objects per frame—for example, reuse plain objects for temporary calculations rather than allocating fresh `{ x, y }` each time. Throttle heavy tasks (e.g., rebuilding quadtree) to run at fixed intervals rather than on every minor viewport change.

## 10.2 Rendering Optimization

Maintaining a steady 60 fps—or higher on high-refresh displays—requires careful orchestration of canvas redraws and leveraging hardware acceleration.

### Layer-Based Rendering Strategies  
Divide content into logical Konva layers:  
- **Static Layer** for gridlines or background guides, redrawn only on zoom changes.  
- **Annotation Layer** for infrequent updates (sticky notes, shapes), invalidated on element edits.  
- **Interaction Layer** for highly dynamic content (freehand strokes, selection boxes), updated per user input.  

By isolating frequently changing visuals, you avoid full-canvas redraws and limit work to small regions.

### WebGL Acceleration Techniques  
Enable Konva’s WebGL renderer for faster shape compositing on supported platforms. In Tauri’s WebView, request a WebGL context when creating the ``:

```tsx

```

Test fallback to Canvas 2D mode for older hardware. Profile with browser devtools to verify GPU usage and identify slow draw calls.

### Frame Rate Monitoring  
Instrument your canvas with a lightweight FPS counter. Hook into Konva’s `frameRate` API or use `performance.now()` around render cycles:

```ts
let last = performance.now(), frames = 0;
function tick() {
  const now = performance.now();
  frames++;
  if (now - last >= 1000) {
    console.log('FPS:', frames);
    frames = 0;
    last = now;
  }
  requestAnimationFrame(tick);
}
tick();
```

Use these metrics during development to detect regressions when adding features.

### Performance Profiling Tools  
Integrate Chrome DevTools or Firefox Performance to record render timelines. Look for large “Recalculate Style” or “Repaint” tasks triggered by your canvas. Use Konva’s built-in `batchDraw()` to group multiple updates into a single redraw:

```ts
layer.batchDraw();
```

For complex scenes, capture CPU flame charts to identify hotspots in event handlers or state updates.

## 10.3 Large Canvas Handling

When boards span thousands of elements or cover vast virtual extents, additional techniques ensure consistent performance.

### Spatial Indexing with Quadtrees  
Maintain an up-to-date quadtree of element bounding boxes. On pan or zoom, query only once per animation frame to retrieve visible elements. Update quadtree entries lazily when elements move, batching index adjustments to avoid thrashing.

### Level-of-Detail Rendering  
Implement LOD thresholds based on zoom level. For distant elements (scale ` size to virtual bounds, keep the canvas dimensions equal to the viewport and rely on Konva’s transforms to pan/zoom. This avoids large internal buffers that exhaust GPU memory. If you need off-screen rendering (e.g., to export high-resolution images), temporarily resize a hidden canvas and draw in chunks using tiled rendering.

By combining meticulous memory management, targeted rendering strategies, and scalable handling of large boards, Chapter 10 lays out the blueprint for a high-performance, production-ready FigJam-style canvas that remains smooth and responsive under any workload.

# Chapter 11: Testing & Quality Assurance

## 11.1 Canvas Testing Strategies

Ensuring the reliability and correctness of a FigJam-style canvas begins with a clear, store-first testing approach. By focusing tests on the underlying data model and business logic rather than UI rendering, you achieve fast, deterministic verification of core functionality.

First, validate individual canvas operations through direct interaction with the state store. For example, tests should cover adding, updating, and removing elements of every type—lines, shapes, text nodes, connectors, sections, and groups—asserting that the store’s collections, spatial indexes, and parent-child relationships update correctly. Stroke smoothing, coordinate conversion, and quadtree culling logic also warrant targeted unit tests to catch edge cases such as collapsed bounding boxes or extreme zoom levels.

Next, employ integration tests that simulate typical user workflows by invoking sequences of store actions. A test might begin by creating a sticky note, resizing it, grouping it with a shape, drawing a connector between them, and then deleting one element—verifying that related connectors and group memberships update or clean up automatically. Keep these tests focused on the store API: each step should assert the expected state change without mounting React components or simulating DOM events. This “store-only” approach delivers millisecond-speed feedback and avoids flakiness common in UI-driven tests.

Finally, complement store-first tests with a small suite of end-to-end smoke tests against the rendered canvas. Using a headless browser or a lightweight Konva mock, verify that critical interactions—such as panning, zooming, freehand drawing, and section creation—produce no runtime errors and render expected node attributes. These smoke tests serve as a safety net, ensuring that foundational rendering and event-handler wiring remain intact as the codebase evolves.

## 11.2 Test Architecture

A robust test architecture centers around three pillars: isolation, real-store execution, and clear organization.

Isolation is achieved by spinning up a fresh store instance for each test. Using a vanilla Zustand store factory with Immer middleware, each test begins with a pristine canvas state. This prevents bleed-through between tests and ensures reproducibility. Helper functions can encapsulate common setup tasks—such as populating the store with a grid of elements or registering mock spatial indexes—while allowing each test to focus on specific assertions.

Real-store execution means avoiding mocks of store internals. Rather than stubbing out quadtree queries or transformer behavior, tests invoke the actual implementations. This practice uncovers integration issues early and builds confidence that the live application will behave as tested. For rendering-adjacent logic—such as node pooling or object-pool cleanup—you may substitute lightweight fakes for Konva nodes, but the store’s data handling should remain unmocked.

Organize test files around feature areas, mirroring the chapter structure of the guide. For example:
- `canvas-store/add-remove.test.ts` for basic element lifecycle  
- `canvas-store/coordinate-conversion.test.ts` for virtual vs. screen math  
- `canvas-integration/connector-workflow.test.ts` for connector creation and cleanup  
- `canvas-smoke/pan-zoom-smoke.test.ts` for rendering smoke tests  

Name tests descriptively and group them using Jest or Vitest’s `describe` blocks aligned with each feature. This mapping makes it easy to locate tests related to a given chapter or tool and keeps the suite maintainable as the canvas grows.

## 11.3 Quality Metrics

Establishing quantitative targets guides both development and regression monitoring. Key metrics include:

1. **Test Coverage**: Aim for at least 90% coverage on the store module and 70% overall, ensuring that all core functions—store actions, selectors, and utility helpers—are exercised.  
2. **Execution Speed**: Maintain sub-10 ms median runtime per unit test and under 100 ms per integration test to keep continuous integration pipelines fast and encourage frequent local runs.  
3. **Bug Regression Rate**: Track post-release bug reports related to canvas functionality. A well-tested canvas should see fewer than one regression per release cycle.  
4. **E2E Smoke Pass Rate**: Ensure 100% passing rate on smoke tests across supported platforms to catch cross-environment inconsistencies.  

Use coverage reports, CI build dashboards, and automated performance logs to monitor these metrics over time. When coverage dips or test runtimes creep upward, allocate dedicated maintenance sprints to refactor tests, optimize store logic, or prune obsolete test cases. By rigorously measuring and enforcing these quality standards, the FigJam-style canvas remains a reliable, production-ready component of your Tauri application.

# Chapter 12: Deployment & Distribution

## 12.1 Build Configuration  
Deployment begins with configuring the Tauri build process in `tauri.conf.json`, which defines both development and production behaviors. Under the top-level `build` object, specify commands to run before development and before production builds (`beforeDevCommand`, `beforeBuildCommand`, `beforeBundleCommand`), as well as asset locations (`devPath` and `distDir`) for your front end[1]. The `bundle` section controls how your application is packaged for each platform: you set identifiers (`bundle.identifier`), product names, versioning, and platform-specific options. For example, enabling the updater requires setting `bundle.updater.active` to `true` and providing an update server URL. Custom scripts can be invoked at each phase to optimize assets, run tests, or generate documentation before packaging commences[1].

## 12.2 Platform Distribution  
Tauri produces native installers tailored to each operating system:

-  **Windows**: On Windows hosts, running `tauri build` emits either an MSI package via the WiX Toolset or a setup `.exe` using NSIS. MSI installers integrate with enterprise deployment, while NSIS executables support lightweight, customizable installers. Cross-compilation of MSIs is not supported; NSIS on non-Windows hosts remains experimental[2][3].  
-  **macOS**: macOS bundles include both an application bundle (`.app`) and a disk image (`.dmg`). The `.dmg` format delivers a user-friendly drag-and-drop experience, customizable with background images, window dimensions, and icon placements in the `bundle.macOS.dmg` settings of `tauri.conf.json`[4][5]. Code signing and notarization steps can be automated via the Tauri CLI when building on a Mac.  
-  **Linux**: Tauri supports DEB and Flatpak formats for distribution through native package managers, as well as standalone AppImage bundles. AppImages package all dependencies, enabling execution on diverse distributions without installation—users simply make the file executable and run it[6]. Debian packages and Flatpaks integrate more closely with system updates and sandboxing but require additional metadata in `bundle.linux` settings.  

Each platform’s artifacts appear in `src-tauri/target/release/bundle` after `npm run tauri build` (or the equivalent Yarn, pnpm, or Cargo command), ready for direct distribution or upload to release channels.

## 12.3 Production Considerations  
To ensure a robust deployment pipeline, incorporate the following production-grade practices:

**Code Signing and Notarization**  
Sign your binaries on Windows and Linux to prevent security warnings, and notarize macOS disk images with Apple’s notarization service to satisfy Gatekeeper requirements. Tauri’s CLI hooks can invoke signing tools (e.g., `signtool.exe` on Windows, `codesign` on macOS) during the `beforeBundleCommand` phase.

**Auto-Update Integration**  
Enable seamless updates using the official Tauri updater plugin. Configure the update server endpoint in `tauri.conf.json` under `bundle.updater.endpoint`, then call `checkUpdate()` and `installUpdate()` from `@tauri-apps/api/updater` in your frontend to prompt users when new versions are available[7]. Secure update manifests with public-key signing to prevent tampering.

**Error Handling, Logging & Diagnostics**  
Instrument your Rust backend with structured logging (e.g., using `tracing`) and capture frontend errors via Tauri’s event system. Persist crash reports and user feedback to a centralized service or local logs before auto-restarting. Offer an in-app diagnostics panel that collects system info, log excerpts, and repro steps to streamline support.

**Performance Monitoring**  
Embed lightweight telemetry (with user consent) to track application start times, update durations, and bundle sizes. Monitor for regressions in load performance or unexpected increases in installer footprint, automating alerts when thresholds are exceeded.

By combining precise build configuration, native installers for each OS, and production-grade safeguards—code signing, auto-updates, robust logging, and performance monitoring—Chapter 12 completes the deployment story, ensuring your Konva-React canvas application ships reliably and securely to end users.


# Chapter 13: Plugin Architecture

## 13.1 Extensibility Design

An extensible plugin system transforms your FigJam-style canvas from a fixed feature set into a customizable platform. Plugins let developers and power users add new tools, behaviors, or integrations without modifying the core codebase.

### 13.1.1 Plugin System Architecture  
Design the canvas to discover, load, and isolate plugins at runtime. A typical architecture involves:

- **Plugin Registry**: A manifest (JSON or TypeScript module) listing available plugins, their metadata (name, version, author), entry points, and required capabilities.
- **Sandboxed Execution**: Load each plugin in a secure sandbox (e.g., using Web Workers or an isolated JavaScript context) to prevent crashes or unauthorized access to core internals.
- **Dependency Injection**: Provide plugins with a controlled API surface—canvas commands, event hooks, UI injection points—while keeping internal state encapsulated.
- **Lifecycle Management**: Standardize phases such as `initialize`, `activate`, `deactivate`, and `dispose` so the host can manage plugin loading and unloading gracefully.

### 13.1.2 Custom Tool Development  
Enable plugins to contribute new drawing or interaction tools:

1. **Tool Definition**: A plugin exports a factory function returning a `ToolDescriptor`:
   ```ts
   interface ToolDescriptor {
     id: string;
     icon: string;
     activate: (context: CanvasContext) => void;
     deactivate?: (context: CanvasContext) => void;
   }
   ```
2. **Registration**: On plugin activation, call `canvas.registerTool(descriptor)`. The canvas toolbar dynamically displays the new tool icon.
3. **Tool Lifecycle**:  
   - **activate** binds pointer and keyboard events to implement custom behavior.  
   - **deactivate** cleans up event listeners and UI overlays.

### 13.1.3 Theme and Styling Extensions  
Allow plugins to customize the canvas UI theme or add new styling presets:

- **CSS Variables**: Expose theme tokens (e.g., `--canvas-background`, `--grid-color`) via CSS custom properties. Plugins update these at runtime:
  ```ts
  canvas.setTheme({ '--canvas-background': '#20232A', '--grid-color': '#444' });
  ```
- **Component Overrides**: Use a registry for core components (palette, inspector, context menus). Plugins can override or wrap components:
  ```tsx
  canvas.overrideComponent('PropertiesPanel', CustomPropertiesPanel);
  ```

### 13.1.4 Third-Party Integrations  
Smoothly connect external services:

- **Data Connectors**: Plugins can implement import/export adapters (CSV, JSON, Mermaid diagrams) by calling `canvas.importData` or `canvas.exportData`.
- **Webhooks & Callbacks**: Provide hooks such as `onElementCreated`, `onSave`, or `onSync` so plugins can trigger network requests or local scripts.
- **Authentication Module**: For integrations requiring OAuth or API keys, plugins may leverage a shared “Credentials Vault” API provided by the host to securely store and retrieve tokens.

## 13.2 API Design

A well-documented, stable API surface is crucial for plugin authors. Organize the API into clear namespaces and events.

### 13.2.1 Public API Surface  
Group available APIs under a global `canvas` object exposed to plugins:

```ts
interface CanvasAPI {
  // Core commands
  addElement(config: ElementConfig): string;
  updateElement(id: string, attrs: Partial): void;
  removeElement(id: string): void;

  // Tool management
  registerTool(descriptor: ToolDescriptor): void;
  setActiveTool(toolId: string): void;

  // Event hooks
  on(event: CanvasEvent, handler: EventHandler): Unsubscribe;

  // Theme
  setTheme(vars: Record): void;
  overrideComponent(slot: string, component: React.ComponentType): void;

  // Data I/O
  importData(format: string, data: string): void;
  exportData(format: string): string;
}
```

### 13.2.2 Event System for Plugins  
Define low-latency, dispatchable events:

- **CanvasEvent** union:
  ```ts
  type CanvasEvent =
    | 'element:created'
    | 'element:updated'
    | 'element:deleted'
    | 'selection:changed'
    | 'tool:activated'
    | 'viewport:changed';
  ```
- **Event Handler**:
  ```ts
  type EventHandler = (payload: any, api: CanvasAPI) => void;
  ```
- **Subscription**:
  ```ts
  const unsubscribe = canvas.on('element:created', ({ id, config }) => {
    console.log('New element:', id);
  });
  // Later:
  unsubscribe();
  ```

### 13.2.3 Configuration Management  
Let users enable, disable, and configure plugins:

- **Plugin Settings UI**: Each plugin can define a settings schema:
  ```ts
  interface PluginSettingsSchema {
    [key: string]: { type: 'string' | 'number' | 'boolean'; default: any; label: string };
  }
  ```
- **Persistent Store**: The host persists plugin settings in Tauri’s secure key–value store. Plugins read/write via:
  ```ts
  canvas.getPluginSettings(pluginId): Record;
  canvas.setPluginSettings(pluginId, settings): void;
  ```

### 13.2.4 Plugin Lifecycle Management  
Standard methods ensure consistent behavior:

1. **initialize(api: CanvasAPI)**  
   Called once at application startup. Use to register tools or register event listeners.
2. **activate()**  
   Invoked when the plugin is enabled. Begin listening to events and injecting UI.
3. **deactivate()**  
   Called when the plugin is disabled. Undo registrations and hide UI.
4. **dispose()**  
   Final cleanup invoked on application shutdown or plugin uninstall.

A minimal plugin skeleton:

```ts
export default {
  id: 'hello-world',
  name: 'Hello World Tool',
  settingsSchema: {
    greeting: { type: 'string', default: 'Hi', label: 'Greeting' }
  },
  initialize(api: CanvasAPI) {
    this.api = api;
    api.registerTool({
      id: 'hello-tool',
      icon: '👋',
      activate: () => {
        const msg = api.getPluginSettings(this.id).greeting;
        alert(`${msg}, from Hello World Plugin!`);
      }
    });
  },
  activate() {
    this.api.setActiveTool('hello-tool');
  },
  deactivate() {
    // no-op
  },
  dispose() {
    // cleanup
  }
};
```

By defining a structured plugin architecture, exposing a consistent public API, and standardizing lifecycle and configuration, Chapter 13 establishes a robust foundation for extending the FigJam-style canvas. Whether adding bespoke drawing tools, integrating with external services, or theming the interface, plugins empower developers to tailor the canvas to diverse workflows and domains.

# Chapter 14: Advanced Use Cases

## 14.1 Specialized Applications

Digital whiteboarding extends far beyond free-form sketching. By tailoring tools and workflows to specific domains, your FigJam-style canvas becomes a platform for diverse professional and creative scenarios.

Educational whiteboarding demands real-time interactivity and visual clarity. Extend the canvas with a “Quiz Mode” plugin that overlays question prompts and collects student responses as sticky notes. Implement a timer widget using a React-Konva `` node that updates via `requestAnimationFrame`, and a submission animation triggered by grouping student responses and applying a `Tween` for a celebratory effect. Tie into your real-time sync provider to lock quiz answers after time expires.

Technical diagramming workflows benefit from domain-specific shapes and validation rules. Create a circuit diagram toolkit by registering custom shapes—resistors, capacitors, and logic gates—each with precise port anchor definitions. On connector creation, enforce electrical rules by subscribing to the `connector:create` event and rejecting invalid connections (e.g., two outputs). Use a property panel to display component metadata (resistance, capacitance), and generate a netlist export by iterating over all connectors and their endpoint element IDs.

Creative collaboration often involves mixed-media canvases. Integrate an image-sticker tool that lets users upload JPEG or SVG assets and place them as draggable Konva.Image nodes. Provide a “masking” plugin where freehand strokes define clipping polygons, then apply them to images via the node’s `clipFunc`. For storyboarding workflows, add a “Frame Navigator” overlay that sequences canvas regions—saved viewports that users can step through like slides.

Business process mapping requires structured elements and data integration. Define a BPMN palette: tasks, events, gateways, and data objects. Each shape implements custom hit-testing for accurate connector snapping. Offer an “Export to BPMN XML” command by serializing element positions, connector ways, and metadata into the BPMN standard schema. Embed this export in a sidebar where users can download or send the file via your Tauri backend, invoking a Rust `fs::write` command for secure local saving.

## 14.2 Integration Patterns

To maximize the canvas’s utility, build flexible import/export and integration hooks that connect the whiteboard to external systems, data sources, and storage backends.

### External Data Source Integration  
Expose a data-import dialog where users paste CSV, JSON, or spreadsheet URLs. Parse the payload in JavaScript, map rows to canvas elements, and render them as tables or data-driven shapes. For example, reading a JSON array of project milestones produces a series of labeled rectangles positioned along a time axis. Use the Konva Transformer to allow users to adjust layouts after import.

### Export and Import Functionality  
Support multiple export formats to suit different workflows:
- **PNG/SVG**: Use `stage.toDataURL()` for raster snapshots or `stage.toSVG()` for vector exports. In Tauri, send the data URL to Rust via `invoke('saveFile', { data })` for native file dialogs.
- **JSON**: Serialize the Zustand store’s element map into a compact JSON structure. Include all attributes, hierarchy, and metadata. Offer versioned exports to maintain backward compatibility.
- **Markdown Embeds**: Convert selected sections into embeddable markdown by translating shapes and text into markdown syntax. For example, boxes become blockquotes, connectors become lists with arrows (`–►`), and sticky notes map to callout blocks.

### Cloud Storage Synchronization  
Integrate with cloud providers by creating a Tauri plugin that handles OAuth flows and REST API calls securely in Rust. For instance, implement a “Save to Google Drive” action that serializes the canvas to JSON, obtains an access token via the plugin’s secure vault, and uploads the file. Listen for file-change webhooks (via a background process) to pull remote updates and merge conflicts through your CRDT layer.

### Third-Party Tool Connectivity  
Enable live embedding of external content—Google Docs, Figma frames, or video streams—by wrapping them in Konva.Rect nodes and layering an `` overlay synchronized to the node’s screen transform. Provide bi-directional resizing and panning so that when users move the placeholder, the embedded content follows. Leverage Tauri’s protocol handler to launch external applications or URLs when users double-click these nodes.

By designing these advanced use cases and integration patterns, Chapter 14 elevates your FigJam-style canvas into a versatile platform that adapts to specialized workflows, connects seamlessly to real-world data, and extends the collaborative experience across tools and domains.


# Appendices

## Appendix A: Code Examples & Templates

This appendix provides ready-to-use code snippets and project templates to accelerate development of a FigJam-style canvas with Konva React and Tauri. Each example illustrates a core feature or pattern discussed in the guide.

### A.1 Starter Project Template  
```bash
# Create the React + Konva frontend
npx create-react-app figjam-canvas --template typescript
cd figjam-canvas
npm install react-konva konva zustand yjs y-websocket @tauri-apps/api

# Initialize Tauri in src-tauri
npm install -D @tauri-apps/cli
npx tauri init
```

### A.2 Infinite Canvas Component  
```tsx
import React from 'react';
import { Stage, Layer, Rect, Line } from 'react-konva';
import create from 'zustand';

// Zustand store for viewport transform
type Viewport = { scale: number; x: number; y: number; set: (s: number, x: number, y: number) => void };
export const useViewport = create(set => ({
  scale: 1, x: 0, y: 0,
  set: (s, x, y) => set({ scale: s, x, y })
}));

export function InfiniteCanvas() {
  const { scale, x, y, set } = useViewport();
  const onWheel = (e: any) => {
    e.evt.preventDefault();
    const direction = e.evt.deltaY > 0 ? 0.9 : 1.1;
    const newScale = Math.max(0.2, Math.min(scale * direction, 4));
    const mouse = e.target.getStage().getPointerPosition()!;
    const dx = (mouse.x - x) * (1 - newScale / scale);
    const dy = (mouse.y - y) * (1 - newScale / scale);
    set(newScale, x + dx, y + dy);
  };
  return (
    
      {/* Grid, guides */}
      {/* User content */}
    
  );
}
```

### A.3 Tauri Command for Saving Canvas State  
```rust
// src-tauri/src/commands.rs
use serde::Deserialize;
use tauri::command;

#[derive(Deserialize)]
struct SavePayload { data: String; path: String; }

#[command]
pub async fn save_canvas(payload: SavePayload) -> Result {
  std::fs::write(&payload.path, &payload.data)
    .map_err(|e| format!("Failed to save file: {}", e))
}
```

```ts
// In React frontend
import { invoke } from '@tauri-apps/api/tauri';

async function saveCanvas() {
  const state = JSON.stringify(useCanvasStore.getState().elements);
  await invoke('save_canvas', { data: state, path: 'canvas.json' });
}
```

### A.4 Template for a Custom Plugin  
```ts
// plugins/hello-plugin.ts
export default {
  id: 'hello-plugin',
  name: 'Hello Plugin',
  initialize(api) {
    api.registerTool({
      id: 'hello-tool',
      icon: '👋',
      activate: () => alert('Hello from plugin!')
    });
  },
  activate() { /* optional */ },
  deactivate() { /* optional */ },
  dispose() { /* cleanup */ }
};
```

## Appendix B: Troubleshooting Guide

This guide lists common issues encountered when building a FigJam-style canvas and offers practical solutions.

### B.1 Coordinate Conversion Errors  
**Symptom:** Drawn shapes appear offset or misaligned after zoom or pan.  
**Cause:** Incorrect conversion between screen and virtual coordinates.  
**Solution:** Always apply the inverse of the current viewport transform before using pointer coordinates. For a screen point `(sx, sy)` and viewport `(scale, x, y)`:
```ts
const vx = (sx - x) / scale;
const vy = (sy - y) / scale;
```
Ensure this logic runs in every pointer event handler.

### B.2 Memory Leaks with Konva Nodes  
**Symptom:** Memory usage grows steadily when adding and removing shapes.  
**Cause:** Konva nodes not destroyed or event listeners not removed.  
**Solution:** On element removal, call `node.destroy()` and remove any attached listeners:
```ts
node.off();
node.destroy();
```
Use object pooling for frequently created nodes to reduce allocations.

### B.3 Performance Drop on Large Boards  
**Symptom:** Frame rate drops below 30 fps when many elements are present.  
**Solution:**  
1. **Viewport culling:** Query a quadtree to render only on-screen elements.  
2. **Layer separation:** Keep static content in separate layers using `layer.batchDraw()` for occasional redraws.  
3. **LOD rendering:** Swap detailed shapes for simplified placeholders at low zoom levels.

### B.4 Section Parenting Mistakes  
**Symptom:** Elements fail to move with their parent section or disappear unexpectedly.  
**Cause:** Incorrect `parentId` handling or transform application order.  
**Solution:** After adding or moving an element, run:
```ts
if (pointInRect(center, section.attrs)) {
  store.updateAttrs(el.id, { parentId: section.id });
} else {
  store.updateAttrs(el.id, { parentId: undefined });
}
```
Then apply section transforms recursively to all children.

### B.5 Real-Time Sync Conflicts  
**Symptom:** Concurrent edits overwrite each other or cause state divergence.  
**Solution:** Use a CRDT library (e.g., Yjs) with a WebSocket provider. Ensure all state updates go through the shared `Y.Doc`, not just local store mutations. Wrap local mutations in CRDT transactions:
```ts
yDoc.transact(() => {
  sharedMap.set(id, attrs);
});
```

## Appendix C: Resources & References

Below is a curated list of documentation, libraries, and tools essential for building and extending a FigJam-style canvas.

| Category                   | Resource                                                                                  |
|----------------------------|-------------------------------------------------------------------------------------------|
| **Konva.js**               | https://konvajs.org/                                                                       |
| **React-Konva**            | https://github.com/konvajs/react-konva                                                      |
| **Tauri Framework**        | https://tauri.app/                                                                         |
| **Tauri API Docs**         | https://tauri.app/v1/api/js/                                                               |
| **Zustand State Management** | https://zustand.surge.sh/                                                                  |
| **Yjs CRDT Library**       | https://docs.yjs.dev/                                                                      |
| **Y-WebSocket Provider**   | https://github.com/yjs/y-websocket                                                         |
| **SQLite for Tauri**       | https://github.com/tauri-apps/tauri-plugin-sqlite-store                                    |
| **Vitest Testing**         | https://vitest.dev/                                                                        |
| **React Testing Library**  | https://testing-library.com/docs/react-testing-library/intro                                 |
| **Tailwind CSS**           | https://tailwindcss.com/                                                                    |
| **TypeScript Handbook**    | https://www.typescriptlang.org/docs/handbook/intro.html                                     |
| **Browser DevTools Performance** | https://developer.chrome.com/docs/devtools/evaluate-performance/                      |
| **Rust Language**          | https://www.rust-lang.org/                                                                  |
| **Serde (Rust Serialization)** | https://serde.rs/                                                                        |

These references serve as the primary sources for APIs, patterns, and best practices when implementing a high-performance, collaborative canvas within a Tauri application.



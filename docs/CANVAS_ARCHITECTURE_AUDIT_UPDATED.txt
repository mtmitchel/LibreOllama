# Canvas System Architecture Audit & Analysis (Live Document)

**Author**: Rovo Dev (AI)
**Date**: 2025-08-28 (Reflects live production code)
**Status**: Verified, Comprehensive, & Current

## 1. Executive Summary

This document provides a rigorous, up-to-date analysis of the LibreOllama canvas architecture. The initial audit was found to be significantly outdated. This version corrects inaccuracies and adds critical context based on a thorough review of the live production codebase, making it suitable for a senior engineer with zero prior context.

The canvas architecture is a modern, modular, and highly performant system built on a **React, Konva, and Zustand** stack, running within a **Tauri (Rust)** desktop environment. It is designed for high-performance rendering and complex state management. Key architectural features include a modular "store-first" state management pattern, a consolidated multi-layer rendering pipeline with advanced GPU acceleration, and a robust, defensive error-handling strategy.

---

## 2. Application Context: The LibreOllama Ecosystem

Before diving into the canvas specifics, it is crucial to understand its place within the broader LibreOllama application.

### 2.1. High-Level Purpose
LibreOllama is a multi-functional, desktop-first productivity application. Its stated mission is to be an **open-source, locally-run, and privacy-first alternative to Ollama**. It bundles several features into a single, unified workspace.

### 2.2. Core Technology Stack
- **Frontend**: **React** with **TypeScript**.
- **State Management**: **Zustand**.
- **Styling**: A custom **Asana-inspired CSS framework**, migrating away from Tailwind CSS.
- **Backend**: **Rust** powered by the **Tauri** framework.
- **Database**: **SQLite** for local data persistence.

### 2.3. Key Features
The application is composed of several feature-rich "surfaces":
- **Mail**: A full Gmail client using the official API with advanced features like Shadow DOM rendering for security.
- **Chat**: A multi-provider LLM chat interface.
- **Notes**: A rich-text editor using the BlockNote library.
- **Tasks & Calendar**: A project management tool with Google Tasks/Calendar two-way sync.
- **Canvas**: A freeform visual content creation tool.

### 2.4. The Canvas's Relation to the Broader App
- **Integrated Feature**: The canvas is a core productivity surface, sitting alongside Mail, Chat, etc.
- **Shared Backend**: It uses the same Tauri/Rust backend for secure, encrypted file persistence that other features use for API calls and database operations.
- **Shared Design System**: The canvas UI is subject to the same Asana-inspired design system, ensuring a consistent look and feel across the application.
- **Unique Complexity**: Due to its graphical and highly interactive nature, the canvas possesses the most specialized frontend architecture in the application, leveraging the Konva rendering engine and advanced optimization techniques not present in the other, more document-centric features.

---

## 3. Build Process & Development Workflow

The project's development environment is built on modern tooling, which is essential for developer productivity and application performance.

- **Build Tool**: **Vite** is used for its fast development server and optimized production builds. The configuration (`vite.config.ts`) includes path aliases (e.g., `@/` for `src/`) for cleaner imports.
- **Package Manager**: The project uses `npm`, with dependencies and scripts defined in `package.json`.
- **Core Scripts**:
  - `npm run dev`: Starts the Vite development server.
  - `npm run build`: Creates an optimized production build.
  - `npm run test`: Executes the test suite using **Vitest**.
  - `npm run lint`: Performs static code analysis with **ESLint**.
  - `npm run type-check`: Validates TypeScript types across the project.

---

## 4. High-Level Architecture

### 4.1. Frontend Topology & Data Flow

The rendering pipeline is designed for performance through layer separation and a unidirectional data flow.

- **Component Hierarchy**:
  1.  `CanvasStage.tsx`: The root component. Hosts the Konva `<Stage>` and is wrapped in an `CanvasErrorBoundary`. It subscribes to the Zustand store and manages global events like wheel-to-zoom.
  2.  `CanvasLayerManager.tsx`: Orchestrates rendering. It receives the full list of elements from `CanvasStage`, performs viewport culling using the `useSpatialIndex` hook, and distributes the visible elements to the appropriate layers.
  3.  **Layers**:
      - `BackgroundLayer`: Renders a static grid.
      - `MainLayer`: Renders the majority of elements (shapes, text, connectors).
      - `FastLayer`: A dedicated, GPU-accelerated layer for rendering all `ImageElement` types.
      - `OverlayLayer`: Renders UI-related overlays like the selection box and the Konva `Transformer`.

- **Typical Data Flow (User Drags a Shape)**:
  1.  **Event**: User `mousedown` on a shape in the `MainLayer`.
  2.  **Handler**: The shape's `onDragStart` event handler is triggered.
  3.  **Action**: The handler calls an action from the Zustand store, e.g., `updateElement(id, { isDragging: true })`.
  4.  **State Update**: The `elementModule` in the store updates the state of the specific element immutably via `immer`.
  5.  **Re-render**: `CanvasStage`, subscribed to the store, receives the updated `elements` map. It passes the new map down to `CanvasLayerManager`.
  6.  **Culling & Rendering**: `CanvasLayerManager` culls the elements, and the `MainLayer` re-renders only the changed element, which now follows the mouse. The `onDragEnd` event fires another action to save the final position.

### 4.2. Backend Topology (Tauri + Rust)

- **Tauri Commands**: `src-tauri/src/commands/canvas.rs` exposes Rust functions to the frontend, including `save_canvas_data`, `load_canvas_data`, etc.
- **Persistence**: The `useTauriCanvas` hook manages autosaving (debounced at **3000ms**). Data is encrypted using **AES-256-GCM** with a key stored securely in the OS keyring.
- **GPU Acceleration**: The application enables WebView2 acceleration flags and `CanvasStage.tsx` requests a `'high-performance'` power preference on the canvas context.

---

## 5. State Management (Zustand)

The architecture uses a modular "store-first" pattern with Zustand, designed for performance and maintainability.

- **Store Structure**: `unifiedCanvasStore.ts` composes **8 modules** into a single store.
  - **Modules**: `element`, `selection`, `viewport`, `drawing`, `history`, `section`, `ui`, `event`.
  - **Consolidation**: `eraserModule` is now in `drawingModule`, `loadingModule` is in `uiModule`, and `stickyNoteModule`/`tableModule` have been consolidated elsewhere.
- **Middleware**: `immer` (with `enableMapSet`) for immutable updates and `subscribeWithSelector` for performant, fine-grained subscriptions.
- **Deprecation**: The store's `getVisibleElements()` function is deprecated. A `console.warn` directs developers to use the modern `useSpatialIndex()` hook instead.

*(See Appendix B for Key State Module APIs)*

---

## 6. Performance & Error Handling

### 6.1. Performance Strategies
- **Viewport Culling**: The `useSpatialIndex` hook uses a QuadTree to efficiently determine visible elements, drastically reducing render load.
- **Layer Separation**: The use of `MainLayer`, `FastLayer` (for images), and `OverlayLayer` allows Konva to repaint only what has changed.
- **Low-Level Optimization**: `CanvasStage.tsx` sets performance-critical properties on the Konva stage (`pixelRatio: 1`) and the 2D context (`desynchronized: true`).
- **Object Pooling**: The `KonvaNodePool` significantly improves performance in drawing-heavy scenarios by reusing Konva nodes.

### 6.2. Error Handling & Stability
- **Error Boundaries**: The entire canvas is wrapped in a `CanvasErrorBoundary` to catch rendering errors.
- **Defensive Programming**: `CanvasLayerManager.tsx` contains numerous checks to ensure the store and its data are initialized before rendering, displaying clear error indicators on the canvas if a problem is detected.
- **Developer Guardrails**: The codebase includes development-only warnings, such as a console warning if the number of canvas layers exceeds the architectural standard.

---

## 7. Styling & Theming

- **Design System**: The project is migrating from `tailwindcss` to a unified, Asana-inspired design system defined in `src/styles/asana-core.css`.
- **Canvas Styling**: Canvas elements are styled via JavaScript props passed to Konva components. These values should eventually be sourced from the design system's CSS variables.

---

## 8. Gaps & Recommendations

- **P1 - Finalize Styling Migration**: Prioritize the complete removal of `tailwindcss` from canvas-related components.
- **P2 - Document Module Interactions**: Create a sequence diagram or written guide for a complex user flow to show how the Zustand modules interact.
- **P3 - Enhance Backend Testing**: The Rust modules need a more comprehensive test suite covering edge cases in encryption and file I/O.

---

## Appendix A: Core Data Structures

Core data types are defined in `src/features/canvas/types/enhanced.types.ts`. The system uses **Branded Types** for IDs (`ElementId`, `SectionId`) to ensure type safety at compile time.

**Base Element:**
```typescript
export interface BaseElement {
  id: ElementId;
  type: string;
  x: number;
  y: number;
  rotation?: number;
  isLocked?: boolean;
  // ... and other common properties
  createdAt: number;
  updatedAt: number;
}
```

**CanvasElement Discriminated Union:**
The `CanvasElement` type is a discriminated union based on the `type` property, allowing for type-safe handling of different shapes.

```typescript
export type CanvasElement = 
  | TextElement
  | RectangleElement
  | CircleElement
  | SectionElement
  | ConnectorElement
  | ImageElement
  | TableElement
  | StickyNoteElement
  | PenElement
  // ... and other element types
;
```

**Example Element Type (Rectangle):**
```typescript
export interface RectangleElement extends BaseElement {
  type: 'rectangle';
  width: number;
  height: number;
  fill?: string;
  stroke?: string;
  strokeWidth?: number;
  text?: string;
}
```

---

## Appendix B: Key State Module APIs

This is a high-level overview of the primary responsibilities and key actions of the main Zustand store modules.

- **`elementModule`**: Manages the lifecycle of all canvas elements.
  - `addElement(element: CanvasElement)`: Adds a new element.
  - `updateElement(id: ElementId, updates: Partial<CanvasElement>)`: Updates properties of an existing element.
  - `deleteElement(id: ElementId)`: Removes an element.
  - `clearAllElements()`: Deletes all elements from the canvas.

- **`selectionModule`**: Manages which elements are selected.
  - `selectElement(id: ElementId, multiSelect: boolean)`: Selects one or more elements.
  - `deselectElement(id: ElementId)`: Deselects a specific element.
  - `clearSelection()`: Clears the entire selection.
  - `setSelectedElementIds(ids: ElementId[])`: Directly sets the selection.

- **`viewportModule`**: Manages the canvas's position and zoom level.
  - `setViewport(viewport: Partial<ViewportState>)`: Sets the raw viewport state.
  - `panViewport(delta: { x: number; y: number })`: Pans the canvas by a delta.
  - `zoomViewport(newScale: number, centerX: number, centerY: number)`: Zooms the canvas around a specific pivot point.

- **`historyModule`**: Manages the undo/redo stack.
  - `addHistoryEntry(operation: HistoryEntry)`: Pushes a new state change onto the history stack.
  - `undo()`: Reverts to the previous state.
  - `redo()`: Moves forward to the next state.
  - `clearHistory()`: Clears the undo/redo stack.

---
**End of Report.**
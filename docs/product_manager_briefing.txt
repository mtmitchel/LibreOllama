===================================================
    PRODUCT MANAGER BRIEFING DOCUMENT
===================================================

Generated: 07/09/2025 17:11:42

This document contains a compilation of all relevant
project planning, roadmap, and status documents.
It is intended to provide a comprehensive overview
for decision-making and future planning.



---------------------------------------------------
--  High-Level Project Roadmap
---------------------------------------------------


# LibreOllama Project Roadmap

This document serves as the central hub for tracking the development of the LibreOllama application. It is broken down into modules, each with its own detailed roadmap.

## Core Features

- [Canvas](./roadmap/01_canvas.md)
- [Gmail Integration](./roadmap/02_gmail_integration.md)
- [Tasks Management](./roadmap/03_tasks_management.md)
- [Calendar & Tasks Integration](./roadmap/04_calendar_integration.md)
- [Chat System](./roadmap/06_chat_system.md)
- [Dashboard](./roadmap/07_dashboard.md)
- [Projects](./roadmap/09_projects.md)
- [Agents](./roadmap/10_agents.md)
- [Notes](./roadmap/11_notes.md)

## Foundational Systems

- [Backend Services](./roadmap/05_backend_services.md)
- [General UI/UX](./roadmap/08_ui_ux.md)

## How to Use

1.  **Review the roadmap for a specific feature** by clicking one of the links above.
2.  **Identify a task** you want to work on.
3.  **Create a new branch** for your feature or bugfix.
4.  **Mark the task as in-progress** by changing `[ ]` to `[x]` (or `[~]` for in-progress if you prefer) and commit the change to the roadmap file.
5.  **When your work is complete**, create a pull request. Once merged, the task will be considered done. 


---------------------------------------------------
--  Detailed Feature Roadmaps
---------------------------------------------------



###
### FILE: 01_canvas.md
###

# Canvas Development Roadmap

This document provides a comprehensive overview of the Canvas feature, including its current implementation details and future development plans.

## Design Assets

- **Mockup:** [canvas mockup.png](../../design/mockups/canvas%20mockup.png)
- **Spec:** [canvas.html](../../design/specs/canvas.html)

## Current Implementation

The canvas is a core feature of the application, built using React Konva and a sophisticated state management system.

### Frontend Architecture

- **Rendering Engine:** `react-konva` & `konva` for 2D canvas rendering.
- **State Management:** A unified Zustand store (`unifiedCanvasStore.ts`) manages all canvas-related state, including elements, tools, and UI properties. It uses Immer for immutable state updates.
- **Component Structure:**
    - `CanvasContainer.tsx`: The main wrapper component.
    - `CanvasLayerManager.tsx`: Manages the different layers (background, main, connector, UI).
    - `ElementRenderer.tsx`: A key component responsible for rendering different canvas elements (shapes, text, etc.) based on their type.
    - `UnifiedEventHandler.tsx`: A centralized handler for all canvas events (mouse, keyboard, drag), which translates user interactions into store actions.
- **Tools System:** A modular tool system is located in `src/features/canvas/tools/`. It includes base classes for creation tools (`BaseCreationTool.tsx`) and specific tools like `PenTool`, `TextTool`, and `ConnectorTool`.
- **Performance:** Optimizations include viewport culling, `React.memo` on heavy components, and granular selectors to minimize re-renders.

### Backend Architecture

- **Persistence:** The backend currently has a command `save_canvas_state` in `src-tauri/src/commands/canvas.rs` which saves the current canvas JSON to `canvas-save.json`.
- **No Real-time:** There is currently no real-time backend support for the canvas.

### Implemented Features

- Core tools: Pen, Text, Sticky Notes, Sections, Connectors.
- Selection and transformation of elements.
- Undo/redo functionality via the `useCanvasHistory` hook.
- A layer management system.

## Future Work & Todos

### High Priority / Known Issues

- [ ] **Bugfix:** Fix tool consistency issues that appear under intensive use.
- [ ] **Bugfix:** Address the occasional need for re-selection of transform handles.
- [ ] **Bugfix:** Investigate and fix inconsistent element movement.

### Feature Enhancements

- [ ] **Real-time Collaboration:** Implement backend services (likely WebSocket-based) to enable multi-user real-time collaboration. This includes:
    - [ ] Broadcasting user cursors.
    - [ ] Synchronizing element creation, modification, and deletion.
- [ ] **New Shape Types:** Add more pre-defined shapes like diamonds, stars, and other common flowchart/diagram symbols.
- [ ] **Template Library:** Develop a system for users to save and load canvas templates for common diagrams.
- [ ] **Improved Connectors:** Enhance the connector logic for better automatic routing and to avoid overlapping elements.

### UX/UI Improvements

- [ ] **Toolbar Redesign:** Refine the visual design of the toolbar and tool icons for better clarity and aesthetics.
- [ ] **Keyboard Shortcuts:** Implement a comprehensive set of keyboard shortcuts for all major tools and actions to improve power-user workflow.
- [ ] **Alignment Guides:** Improve the "snap-to-grid" and smart alignment guides for easier element positioning.

### Technical Debt & Refactoring

- [ ] **Refactor `UnifiedEventHandler`:** Review and refactor the central event handler for better clarity, performance, and maintainability.
- [ ] **Increase Test Coverage:** Add more tests for complex user interactions like drag-and-drop and multi-select to improve stability.
- [ ] **Documentation:** Create detailed documentation for the canvas store architecture, data flow, and event handling logic.
- [ ] **Backend Persistence:** Move from a single JSON file to a proper database solution for storing canvas data, especially for multi-canvas and multi-user support. 

###
### FILE: 02_gmail_integration.md
###

# Gmail Integration Roadmap

This document provides a comprehensive overview of the Gmail Integration feature, including its current implementation details and future development plans.

## Design Assets

- **Mockup:** None available in `design/mockups/`.
- **Spec:** None available in `design/specs/`.

## Current Implementation

The Gmail integration connects directly to the Google API, providing real email functionality within the application. It has a robust service-oriented architecture.

### Backend Architecture (Rust)

- **Core Services:** The backend is built in Rust within the `src-tauri/src/services/gmail/` directory. It features a clean separation of concerns:
    - `auth_service.rs`: Handles the entire OAuth2 flow, including token acquisition, refresh, and secure storage in the OS keyring.
    - `api_service.rs`: Manages all direct communication with the Gmail API for fetching messages, labels, etc.
    - `cache_service.rs`: Provides a caching layer to reduce API calls and improve performance.
- **Tauri Commands:** The `src-tauri/src/commands/gmail/` directory exposes the backend services to the frontend via Tauri commands (e.g., `get_gmail_labels`, `send_email`).
- **Error Handling:** A dedicated error module ensures that API errors, network issues, and authentication failures are handled gracefully.
- **Multi-Account Support:** The backend is designed to support multiple Gmail accounts, storing tokens and data separately for each.

### Frontend Architecture

- **Service Layer:** A frontend service (`gmailApiService.ts`) acts as a bridge, calling the Tauri commands to interact with the backend. It centralizes all frontend-to-backend communication.
- **State Management:** The `mailStore.ts` (a Zustand store) manages all mail-related state, including accounts, messages, labels, and UI state.
- **Components:** The UI is composed of various React components in `src/features/mail/components/` for displaying the mailbox, composing messages, handling attachments, etc.

### Implemented Features

- Secure OAuth2 authentication and multi-account management.
- Fetching, displaying, and parsing of email messages.
- Basic email operations (reply, forward, delete).
- Rate limiting and robust error handling on the backend.

## Future Work & Todos

### High Priority / Known Issues

- [ ] **Bugfix:** Resolve the 2 failing backend tests related to minor OAuth configuration issues.
- [ ] **Bugfix:** Fix frontend test failures that appear to be caused by race conditions between data fetching and test assertions.
- [ ] **Setup:** Finalize and document the required environment variable configuration for OAuth (`.env` file).

### Feature Enhancements

- [ ] **Email Categorization:** Implement an automatic email categorization/sorting system (e.g., "Primary", "Promotions", "Social").
- [ ] **Filter Management:** Add support for users to create and manage their Gmail filters directly from the application.
- [ ] **Calendar Integration:** Integrate with the Calendar feature to allow creating events directly from emails.
- [ ] **Scheduled Sending:** Add the ability for users to schedule emails to be sent at a later time.

### UX/UI Improvements

- [ ] **Multi-Account UI:** Improve the UI for switching between and managing multiple linked Gmail accounts.
- [ ] **Rich Text Editor:** Enhance the email composition window with a full-featured rich text editor (bold, italics, lists, etc.).
- [ ] **Attachment Handling:** Design a more intuitive and powerful interface for viewing, downloading, and managing email attachments.

### Technical Debt & Refactoring

- [ ] **Backend Warnings:** Address the 49 compiler warnings in the backend Rust code (mostly unused imports and dead code).
- [ ] **Offline Support:** Refactor the frontend store (`mailStore.ts`) to handle offline access more gracefully, perhaps with more aggressive caching or a local-first approach.
- [ ] **API Error Feedback:** Improve the error handling on the frontend to provide more specific and helpful feedback to the user when an API call fails. 

###
### FILE: 03_tasks_management.md
###

# Tasks Management Roadmap

This document provides a comprehensive overview of the Tasks Management feature, detailing its current implementation and future plans. It is currently considered **Production-Ready**.

## Design Assets

- **Mockup:** [tasks mockup.png](../../design/mockups/tasks%20mockup.png)
- **Spec:** [Tasks.html](../../design/specs/Tasks.html)

## Current Implementation

The Tasks page is a robust, client-side Kanban board for task management, built with a focus on performance and user experience.

### Frontend Architecture

- **State Management:** The `useKanbanStore.ts` is a dedicated Zustand store that manages all task and column data. It handles all CRUD operations and state logic.
- **Persistence:** All tasks and columns are persisted in the browser's `localStorage`, making any changes available across page refreshes. The store handles serialization and deserialization automatically.
- **Drag and Drop:** The `@dnd-kit` library is used to provide a professional and accessible drag-and-drop experience for moving tasks between columns. It includes features like a `DragOverlay` for visual feedback.
- **Component Structure:**
    - `Tasks.tsx`: The main page component that orchestrates the different views and the modal.
    - `TaskColumn.tsx` & `TaskCard.tsx`: Memoized components for displaying columns and individual tasks, optimized to prevent unnecessary re-renders.
    - `SimpleTaskModal.tsx`: A comprehensive modal for creating and editing tasks with full metadata support.
- **Metadata:** Tasks support rich metadata, including priority, labels, subtasks with completion status, and complex recurring task rules.

### Backend Architecture

- **No Backend:** This feature is currently **100% client-side**. All data is stored and managed in the browser's `localStorage`. There are no Tauri commands or backend services associated with it.

### Implemented Features

- Full task CRUD operations (Create, Read, Update, Delete).
- Kanban and List view modes.
- LocalStorage persistence.
- Professional drag-and-drop with visual feedback.
- Comprehensive task metadata (priority, labels, subtasks, recurring tasks).
- Timezone-correct date handling.
- Performance optimized with `React.memo`, `useCallback`, and efficient re-renders.

## Future Work & Todos

### High Priority / Known Issues

- [ ] **Accessibility:** Implement full accessibility for the Tasks page. This includes:
    - [ ] Keyboard navigation for all interactive elements (creating tasks, moving between columns, editing).
    - [ ] Proper ARIA labels and roles for drag-and-drop actions.
    - [ ] Full screen reader support.

### Feature Enhancements

- [ ] **Lazy Loading:** For columns with a very large number of tasks, fetch and render tasks lazily to reduce the initial load time.
- [ ] **Advanced Filtering:** Add advanced filtering and sorting options to the list view (e.g., sort by due date, filter by priority or label).
- [ ] **Task Dependencies:** Implement a system for defining dependencies between tasks (e.g., "Task B cannot start until Task A is complete").
- [ ] **Search:** Add a search functionality to quickly find tasks across all columns by title or content.
- [ ] **Backend Sync:** Add an optional backend synchronization feature to save tasks to a central database, enabling cross-device access.

### UX/UI Improvements

- [ ] **Storybook Coverage:** Create Storybook stories for the `TaskCard`, `TaskColumn`, and `SimpleTaskModal` components and enable Chromatic for visual regression testing.
- [ ] **Mobile Responsiveness:** Improve the experience on mobile devices:
    - [ ] Enable horizontal scroll-snap for columns on smaller screens.
    - [ ] Verify and improve touch-based drag-and-drop support and momentum scrolling.

### Technical Debt & Refactoring

- [ ] **Performance Benchmarking:** Perform a performance benchmark using Lighthouse and the React Profiler to ensure the UI remains fast (target ≤ 100ms updates) even with a very large number of tasks (~1,000).
- [ ] **Documentation:** Create documentation for the Kanban architecture and best practices, and add it to the project's `docs`. 

###
### FILE: 04_calendar_integration.md
###

# Calendar & Tasks Integration Roadmap

This document provides a comprehensive overview of the Calendar and Tasks integration, including its current state, the significant implementation gap, and the steps required to create a cohesive user experience.

## Design Assets

- **Mockup:** [calendar mockup.png](../../design/mockups/calendar%20mockup.png)
- **Spec:** [calendar.html](../../design/specs/calendar.html)

## Current Implementation

The current implementation consists of two separate, functional systems that are not yet properly integrated.

### Frontend Architecture

- **Calendar View:** The `Calendar.tsx` page uses the `FullCalendar` library to display events from Google Calendar. It includes a sidebar that displays tasks from the `googleTasksService`.
- **Tasks View:** The `Tasks.tsx` page is a fully functional Kanban board that uses the `googleTasksService` to manage task lists and tasks.
- **Services:**
    - `googleCalendarService.ts`: Interacts with the Google Calendar API.
    - `googleTasksService.ts`: Interacts with the Google Tasks API.
- **State Management:** A legacy Zustand store, `googleStore.ts`, manages the state for both calendar events and Google Tasks. This is separate from the `useKanbanStore` used for the local-only tasks board.

### Backend Architecture

- **Direct API Calls:** The frontend services make calls to Tauri commands which in turn call the Google Calendar and Tasks APIs via the Rust backend services. There is no specific integration logic on the backend; it simply provides access to the Google APIs.

### Implementation Gap: The Missing Workflow

The core value proposition of this feature was the ability to seamlessly schedule tasks by dragging them from a task list onto the calendar. **This workflow is completely missing.**

- **What Works:** You can view calendar events. You can manage Google Tasks in a separate Kanban view.
- **What Doesn't Work:**
    - You cannot drag a task from the sidebar and drop it onto the calendar to schedule it.
    - There is no "Schedule Task" modal to set a time when a task is dropped.
    - The core logic to convert a task into a calendar event (`task-to-event`) is not implemented.

## Future Work & Todos

### High Priority / Bridging the Gap

- [ ] **Implement Drag-and-Drop Time Blocking:** This is the highest priority.
    - [ ] Add `droppable` behavior to the FullCalendar component.
    - [ ] Add event handlers to capture when a task is dropped onto a specific date.
- [ ] **Create "Schedule Task" Modal:**
    - [ ] Design and build a modal that appears when a task is dropped on the calendar.
    - [ ] This modal must include start and end time inputs.
- [ ] **Implement Task-to-Event Conversion:**
    - [ ] Create the core logic in the `googleCalendarService` to create a new calendar event from a task's data.
    - [ ] This should include the title, description, and the date/time from the modal.
- [ ] **Complete from Calendar:** Allow tasks to be marked as complete directly from the calendar view, without having to go to the Tasks page.
- [ ] **Enhanced Event Modal:** Replace the basic event creation prompt with a full-featured modal.

### Feature Enhancements

- [ ] **Recurring Tasks:** Add the ability to see and manage recurring tasks on the calendar.
- [ ] **Event Resizing:** Allow users to resize events directly on the calendar to change their duration.
- [ ] **Display Task Priority:** Show a visual indicator of a task's priority on the calendar event.

### UX/UI Improvements

- [ ] **Visual Distinction:** Improve the visual design to make a clear distinction between regular calendar events and scheduled tasks.
- [ ] **Drag Feedback:** Provide better visual feedback during the drag-and-drop operation from the task sidebar to the calendar.

### Technical Debt & Refactoring

- [ ] **Consolidate Stores:** This is critical. Refactor the state management to have a single source of truth for tasks. The logic from the legacy `googleStore.ts` should be merged or reconciled with the newer `useKanbanStore.ts`.
- [ ] **Improve Test Coverage:** Write integration tests that specifically cover the new drag-and-drop scheduling workflow. 

###
### FILE: 05_backend_services.md
###

# Backend Services Roadmap

This document provides a comprehensive overview of the backend services, which are built with Rust in the `src-tauri` directory.

## Design Assets

- This is a non-visual, architectural component. No specific design assets apply.

## Current Implementation

The backend follows a professional, service-oriented architecture with a clear separation of domains.

### Core Architecture

- **Language:** The entire backend is written in **Rust** for performance and safety.
- **Framework:** It's built as a **Tauri** backend, which allows it to be called securely from the JavaScript frontend.
- **Service-Oriented Design:** The code is organized by domain into services (e.g., `services/gmail`, `services/agents`). Each service encapsulates its own logic and data access.
- **Database:** The project uses **SQLite** for its database, managed by the `database/connection.rs` and `database/operations` modules. This provides a lightweight, file-based database solution.
- **Error Handling:** There is a centralized error handling system (`errors/mod.rs`) to ensure consistent error responses across the application.

### Key Implemented Features

- **Gmail Integration:** A full suite of services for handling Gmail OAuth2 authentication, API interaction, and caching.
- **Tauri Commands:** Dozens of Tauri commands are implemented in `commands/` to expose backend functionality to the frontend in a secure way.
- **Database Operations:** A comprehensive set of database operations for managing application data.
- **Testing:** The backend has a good testing foundation, with `40 passing tests` that cover services and integration points.

## Future Work & Todos

### High Priority / Known Issues

- [ ] **Fix Failing Tests:** Resolve the `2 failing tests`. Based on previous reports, these are related to OAuth configuration and Gmail API scopes.
- [ ] **Clean Up Warnings:** Eliminate the `49 compiler warnings`. These are mostly unused imports and dead code that should be easy to clean up but are important for code hygiene.

### Feature Enhancements

- [ ] **Robust Caching:** Implement a more robust, application-wide caching layer for all major API endpoints to improve performance and reduce API usage.
- [ ] **Background Sync:** Develop a system for background data synchronization, allowing the app to fetch data periodically without blocking the UI.
- [ ] **WebSocket Support:** Add WebSocket support to enable real-time features, particularly for the Canvas collaboration and Chat system.
- [ ] **Chat API:** Design and create a comprehensive set of backend services and API commands for the Chat system, moving it from mock data to a real, persistent feature.

### Security

- [ ] **Security Audit:** Conduct a full security audit of all backend services, especially those handling sensitive data like authentication tokens and user content.
- [ ] **End-to-End Encryption:** For features that require it (like Chat or Notes), implement end-to-end encryption for user data stored in the database.
- [ ] **Input Validation:** Strengthen validation and sanitization on all data received from the frontend via Tauri commands.

### Technical Debt & Refactoring

- [ ] **Database Schema:** Improve the database schema by adding proper indexing to tables to ensure queries remain fast as the amount of data grows.
- [ ] **Error Handling:** Refactor the error handling system to be even more consistent and to provide more informative error messages to the frontend.
- [ ] **Unified Logging:** Create a unified logging strategy across all services to make debugging and monitoring easier. 

###
### FILE: 06_chat_system.md
###

# Chat System Roadmap

This document provides a comprehensive overview of the Chat System, including its current prototype implementation and the necessary steps to make it a fully functional feature.

## Design Assets

- **Mockup:** [chats mockup.png](../../design/mockups/chats%20mockup.png)
- **Spec:** [chat-hub.html](../../design/specs/chat-hub.html)

## Current Implementation (Prototype)

The chat system currently exists as a **fully client-side prototype** with a well-developed UI, but no backend functionality.

### Frontend Architecture

- **UI Components:** The UI is located in `src/features/chat/components/` and is feature-rich, including:
    - `Chat.tsx`: The main chat interface.
    - `ConversationList.tsx`: A sidebar for managing different conversations.
    - `ChatMessageBubble.tsx`: A component for displaying individual messages, styled with the "ghost" low-fatigue design.
    - `ChatInput.tsx`: A flexible input component for typing messages.
- **Mock Data:** The entire chat experience is powered by mock data from `src/core/lib/chatMockData.ts`. There is no connection to a real AI or backend service.
- **State Management:** The state is managed locally within the React components. There is no centralized store for chat data yet.

### Backend Architecture

- **No Backend Implementation:** There are currently **no backend services, Tauri commands, or database tables** for the chat system. The `src-tauri/src/commands/chat/` directory exists but is likely a placeholder.

### Implemented Features (UI Only)

- A complete chat UI with conversation list, message bubbles, and input.
- Conversation management UI (create, select, pin, delete).
- A responsive layout with collapsible sidebars.
- Ghost-style message bubbles for a clean, low-fatigue design.

## Future Work & Todos

### High Priority / Core Functionality

- [ ] **Backend Integration:** This is the most critical step.
    - [ ] Design and implement the database schema for storing conversations, messages, and users.
    - [ ] Create backend services in Rust for all chat operations (sending messages, fetching history, managing conversations).
    - [ ] Expose these services to the frontend via new Tauri commands in `src-tauri/src/commands/chat/`.
- [ ] **AI Integration:** Integrate with a real AI backend (e.g., via a local Ollama instance or an external API) to provide responses.
- [ ] **Persistent Storage:** Connect the frontend to the backend to replace the mock data with persistent storage.
- [ ] **Message Editing:** Enable the existing UI for message editing to work by calling the backend.
- [ ] **"Create Task from Message":** Implement the backend logic to create a new task in the Tasks system from a chat message.

### Feature Enhancements

- [ ] **File Attachments:** Add support for uploading and attaching files to chat messages.
- [ ] **Multi-User Chat:** Implement the concept of chat rooms to allow for multi-user conversations.
- [ ] **Plugin System:** Develop a plugin system to extend the chat's functionality (e.g., custom slash commands).
- [ ] **Message Reactions:** Add support for emoji reactions to messages.

### UX/UI Improvements

- [ ] **Loading Indicators:** Add loading skeletons and indicators that appear while waiting for AI responses or fetching message history.
- [ ] **Code Block Handling:** Improve the rendering of code blocks with syntax highlighting and a "copy" button.
- [ ] **Message Animations:** Animate the appearance of new messages to make the conversation feel more dynamic.

### Technical Debt & Refactoring

- [ ] **Dedicated Chat Store:** Create a dedicated Zustand store (`chatStore.ts`) to manage all chat-related state efficiently, especially for handling real-time updates from a WebSocket.
- [ ] **API Contract:** Create a clear, documented API contract between the frontend and the backend chat service.
- [ ] **Test Coverage:** Add comprehensive tests for the chat functionality, including both backend unit tests and frontend integration tests. 

###
### FILE: 07_dashboard.md
###

# Dashboard Roadmap

This document provides a comprehensive overview of the Dashboard feature, including its current implementation and future development plans.

## Current Implementation

The Dashboard serves as a home page, providing an at-a-glance view of various parts of the application through a system of widgets.

### Frontend Architecture

- **Widget System:** The core of the dashboard is a widget system. The components are located in `src/features/dashboard/components/`.
- **Existing Widgets:**
    - `WelcomeWidget.tsx`: A simple welcome message.
    - `AgentStatusWidget.tsx`: Displays the status of different agents.
    - `ProjectProgressWidget.tsx`: Shows the progress of various projects.
- **Layout:** The dashboard uses a simple grid layout to arrange the widgets.
- **State Management:** Currently, state is likely managed within individual widgets, fetching data as needed. There does not appear to be a dedicated store for the dashboard itself.

### Backend Architecture

- **No Direct Backend:** The dashboard itself doesn't have dedicated backend services. Instead, each widget is responsible for fetching its own data from other backend services (e.g., the `AgentStatusWidget` would fetch data from the agent services).

### Implemented Features

- A functional widget system.
- Three initial widgets providing basic information.
- A clean, responsive layout.

## Future Work & Todos

### Feature Enhancements

- [ ] **Widget Configuration:** Make widgets configurable. For example, allow the user to choose which projects are displayed in the `ProjectProgressWidget`.
- [ ] **New Widget Types:** Add more widget types to provide more value. Potential new widgets include:
    - [ ] A "Recent Emails" widget.
    - [ ] A "Calendar" widget showing upcoming events.
    - [ ] A "Recent Notes" widget.
    - [ ] A "GitHub Activity" widget.
- [ ] **Customizable Layout:** Implement a drag-and-drop interface that allows users to rearrange and resize widgets to create a personalized dashboard layout.
- [ ] **Multiple Dashboards:** Allow users to create and save multiple, distinct dashboards for different workflows or projects.

### UX/UI Improvements

- [ ] **Information Density:** Improve the visual design and information density of the existing widgets to make them more useful.
- [ ] **Loading Animations:** Add loading animations or skeletons that appear while widget data is being fetched.
- [ ] **Responsiveness:** Perform a full review of the dashboard's responsiveness to ensure it is fully usable and looks great on all screen sizes.

### Technical Debt & Refactoring

- [ ] **Modular Widget System:** Refactor the widget system to be more modular and extensible, making it easier to create and add new widgets in the future.
- [ ] **Performance:** Improve the performance of data fetching for the widgets, potentially by creating a dedicated dashboard service that can fetch data for multiple widgets in a single batch.
- [ ] **Test Coverage:** Add tests for the dashboard components and their interactions, including how they fetch and display data. 

###
### FILE: 08_ui_ux.md
###

# General UI/UX Roadmap

This document provides a comprehensive overview of the application's design system, general UI/UX patterns, and future development plans.

## Current Implementation

The application has a solid design foundation, using Tailwind CSS, a well-defined set of design tokens, and an interactive component workshop with Ladle.

### Core Architecture

- **Design Tokens:** The single source of truth for all design tokens (colors, spacing, typography, etc.) is [`/src/core/design-system/globals.css`](../../src/core/design-system/globals.css). These are exposed as CSS variables.
- **Styling:** **Tailwind CSS** is used for all styling, configured in `tailwind.config.ts` to use our design tokens.
- **Component Workshop:** We use **Ladle** (`npm run ladle`) for interactive component development, testing, and documentation. Configuration is in `.ladle/`.
- **Component Stories:** Component examples and documentation are created in `*.stories.tsx` files, located alongside the components they document. We have excellent system-level stories in `src/core/design-system/`.

## Future Work & Todos

### High Priority

- [ ] **Accessibility Audit:** Using the `AccessibilityAudit.stories.tsx` as a starting point, conduct a full accessibility audit of the entire application to ensure it complies with WCAG standards.
- [ ] **Expand Ladle Story Coverage:** The highest priority is to ensure all UI components in `src/components/ui/` have a corresponding `.stories.tsx` file with complete controls for all props.
- [ ] **Formalize Design System:** While the implementation is strong, we need to ensure the `design/system/overview.md` document is kept up-to-date with the ground truth in `globals.css`.

### Enhancements

- [ ] **Dark Mode Polish:** Fully test the dark mode theme across all components and pages to ensure consistency and fix any visual issues.
- [ ] **Micro-interactions:** Add subtle, meaningful animations and transitions to improve user feedback and make the application feel more polished.
- [ ] **Icon System Review:** Formalize the usage of the `lucide-react` icons to ensure consistency in style, size, and meaning across the app.
- [ ] **Continuous Improvement:** Regularly review and refine existing components based on user feedback and evolving design standards.

### Technical Debt & Refactoring

A comprehensive review of the existing codebase has been performed to identify deviations from the established design system. The findings are documented in the **[Design System Audit](../DESIGN_SYSTEM_AUDIT.md)**.

The primary goal of the UI/UX team moving forward is to systematically address the issues outlined in the audit. This involves:

- **Phase 1: Token & Utility Class Cleanup:**
  - [ ] **Canvas:** Refactor `style` props to use Tailwind utility classes.
  - [ ] **Mail:** Replace all direct `var()` injections and hardcoded colors with Tailwind utilities. Refactor custom buttons.
  - [ ] **Notes:** Refactor container `div` to use standard Tailwind utility classes.
  - [ ] **Agents:** Replace all direct `var()` injections with Tailwind utilities.
- **Phase 2: Architectural Refactoring:**
  - [ ] **Projects:** Refactor the data layer to remove hardcoded CSS variables from mock data.
  - [ ] **Chat:** Complete rewrite of the `ChatMessageBubble` component to properly use the design system without overrides.
- **Phase 3: Component Consolidation:**
  - [ ] **Modals:** Refactor all modal components (`Tasks`, `Calendar`) to use a single, consistent overlay style from the design system, removing hardcoded `bg-black` styles.

---

- [ ] **Identify & Refactor Hardcoded Styles:** Systematically find and replace any remaining hardcoded style values with the proper Tailwind utility classes that use our design tokens.
- [ ] **CSS Cleanup:** Remove any unused or duplicate custom CSS from `globals.css` or other stylesheets.
- [ ] **Documentation:** Ensure the `DEVELOPER_DESIGN_GUIDE.md` is kept up-to-date with any changes to our workflow. 

###
### FILE: 09_projects.md
###

# Projects Page Roadmap

This document provides a comprehensive overview of the Projects page, including its current placeholder implementation and future development plans.

## Current Implementation (Placeholder)

The Projects page is currently a placeholder with a minimal UI and no backend functionality.

### Frontend Architecture

- **UI Components:** The UI is located in `src/features/projects/components/` and is very basic:
    - `Projects.tsx`: The main page component.
    - `NewProjectModal.tsx`: A modal for creating a new project (UI only).
    - `NoProjectSelected.tsx`: A placeholder screen for when no project is selected.
- **State Management:** There is no dedicated store for projects. State is likely managed locally within the components.

### Backend Architecture

- **No Backend Implementation:** There are currently **no backend services, Tauri commands, or database tables** for managing projects.

### Implemented Features

- A basic UI shell for the Projects page.
- A non-functional "New Project" modal.

## Future Work & Todos

### High Priority / Core Functionality

- [ ] **Define Scope:** Define the full scope of project management features. This should include:
    - [ ] What fields define a project (e.g., name, description, start/end dates, team members)?
    - [ ] What actions can be performed on a project?
- [ ] **Backend Implementation:**
    - [ ] Design the database schema for projects.
    - [ ] Create backend services in Rust for all project CRUD operations.
    - [ ] Expose these services to the frontend via new Tauri commands.
- [ ] **Frontend Integration:**
    - [ ] Create a dedicated Zustand store (`projectStore.ts`) to manage project state.
    - [ ] Connect the frontend components to the backend by calling the new Tauri commands.
    - [ ] Make the `NewProjectModal` fully functional.

### Feature Enhancements

- [ ] **Timeline/Gantt View:** Add a timeline or Gantt chart view to visualize project schedules.
- [ ] **Task Integration:** Integrate projects with the Tasks feature, allowing tasks to be associated with specific projects.
- [ ] **Search & Filtering:** Implement a search and filtering system to easily find projects.

### UX/UI Improvements

- [ ] **Enhance `NewProjectModal`:** Add more configuration options to the modal, such as setting deadlines or assigning team members.
- [ ] **Improve `NoProjectSelected`:** Make the "No Project Selected" screen more informative and visually appealing, perhaps with a guide on how to create a new project.
- [ ] **Project Dashboard:** Design the main project view to be an intuitive and useful dashboard for a single project.

### Technical Debt & Refactoring

- [ ] **Test Coverage:** Add comprehensive tests for all new project-related components and services.
- [ ] **Scalable Store:** Design the `projectStore` to be scalable and performant, even with a large number of projects.
- [ ] **Documentation:** Document the new project data model and the API for interacting with it. 

###
### FILE: 10_agents.md
###

# Agents Page Roadmap

This document provides a comprehensive overview of the Agents feature, including its current placeholder implementation and the necessary steps to define and build it.

## Current Implementation (Placeholder)

The Agents page is currently a placeholder with a minimal UI and a skeletal backend implementation. The core concept of what an "Agent" is needs to be fully defined.

### Frontend Architecture

- **UI Components:** A basic `Agents.tsx` page component exists. There do not appear to be any other specific components for agent configuration or display.
- **State Management:** There is no dedicated store for agents.

### Backend Architecture

- **Placeholder Services:** The backend has a directory for agent services (`src-tauri/src/services/agents/`) and commands (`src-tauri/src/commands/agents/`), but these are likely placeholders without significant logic. `lifecycle.rs` suggests a concept of running and stopping agents.

### Implemented Features

- A basic UI shell for the Agents page.
- Placeholder backend files.

## Future Work & Todos

### High Priority / Core Functionality

- [ ] **Define "Agent" Concept:** This is the most critical first step. We need to clearly define what an "Agent" is in the context of this application. Is it:
    - An automated workflow?
    - A connection to an external AI model?
    - A background task runner?
- [ ] **Backend Implementation:** Once the concept is defined, build the core backend services.
    - [ ] Design the database schema for storing agent configurations.
    - [ ] Create Rust services for creating, configuring, running, and stopping agents.
    - [ ] Implement the logic within the `lifecycle.rs` command for managing agent execution.
- [ ] **Frontend UI:** Develop the core UI for interacting with agents.
    - [ ] Create a view to list all available agents.
    - [ ] Design a component for creating and configuring a new agent.
    - [ ] Build a view to see the status and output of a running agent.
- [ ] **Frontend Integration:**
    - [ ] Create a dedicated Zustand store (`agentStore.ts`) to manage agent state.
    - [ ] Connect the new UI components to the backend services via Tauri commands.

### Feature Enhancements

- [ ] **Event Triggers:** Allow agents to be triggered automatically by events in other parts of the application (e.g., "when a new email arrives from sender X, run agent Y").
- [ ] **Agent Library:** Create a library of pre-built agents for common tasks that users can easily add and configure.
- [ ] **Monitoring & Logging:** Implement a system for monitoring agent activity, including logs, performance metrics, and success/failure status.

### UX/UI Improvements

- [ ] **Configuration Interface:** Design an intuitive, user-friendly interface for configuring complex agent parameters without needing to write code.
- [ ] **Status Visualization:** Create clear visualizations for agent status (e.g., running, idle, error) and performance.

### Technical Debt & Refactoring

- [ ] **Test Coverage:** Add comprehensive tests for the entire agent lifecycle: creation, configuration, execution, and deletion.
- [ ] **Scalability:** Refactor the agent service to ensure it is reliable and can scale to handle many agents running concurrently.
- [ ] **Documentation:** Document the agent architecture, the API for interacting with agents, and how to create new types of agents. 

###
### FILE: 11_notes.md
###

# Notes Page Roadmap

This document provides a comprehensive overview of the Notes feature, including its current implementation and future development plans.

## Current Implementation

The Notes feature is a powerful, block-based text editor built using Tiptap, with a file-system-like folder structure for organization.

### Frontend Architecture

- **Editor Engine:** The core of the feature is the **Tiptap** editor (`TiptapEditor.tsx`). Tiptap is a headless editor framework, which gives us full control over the look and feel.
- **Component Structure:** The feature is composed of several key components found in `src/features/notes/components/`:
    - `BlockEditor.tsx`: The main component that brings together the editor and its UI elements.
    - `FolderTree.tsx`: A component for displaying and navigating a hierarchical folder structure.
    - `TiptapFixedToolbar.tsx`: A toolbar that is fixed at the top of the editor.
    - `TiptapSlashCommand.tsx`: A slash command menu that allows for quick insertion of blocks and other elements.
- **State Management:** State is currently managed within the React components. There is no dedicated store for notes and folders yet.

### Backend Architecture

- **No Backend Implementation:** There are currently **no backend services, Tauri commands, or database tables** for saving notes or folders. The feature is client-side only at the moment.

### Implemented Features

- A rich text editor based on Tiptap.
- A fixed toolbar and a slash command menu.
- A folder tree for organizing notes.
- A clean, modern UI for note-taking.

## Future Work & Todos

### High Priority / Core Functionality

- [ ] **Backend Implementation:**
    - [ ] Design the database schema for storing notes (likely as JSON or HTML) and folders.
    - [ ] Create backend services in Rust for all CRUD operations on notes and folders.
    - [ ] Expose these services to the frontend via new Tauri commands.
- [ ] **Frontend Integration:**
    - [ ] Connect the `FolderTree` and `BlockEditor` to the backend services.
    - [ ] Ensure that creating, editing, and deleting notes and folders is persisted to the database.
- [ ] **Finalize Editor Functionality:** Ensure all buttons on the `TiptapFixedToolbar` and all options in the `TiptapSlashCommand` menu are fully functional.

### Feature Enhancements

- [ ] **Rich Media:** Add support for embedding rich media, like images and videos, directly into the notes.
- [ ] **Tagging and Search:** Implement a system for adding tags to notes and a powerful search functionality to find notes by title, content, or tag.
- [ ] **Sharing & Collaboration:** Add the ability for users to share notes with others, potentially with real-time collaborative editing.
- [ ] **Note Templates:** Create a template system for different types of notes (e.g., meeting minutes, daily planners, project outlines).

### UX/UI Improvements

- [ ] **Slash Command UX:** Refine the user experience of the slash command menu to make it more intuitive and powerful.
- [ ] **Folder Tree Drag-and-Drop:** Improve the drag-and-drop functionality within the `FolderTree` for reorganizing notes and folders.
- [ ] **Note Metadata:** Design and implement the `NoteMetadata.tsx` component to display useful information about the current note (e.g., word count, last updated time).

### Technical Debt & Refactoring

- [ ] **Dedicated Notes Store:** Create a dedicated Zustand store (`notesStore.ts`) to manage the state for notes and folders, which will be critical for handling data from the backend.
- [ ] **Test Coverage:** Add comprehensive tests for the Tiptap editor, its custom extensions, and the folder management logic.
- [ ] **Documentation:** Document the custom Tiptap extensions and the overall architecture of the notes feature. 


---------------------------------------------------
--  Design System Implementation Audit
---------------------------------------------------


# Design System Audit

This document tracks the adoption of the LibreOllama Design System across all major pages and features of the application. The goal is to achieve 100% adoption and eliminate all legacy and one-off styling.

**Disclaimer:** This audit is a high-level overview based on the analysis of a single, representative component file for each feature area. A full, comprehensive audit would require inspecting every component within a feature. This document serves as a starting point to identify recurring patterns and prioritize refactoring efforts.

**Legend:**
- ✅ **Full Adoption:** The page exclusively uses design system tokens and components. No legacy styles.
- 🟡 **Partial Adoption:** The page primarily uses the design system but contains some legacy styles or custom components that need to be refactored.
- ❌ **No Adoption:** The page is a placeholder or uses a significant amount of legacy styling.

---

| Page / Feature | Adoption Status | Notes & Action Items |
|---|---|---|
| **Tasks** | 🟡 Partial | - **Overall:** Very high adoption. A great template for other pages.<br>- **Action Item:** The `SimpleTaskModal` uses a hardcoded `bg-black bg-opacity-50` for its overlay. This should be replaced with a design system token like `bg-overlay`. |
| **Canvas** | 🟡 Partial | - **Overall:** The page structure uses design tokens, but incorrectly.<br>- **Action Item:** Refactor the page to use Tailwind utility classes (e.g., `p-layout-gutter`) instead of `style` props with CSS variables (e.g., `style={{ padding: 'var(--space-layout-gutter)' }}`). |
| **Mail** | 🟡 Partial | - **Overall:** Mixed adoption. Component contains multiple legacy patterns.<br>- **Action Items:**<br>  - Replace direct CSS variable injection in class names (e.g., `border-[var(--border-default)]`) with Tailwind utilities (e.g., `border-border-default`).<br>  - Remove hardcoded colors (e.g., `text-yellow-500`) and use system tokens.<br>  - Replace custom button with the shared `Button` component. |
| **Calendar** | 🟡 Partial | - **Overall:** Excellent adoption of components and tokens.<br>- **Action Item:** The `ScheduleTaskModal` uses a hardcoded `bg-black bg-opacity-50` for its overlay. Replace with a system token like `bg-overlay`. |
| **Dashboard** | ✅ Full | - **Overall:** Excellent adoption. This page is a model for implementing the design system correctly. |
| **Projects** | 🟡 Partial | - **Overall:** Strong component usage, but with a significant anti-pattern in the data layer.<br>- **Action Item:** Refactor the `mockProjects` data. Remove hardcoded CSS variables (e.g., `color: 'var(--primary)'`) and replace them with semantic token names (e.g., `color: 'primary'`). The rendering component should map the token name to the appropriate style. |
| **Agents** | 🟡 Partial | - **Overall:** Good component usage, but incorrect styling implementation.<br>- **Action Items:**<br>  - Replace all direct CSS variable injection in class names (e.g., `bg-[var(--accent-ghost)]`) with Tailwind utility classes.<br>  - Refactor custom hover styles on buttons to use standard `Button` variants for consistency. |
| **Notes** | 🟡 Partial | - **Overall:** Component structure is good, but container styling is incorrect.<br>- **Action Item:** Refactor the main container `div` to use standard Tailwind utility classes (e.g., `p-4`, `gap-4`) instead of direct CSS variable injection in class names (e.g., `p-[var(--space-4)]`). |
| **Chat** | ❌ No Adoption | - **Overall:** This component has very poor adoption and requires a full refactor.<br>- **Action Items:**<br>  - Rewrite the component to remove all direct CSS variable injections (`var(...)`) and use standard Tailwind utility classes.<br>  - Remove functions that generate custom class strings (`getUserMessageStyles`) and use component variants instead.<br>  - Eliminate all style overrides on shared components like `Button` and `Card`. The component's appearance should be governed by the design system, not by local, one-off styles. | 


---------------------------------------------------
--  Core Design System Principles & Overview
---------------------------------------------------


LibreOllama Workspace - Design System v1.12. IntroductionPurpose:This document outlines the design system for LibreOllama Workspace. Its purpose is to ensure visual and experiential consistency across the entire application, streamline the design and development process, and provide a shared language for all team members. This system is a living document and will evolve alongside the product.Core Philosophies:LibreOllama Workspace is built upon the following core philosophies, which are reflected in this design system:Simplicity: Strive for clarity and ease of use, avoiding unnecessary complexity.Cleanliness: Maintain a visually uncluttered interface with generous use of whitespace and purposeful design elements.Integration: Ensure a seamless and interconnected experience across all modules and features.User Empowerment: Provide users with control and flexibility to adapt the workspace to their needs.AI Augmentation: Design with AI as a core, integrated partner to enhance productivity and creativity.Privacy-Focused: Prioritize user control over data with local-first considerations where appropriate.2. Foundations2.1. Color PaletteThe color palette is designed to be modern, accessible, and adaptable for both dark and light themes. Colors are defined using CSS variables for easy theming and maintenance, based on the comprehensive mockups.Primary Accent:--accent-primary: #3b82f6 (Blue 500 - Primary actions, active states, highlights)--accent-secondary: #1d4ed8 (Blue 700 - Darker shade for hover/pressed states)--accent-soft: rgba(59, 130, 246, 0.15) (Subtle background for active/selected items, adjusted from 0.1 for better visibility as seen in active chat list items)--accent-hover: rgba(59, 130, 246, 0.2) (Slightly darker hover for soft accent)Semantic Colors:Success: --success: #10b981 (Green 500), --success-soft: rgba(16, 185, 129, 0.1)Warning: --warning: #f59e0b (Amber 500), --warning-soft: rgba(245, 158, 11, 0.1)Error/Danger: --error: #ef4444 (Red 500), --error-soft: rgba(239, 68, 68, 0.1)Text Colors (Dark Theme):--text-primary: #ffffff--text-secondary: #94a3b8--text-tertiary: #64748b--text-muted: #475569Text Colors (Light Theme):--text-primary: #0f172a--text-secondary: #475569--text-tertiary: #64748b--text-muted: #94a3b8Background Colors (Dark Theme):--bg-primary: #0f1419--bg-secondary: #1a2332--bg-tertiary: #242b3d--bg-surface: #2a3441--bg-elevated: #323a47--bg-overlay: rgba(15, 20, 25, 0.95)Background Colors (Light Theme):--bg-primary: #ffffff--bg-secondary: #f8fafc--bg-tertiary: #f1f5f9--bg-surface: #ffffff--bg-elevated: #f9fafb--bg-overlay: rgba(248, 250, 252, 0.95)Border Colors (Dark Theme):--border-subtle: rgba(148, 163, 184, 0.1)--border-default: rgba(148, 163, 184, 0.2)--border-strong: rgba(148, 163, 184, 0.3)Border Colors (Light Theme):--border-subtle: rgba(0, 0, 0, 0.05)--border-default: rgba(0, 0, 0, 0.1)--border-strong: rgba(0, 0, 0, 0.2)2.2. TypographyFont Family: Inter, system-ui, sans-serifFont Weights: Regular (400), Medium (500), Semi-Bold (600), Bold (700).Font Size Scale (Core examples):Page Titles (e.g., Dashboard, Agent Management): 28px - 32px, Bold (700)Module/Section Titles (e.g., Chat Sidebar "Conversations", Widget Titles): 18px - 20px, Semi-Bold (600)Note Editor Title: 26px, Semi-Bold (600) (from mockup_notes_v1 Rev 4)Note Editor Headings: H1 28px (Bold), H2 22px (Semi-Bold) (from comprehensive mockups) / 24px (from mockup_notes_v1 Rev 4) - consistency needed, leaning towards user comprehensive scale. H1 30px, H2 24px from final notes mockup.Body/Standard Text: 14px - 16px, Regular (400) or Medium (500) for emphasis.Secondary Text/Labels: 12px - 14px, Regular (400) or Medium (500).Small/Muted Text: 11px - 12px, Regular (400).Line Heights: Body 1.6 - 1.7, Headings 1.2 - 1.4.Case: Sentence case for all UI text.2.3. Spacing & SizingBased on an 8px grid system, using --space- variables (4px to 64px). Consistent application for margins, paddings, and gaps.2.4. Border Radius--radius-sm: 4px (Tags, small UI elements)--radius-md: 6px (Buttons, inputs, list items)--radius-lg: 8px (Cards, widgets, some modals)--radius-xl: 12px (Larger containers like Command Palette)50% or 9999px for circular elements.2.5. ShadowsDefined by --shadow-sm, --shadow-md, --shadow-lg, --shadow-xl for depth and hierarchy.2.6. IconographyLibrary: Lucide Icons (lucide.dev).Default Size: 16px - 18px in text/buttons, 20px in navigation.Color: Inherits text color or uses specific semantic/accent variables.3. Components3.1. Buttons(As previously defined, ensuring sentence case for text).Quick Actions Widget Buttons: Justify content left, icon var(--space-2) margin-right.Block Type Toolbar Buttons (.block-type-btn in Notes): Smaller, distinct styling with icon and text.3.2. Input Fields(As previously defined).Search Input (.search-input): Placeholder text "Search or type a command (Ctrl+K)" or more generic "Search...". The Ctrl+K visual hint (.search-kbd) is shown.3.3. NavigationMain Sidebar (.sidebar):"Agents" section (not "AI agents")."Canvas" section (not "Whiteboards").Active nav item background: var(--accent-primary).Conceptual collapse button in sidebar header.Chat Sidebar (.chat-sidebar):Header: No "Conversations" title. Contains "+ New chat" button.Model Selector: Now part of the chat sidebar header, below the "New chat" button. Includes dropdown for model selection and status indicator.Search/Filter: Input field with an adjacent filter button.Sections:"Favorites" (denoted by a star icon, no text label).Folders (e.g., "Design Systems") with expand/collapse chevrons and item counts."Recent" conversations.List Items (.chat-list-item):Display title, preview of last message (optional).Metadata: Tags, last updated timestamp, participant indicators.Hover actions: Pin, Tag, Archive, Delete icons.Active state: Left accent border and var(--accent-soft) background.Notes Sidebar (.notes-sidebar):"My notebooks" title."+ New notebook" button.Tree structure for notebooks (folders) and notes. Expandable folders with chevrons and folder icons.Active folder: var(--accent-primary) background.Active note: var(--accent-primary) background.Project Tabs (.project-tabs): Text labels, active tab has accent color bottom border.View Switcher Tabs (.tasks-views, .calendar-views): Button-like tabs, active tab uses var(--accent-primary) background.3.4. Cards & Widgets(As previously defined).3.5. Modals & Overlays(As previously defined, ensuring Command Palette mentions generic "Type a command or search...").3.6. Chat Elements (Main Chat Area)Header (.chat-header):Left: Breadcrumb (e.g., "Workspace > Chat > Folder > Chat Title"). Current chat title.Right: Chat-specific actions (Add to project, Export, etc.). Model selector is NOT here anymore, moved to chat sidebar header.Message Bubbles (.message):Avatars (.message-avatar): Styled distinctly for "User" (accent) and "AI" (elevated surface).Sender Name (.message-sender): "You" or "LibreOllama Assistant" above the bubble.User message (.message.user .message-content): Solid var(--accent-primary) background, white text.AI message (.message.ai .message-content): var(--bg-surface) background, var(--border-default) border.Code Blocks: var(--bg-tertiary) background, language hint, prominent "Copy" button with icon.Attachments (.message-attachments): Richer previews for PDFs (thumbnail, filename, preview button), generic file icon for others.Input Area (.chat-input-area):Large text area (.chat-input) with placeholder "Ask about design, code, or anything else... (Ctrl+Enter to send)".Send button (.chat-send-btn) with send icon.Controls (.chat-input-controls): Attachment buttons (files, images), context indicator ("X files • Y tokens"), "Clear context" button.3.7. Note Editor Blocks (Refined based on mockup_notes_v1 Rev 4)Editor Header (.notes-editor-header):Note Title (.note-title-display): Large, bold.Actions (.note-actions): Star, Share, History, More - subtle ghost buttons.Block Type Toolbar (.block-type-toolbar): Below header, buttons for Text, H1, H2, Lists, Checklist, Code, Image, Table, Sketch.Content Area (.notes-editor-content): Max-width for readability.Individual Blocks (.editor-block): Clearer visual separation.Placeholder/Initial Block: "Type '/' for commands..." with subtle inline formatting icons (B, I, U).Paragraphs: Standard text.Headings: H1 (.heading1) larger, bold, with bottom border. H2 (.heading2) smaller, bold.Lists: ol, ul with standard styling. Action items use -  prefix.Checklist (.block-content.checklist): Styled checkboxes, completed items struck through.Code Block (.block-content.code-block): Distinct background, monospace font, "Copy" button.Image/Table Placeholders: Dashed borders, indicative icons/text.Wiki-Link (.wiki-link): Accent color, dotted underline.Floating Action Button (.fab): Bottom right, for adding new blocks.3.8. Calendar Elements(As previously defined, ensuring view switcher tabs are styled like .view-tab-group or .calendar-view-btn).Includes a "Tasks to schedule" panel (.time-blocking-panel).3.9. Kanban Board (Tasks Module)(As previously defined, ensuring view switcher tabs for Kanban/List are styled correctly).Task Cards (.kanban-task): Include priority indicators (colored dots/tags), assignee avatars, and due dates."Add task" button at the bottom of columns.List View (.task-list-view): Table format with columns for Title, Status, Priority, Due Date, Assignee, Project.3.10. Agent Cards (Agents Module)(As previously defined, ensuring module is named "Agents").4. LayoutMain Application Shell: (As previously defined).Two-Column Layouts: (As previously defined, names updated for "Canvas" and "Agents" if applicable).Grid Layouts: (As previously defined).5. Themes(As previously defined).6. Accessibility (WCAG 2.1 AA Goals)(As previously defined).7. Voice and Tone(As previously defined, emphasizing sentence case).This updated Design System (v1.12) should now more accurately reflect all the refinements and specific component designs we've discussed across the various static mockups and your comprehensive examples.

**Note on Current Status:** Phase 1 (Foundation) is complete. Phase 2 (Core Screen Transformations and Component Enhancements) is currently in progress. This document will be further updated as Phase 2 milestones are achieved.

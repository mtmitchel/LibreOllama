use crate::{
    database::DatabaseManager,
    services::google::tasks_service::{GoogleTasksService, CreateTaskInput, UpdateTaskInput},
    models::task_metadata::{CreateTaskMetadata, UpdateTaskMetadata, TimeBlock},
    models::task_id_map::{CreateTaskIdMap},
    commands::tasks::{metadata, id_map},
};
use std::sync::Arc;
use tauri::State;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateTaskRequest {
    pub account_id: String,
    pub task_list_id: String,
    pub local_id: Option<String>, // Frontend can provide a local ID, or we generate one
    pub title: String,
    pub notes: Option<String>,
    pub due: Option<String>,
    pub priority: Option<String>,
    pub labels: Option<Vec<String>>,
    pub time_block: Option<TimeBlock>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTaskRequest {
    pub account_id: String,
    pub task_list_id: String,
    pub task_id: String,  // This should be the stable local ID
    pub title: Option<String>,
    pub notes: Option<String>,
    pub due: Option<String>,
    pub status: Option<String>,
    pub priority: Option<String>,
    pub labels: Option<Vec<String>>,
    pub time_block: Option<TimeBlock>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteTaskRequest {
    pub account_id: String,
    pub task_list_id: String,
    pub task_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskResponse {
    pub id: String,          // This will be the stable local ID
    pub google_id: String,   // The Google Task ID (can change when moved)
    pub title: String,
    pub notes: Option<String>,
    pub due: Option<String>,
    pub status: String,
    pub position: Option<String>,
    pub updated: Option<String>,
    pub priority: String,
    pub labels: Vec<String>,
}

#[tauri::command]
pub async fn create_google_task(
    request: CreateTaskRequest,
    google_tasks_service: State<'_, GoogleTasksService>,
    db_manager: State<'_, Arc<DatabaseManager>>,
) -> Result<TaskResponse, String> {
    // Generate stable local ID if not provided
    let local_id = request.local_id.unwrap_or_else(|| id_map::generate_local_id());
    
    // Create task in Google Tasks
    let google_task = google_tasks_service
        .create_task(
            &request.account_id,
            &request.task_list_id,
            CreateTaskInput {
                title: request.title.clone(),
                notes: request.notes.clone(),
                due: request.due.clone(),
                status: Some("needsAction".to_string()),
            },
        )
        .await
        .map_err(|e| format!("Failed to create Google Task: {}", e))?;

    // Create mapping between local ID and Google ID
    let mapping = CreateTaskIdMap {
        local_id: local_id.clone(),
        google_task_id: google_task.id.clone(),
        task_list_id: request.task_list_id.clone(),
    };
    
    // Call the function directly since it's in the same crate
    crate::commands::tasks::id_map::create_task_id_mapping(
        mapping,
        db_manager.clone(),
    )
    .await
    .map_err(|e| format!("Failed to create ID mapping: {}", e))?;

    // Debug log to check if time_block is received
    eprintln!("üîµ TIMEBLOCK DEBUG - Create request received: has_time_block={}, time_block={:?}", 
        request.time_block.is_some(), request.time_block);
    
    // Store metadata in local DB linked to the stable local ID
    if request.priority.is_some() || request.labels.is_some() || request.time_block.is_some() {
        // Log what we're storing
        eprintln!("üìù Storing metadata for new task {} (local: {}): priority={:?}, labels={:?}", 
            google_task.id, local_id, request.priority, request.labels);
            
        match crate::commands::tasks::metadata::create_task_metadata(
            CreateTaskMetadata {
                google_task_id: google_task.id.clone(),
                task_list_id: request.task_list_id.clone(),
                priority: request.priority.clone(),
                labels: request.labels.clone(),
                subtasks: None,
                time_block: request.time_block.clone(),
            },
            db_manager.clone(),
        )
        .await {
            Ok(_) => eprintln!("‚úÖ Metadata stored successfully for task {} (local: {})", google_task.id, local_id),
            Err(e) => eprintln!("‚ùå Failed to store metadata for task {}: {}", google_task.id, e),
        }
    }

    Ok(TaskResponse {
        id: local_id,  // Return the stable local ID as the primary ID
        google_id: google_task.id,  // Also return the Google ID for reference
        title: google_task.title,
        notes: google_task.notes,
        due: google_task.due,
        status: google_task.status,
        position: google_task.position,
        updated: google_task.updated,
        priority: request.priority.unwrap_or_else(|| "none".to_string()),
        labels: request.labels.unwrap_or_default(),
    })
}

#[tauri::command]
pub async fn update_google_task(
    request: UpdateTaskRequest,
    google_tasks_service: State<'_, GoogleTasksService>,
    db_manager: State<'_, Arc<DatabaseManager>>,
) -> Result<TaskResponse, String> {
    // Look up the current Google ID from the local ID
    let id_mapping = crate::commands::tasks::id_map::get_task_id_mapping_by_local(
        request.task_id.clone(),
        db_manager.clone(),
    )
    .await?
    .ok_or_else(|| format!("No ID mapping found for local ID: {}", request.task_id))?;
    
    let google_task_id = id_mapping.google_task_id;
    let local_id = id_mapping.local_id.clone();
    
    // CRITICAL: Fetch current task state from Google to merge with updates
    let current_task = google_tasks_service
        .get_single_task(
            &request.account_id,
            &request.task_list_id,
            &google_task_id,
        )
        .await
        .map_err(|e| format!("Failed to fetch current task state: {}", e))?;
    
    // Merge updates with current state - ALWAYS send complete object
    let merged_input = UpdateTaskInput {
        title: request.title.or(Some(current_task.title)),
        notes: request.notes.or(current_task.notes),
        due: request.due.or(current_task.due),
        status: request.status.or(Some(current_task.status)),
    };
    
    // Update task in Google Tasks with COMPLETE merged data
    let google_task = google_tasks_service
        .update_task(
            &request.account_id,
            &request.task_list_id,
            &google_task_id,
            merged_input,
        )
        .await
        .map_err(|e| format!("Failed to update Google Task: {}", e))?;

    // Debug log to check if time_block is received
    eprintln!("üîµ TIMEBLOCK DEBUG - Update request received: task_id={}, has_time_block={}, time_block={:?}", 
        request.task_id, request.time_block.is_some(), request.time_block);
    
    // Also log the full request to see all fields (clone to avoid move issues)
    eprintln!("üîµ TIMEBLOCK DEBUG - Full update request: account_id={}, task_list_id={}, task_id={}, priority={:?}, labels={:?}", 
        request.account_id, request.task_list_id, request.task_id, request.priority, request.labels);
    
    // Update or create metadata in local DB if needed
    if request.priority.is_some() || request.labels.is_some() || request.time_block.is_some() {
        // First check if metadata exists (using Google ID)
        let existing_metadata = crate::commands::tasks::metadata::get_task_metadata(
            google_task_id.clone(),
            db_manager.clone(),
        )
        .await
        .ok()
        .flatten();
        
        if existing_metadata.is_some() {
            eprintln!("üîµ TIMEBLOCK DEBUG - Updating existing metadata for task {} (local: {})", google_task_id, local_id);
            // Update existing metadata
            match crate::commands::tasks::metadata::update_task_metadata(
                google_task_id.clone(),
                UpdateTaskMetadata {
                    priority: request.priority.clone(),
                    labels: request.labels.clone(),
                    subtasks: None,
                    time_block: request.time_block.clone(),
                },
                db_manager.clone(),
            )
            .await {
                Ok(_) => eprintln!("‚úÖ TIMEBLOCK DEBUG - Successfully updated metadata"),
                Err(e) => eprintln!("‚ùå TIMEBLOCK DEBUG - Failed to update metadata: {}", e),
            }
        } else {
            eprintln!("üîµ TIMEBLOCK DEBUG - Creating new metadata for task {} (local: {})", google_task_id, local_id);
            // Create new metadata
            match crate::commands::tasks::metadata::create_task_metadata(
                CreateTaskMetadata {
                    google_task_id: google_task_id.clone(),
                    task_list_id: request.task_list_id.clone(),
                    priority: request.priority.clone(),
                    labels: request.labels.clone(),
                    subtasks: None,
                    time_block: request.time_block.clone(),
                },
                db_manager.clone(),
            )
            .await {
                Ok(_) => eprintln!("‚úÖ TIMEBLOCK DEBUG - Successfully created metadata"),
                Err(e) => eprintln!("‚ùå TIMEBLOCK DEBUG - Failed to create metadata: {}", e),
            }
        }
    }

    // Get metadata from DB
    let metadata = crate::commands::tasks::metadata::get_task_metadata(
        google_task_id.clone(),
        db_manager.clone(),
    )
    .await
    .ok()
    .flatten();

    Ok(TaskResponse {
        id: local_id,  // Return the stable local ID as the primary ID
        google_id: google_task.id,  // Also return the Google ID for reference
        title: google_task.title,
        notes: google_task.notes,
        due: google_task.due,
        status: google_task.status,
        position: google_task.position,
        updated: google_task.updated,
        priority: metadata
            .as_ref()
            .map(|m| m.metadata.priority.clone())
            .unwrap_or_else(|| "none".to_string()),
        labels: metadata
            .as_ref()
            .map(|m| m.labels.iter().map(|l| l.name.clone()).collect())
            .unwrap_or_default(),
    })
}

#[tauri::command]
pub async fn delete_google_task(
    request: DeleteTaskRequest,
    google_tasks_service: State<'_, GoogleTasksService>,
    db_manager: State<'_, Arc<DatabaseManager>>,
) -> Result<(), String> {
    // Delete from Google Tasks
    google_tasks_service
        .delete_task(&request.account_id, &request.task_list_id, &request.task_id)
        .await
        .map_err(|e| format!("Failed to delete Google Task: {}", e))?;

    // Delete metadata from local DB
    let _ = crate::commands::tasks::metadata::delete_task_metadata(
        request.task_id.clone(),
        db_manager.clone(),
    )
    .await;

    Ok(())
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTaskListRequest {
    pub account_id: String,
    pub task_list_id: String,
    pub new_title: String,
}

#[tauri::command]
pub async fn update_google_task_list(
    request: UpdateTaskListRequest,
    google_tasks_service: State<'_, GoogleTasksService>,
) -> Result<(), String> {
    google_tasks_service
        .update_task_list(&request.account_id, &request.task_list_id, request.new_title)
        .await
        .map_err(|e| format!("Failed to update Google Task list: {}", e))?;

    Ok(())
}